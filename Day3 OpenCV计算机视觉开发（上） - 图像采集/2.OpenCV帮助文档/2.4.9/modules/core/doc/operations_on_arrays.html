
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Operations on Arrays &mdash; OpenCV 2.4.9.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 2.4.9.0 documentation" href="../../../index.html" />
    <link rel="up" title="core. The Core Functionality" href="core.html" />
    <link rel="next" title="Drawing Functions" href="drawing_functions.html" />
    <link rel="prev" title="Dynamic Structures" href="dynamic_structures.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="drawing_functions.html" title="Drawing Functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dynamic_structures.html" title="Dynamic Structures"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.9.0 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" accesskey="U">core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="operations-on-arrays">
<h1>Operations on Arrays<a class="headerlink" href="#operations-on-arrays" title="Permalink to this headline">¶</a></h1>
<div class="section" id="abs">
<h2>abs<a class="headerlink" href="#abs" title="Permalink to this headline">¶</a></h2>
<p>Calculates an absolute value of each matrix element.</p>
<dl class="function">
<dt id="MatExpr abs(const Mat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">abs</tt><big>(</big>const Mat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#MatExpr abs(const Mat& m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MatExpr abs(const MatExpr&amp; e)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">abs</tt><big>(</big>const MatExpr&amp; <strong>e</strong><big>)</big><a class="headerlink" href="#MatExpr abs(const MatExpr& e)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; matrix.</li>
<li><strong>e</strong> &#8211; matrix expression.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><tt class="docutils literal"><span class="pre">abs</span></tt> is a meta-function that is expanded to one of <a class="reference internal" href="#void absdiff(InputArray src1, InputArray src2, OutputArray dst)" title="void absdiff(InputArray src1, InputArray src2, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">absdiff()</span></tt></a> or <a class="reference internal" href="#void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)" title="void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">convertScaleAbs()</span></tt></a> forms:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">abs(A-B)</span></tt>     is equivalent to <tt class="docutils literal"><span class="pre">absdiff(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">abs(A)</span></tt>     is equivalent to <tt class="docutils literal"><span class="pre">absdiff(A,</span> <span class="pre">Scalar::all(0),</span> <span class="pre">C)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">Mat_&lt;Vec&lt;uchar,n&gt;</span> <span class="pre">&gt;(abs(A*alpha</span> <span class="pre">+</span> <span class="pre">beta))</span></tt>     is equivalent to  <tt class="docutils literal"><span class="pre">convertScaleAbs(A,</span> <span class="pre">C,</span> <span class="pre">alpha,</span> <span class="pre">beta)</span></tt></li>
</ul>
</div></blockquote>
<p>The output matrix has the same size and the same type as the input one except for the last case, where <tt class="docutils literal"><span class="pre">C</span></tt> is <tt class="docutils literal"><span class="pre">depth=CV_8U</span></tt> .</p>
<blockquote>
<div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a>, <a class="reference internal" href="#void absdiff(InputArray src1, InputArray src2, OutputArray dst)" title="void absdiff(InputArray src1, InputArray src2, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">absdiff()</span></tt></a>, <a class="reference internal" href="#void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)" title="void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">convertScaleAbs()</span></tt></a></p>
</div>
</div></blockquote>
</div>
<div class="section" id="absdiff">
<h2>absdiff<a class="headerlink" href="#absdiff" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element absolute difference between two arrays or between an array and a scalar.</p>
<dl class="function">
<dt id="void absdiff(InputArray src1, InputArray src2, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">absdiff</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void absdiff(InputArray src1, InputArray src2, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.absdiff">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">absdiff</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.absdiff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAbsDiff(const CvArr* src1, const CvArr* src2, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAbsDiff</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvAbsDiff(const CvArr* src1, const CvArr* src2, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAbsDiffS(const CvArr* src, CvArr* dst, CvScalar value)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAbsDiffS</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvScalar <strong>value</strong><big>)</big><a class="headerlink" href="#void cvAbsDiffS(const CvArr* src, CvArr* dst, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AbsDiff">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">AbsDiff</tt><big>(</big>src1, src2, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.AbsDiff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AbsDiffS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">AbsDiffS</tt><big>(</big>src, dst, value<big>)</big> &rarr; None<a class="headerlink" href="#cv.AbsDiffS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar.</li>
<li><strong>src</strong> &#8211; single input array.</li>
<li><strong>value</strong> &#8211; scalar value.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and type as input arrays.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">absdiff</span></tt> calculates:</p>
<blockquote>
<div><ul>
<li><p class="first">Absolute difference between two arrays when they have the same size and type:</p>
<div class="math">
<p><img src="../../../_images/math/476867d4baf53f6b8ae52e941268a31ce114a83d.png" alt="\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2}(I)|)"/></p>
</div></li>
<li><p class="first">Absolute difference between an array and a scalar when the second array is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has as many elements as the number of channels in <tt class="docutils literal"><span class="pre">src1</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/0f324bf3834cd4f19cf2476dc1836fa663d6b34b.png" alt="\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2} |)"/></p>
</div></li>
<li><p class="first">Absolute difference between a scalar and an array when the first array is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has as many elements as the number of channels in <tt class="docutils literal"><span class="pre">src2</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/69d9f062bcaad2bbac5e413016833352b6e6366b.png" alt="\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1} -  \texttt{src2}(I) |)"/></p>
</div><p>where  <tt class="docutils literal"><span class="pre">I</span></tt> is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.</p>
</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saturation is not applied when the arrays have the depth <tt class="docutils literal"><span class="pre">CV_32S</span></tt>. You may even get a negative value in the case of overflow.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#MatExpr abs(const Mat&amp; m)" title="MatExpr abs(const Mat&amp; m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">abs()</span></tt></a></p>
</div>
</div>
<div class="section" id="add">
<h2>add<a class="headerlink" href="#add" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element sum of two arrays or an array and a scalar.</p>
<dl class="function">
<dt id="void add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">add</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, InputArray <strong>mask</strong>=noArray(), int <strong>dtype</strong>=-1<big>)</big><a class="headerlink" href="#void add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.add">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">add</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, mask<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAdd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAdd</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvAdd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAddS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAddS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>value</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvAddS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Add">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Add</tt><big>(</big>src1, src2, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.Add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AddS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">AddS</tt><big>(</big>src, value, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.AddS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar.</li>
<li><strong>src</strong> &#8211; single input array.</li>
<li><strong>value</strong> &#8211; scalar value.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and number of channels as the input array(s); the depth is defined by <tt class="docutils literal"><span class="pre">dtype</span></tt> or <tt class="docutils literal"><span class="pre">src1</span></tt>/<tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>mask</strong> &#8211; optional operation mask - 8-bit single channel array, that specifies elements of the output array to be changed.</li>
<li><strong>dtype</strong> &#8211; optional depth of the output array (see the discussion below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">add</span></tt> calculates:</p>
<blockquote>
<div><ul>
<li><p class="first">Sum of two arrays when both input arrays have the same size and the same number of channels:</p>
<div class="math">
<p><img src="../../../_images/math/0277d44c813e079d941c0bc076efc96e4c3639f5.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0"/></p>
</div></li>
<li><p class="first">Sum of an array and a scalar when <tt class="docutils literal"><span class="pre">src2</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src1.channels()</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/cd67b44060572ded182b1fddd8695d72c070259a.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0"/></p>
</div></li>
<li><p class="first">Sum of a scalar and an array when <tt class="docutils literal"><span class="pre">src1</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src2.channels()</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/506df4ebae98351a1b4baee6cbc07fd2f13e2d12.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0"/></p>
</div><p>where <tt class="docutils literal"><span class="pre">I</span></tt> is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.</p>
</li>
</ul>
</div></blockquote>
<p>The first function in the list above can be replaced with matrix expressions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">dst</span> <span class="o">=</span> <span class="n">src1</span> <span class="o">+</span> <span class="n">src2</span><span class="p">;</span>
<span class="n">dst</span> <span class="o">+=</span> <span class="n">src1</span><span class="p">;</span> <span class="c1">// equivalent to add(dst, src1, dst);</span>
</pre></div>
</div>
<p>The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the <tt class="docutils literal"><span class="pre">dtype</span></tt> parameter. In the second and third cases above, as well as in the first case, when <tt class="docutils literal"><span class="pre">src1.depth()</span> <span class="pre">==</span> <span class="pre">src2.depth()</span></tt>, <tt class="docutils literal"><span class="pre">dtype</span></tt> can be set to the default <tt class="docutils literal"><span class="pre">-1</span></tt>. In this case, the output array will have the same depth as the input array, be it <tt class="docutils literal"><span class="pre">src1</span></tt>, <tt class="docutils literal"><span class="pre">src2</span></tt> or both.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saturation is not applied when the output array has the depth <tt class="docutils literal"><span class="pre">CV_32S</span></tt>. You may even get result of an incorrect sign in the case of overflow.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">subtract()</span></tt></a>,
<a class="reference internal" href="#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)" title="void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">addWeighted()</span></tt></a>,
<a class="reference internal" href="#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)" title="void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">scaleAdd()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="addweighted">
<h2>addWeighted<a class="headerlink" href="#addweighted" title="Permalink to this headline">¶</a></h2>
<p>Calculates the weighted sum of two arrays.</p>
<dl class="function">
<dt id="void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">addWeighted</tt><big>(</big>InputArray <strong>src1</strong>, double <strong>alpha</strong>, InputArray <strong>src2</strong>, double <strong>beta</strong>, double <strong>gamma</strong>, OutputArray <strong>dst</strong>, int <strong>dtype</strong>=-1<big>)</big><a class="headerlink" href="#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.addWeighted">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">addWeighted</tt><big>(</big>src1, alpha, src2, beta, gamma<span class="optional">[</span>, dst<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.addWeighted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAddWeighted(const CvArr* src1, double alpha, const CvArr* src2, double beta, double gamma, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAddWeighted</tt><big>(</big>const CvArr* <strong>src1</strong>, double <strong>alpha</strong>, const CvArr* <strong>src2</strong>, double <strong>beta</strong>, double <strong>gamma</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvAddWeighted(const CvArr* src1, double alpha, const CvArr* src2, double beta, double gamma, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AddWeighted">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">AddWeighted</tt><big>(</big>src1, alpha, src2, beta, gamma, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.AddWeighted" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>alpha</strong> &#8211; weight of the first array elements.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and channel number as  <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>beta</strong> &#8211; weight of the second array elements.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and number of channels as the input arrays.</li>
<li><strong>gamma</strong> &#8211; scalar added to each sum.</li>
<li><strong>dtype</strong> &#8211; optional depth of the output array; when both input arrays have the same depth, <tt class="docutils literal"><span class="pre">dtype</span></tt> can be set to <tt class="docutils literal"><span class="pre">-1</span></tt>, which will be equivalent to <tt class="docutils literal"><span class="pre">src1.depth()</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">addWeighted</span></tt> calculates the weighted sum of two arrays as follows:</p>
<div class="math">
<p><img src="../../../_images/math/160c3479896ac799bb5c7d260a052e6b35c463ef.png" alt="\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )"/></p>
</div><p>where <tt class="docutils literal"><span class="pre">I</span></tt> is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.</p>
<p>The function can be replaced with a matrix expression:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">dst</span> <span class="o">=</span> <span class="n">src1</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">src2</span><span class="o">*</span><span class="n">beta</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saturation is not applied when the output array has the depth <tt class="docutils literal"><span class="pre">CV_32S</span></tt>. You may even get result of an incorrect sign in the case of overflow.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../contrib/doc/openfabmap.html#virtual void add(const Mat&amp; queryImgDescriptor)" title="virtual void add(const Mat&amp; queryImgDescriptor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">add()</span></tt></a>,
<a class="reference internal" href="#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">subtract()</span></tt></a>,
<a class="reference internal" href="#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)" title="void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">scaleAdd()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="bitwise-and">
<h2>bitwise_and<a class="headerlink" href="#bitwise-and" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element bit-wise conjunction of two arrays or an array and a scalar.</p>
<dl class="function">
<dt id="void bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">bitwise_and</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.bitwise_and">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">bitwise_and</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.bitwise_and" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAnd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAnd</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvAnd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAndS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAndS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>value</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvAndS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.And">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">And</tt><big>(</big>src1, src2, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.And" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AndS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">AndS</tt><big>(</big>src, value, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.AndS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar.</li>
<li><strong>src</strong> &#8211; single input array.</li>
<li><strong>value</strong> &#8211; scalar value.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and type as the input arrays.</li>
<li><strong>mask</strong> &#8211; optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the per-element bit-wise logical conjunction for:</p>
<blockquote>
<div><ul>
<li><p class="first">Two arrays when <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">src2</span></tt> have the same size:</p>
<div class="math">
<p><img src="../../../_images/math/2f22b4609c680cf8a1a0151f1ceb33f453300f04.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0"/></p>
</div></li>
<li><p class="first">An array and a scalar when <tt class="docutils literal"><span class="pre">src2</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src1.channels()</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/78c2251ac74f9d613a28b7782927431d6737a3c4.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0"/></p>
</div></li>
<li><p class="first">A scalar and an array when <tt class="docutils literal"><span class="pre">src1</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src2.channels()</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/383e83e94d7d953be836e0ae9a4dccb6a62e8a69.png" alt="\texttt{dst} (I) =  \texttt{src1}  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0"/></p>
</div></li>
</ul>
</div></blockquote>
<p>In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.</p>
</div>
<div class="section" id="bitwise-not">
<h2>bitwise_not<a class="headerlink" href="#bitwise-not" title="Permalink to this headline">¶</a></h2>
<p>Inverts every bit of an array.</p>
<dl class="function">
<dt id="void bitwise_not(InputArray src, OutputArray dst, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">bitwise_not</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void bitwise_not(InputArray src, OutputArray dst, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.bitwise_not">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">bitwise_not</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.bitwise_not" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvNot(const CvArr* src, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvNot</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvNot(const CvArr* src, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Not">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Not</tt><big>(</big>src, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Not" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and type as the input array.</li>
<li><strong>mask</strong> &#8211; optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates per-element bit-wise inversion of the input array:</p>
<div class="math">
<p><img src="../../../_images/math/310e8c1f76943ba41a6fabf907721d57b826e63e.png" alt="\texttt{dst} (I) =  \neg \texttt{src} (I)"/></p>
</div><p>In case of a floating-point input array, its machine-specific bit representation (usually IEEE754-compliant) is used for the operation. In case of multi-channel arrays, each channel is processed independently.</p>
</div>
<div class="section" id="bitwise-or">
<h2>bitwise_or<a class="headerlink" href="#bitwise-or" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element bit-wise disjunction of two arrays or an array and a scalar.</p>
<dl class="function">
<dt id="void bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">bitwise_or</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.bitwise_or">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">bitwise_or</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.bitwise_or" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvOr(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvOr</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvOr(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvOrS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvOrS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>value</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvOrS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Or">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Or</tt><big>(</big>src1, src2, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.Or" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.OrS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">OrS</tt><big>(</big>src, value, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.OrS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar.</li>
<li><strong>src</strong> &#8211; single input array.</li>
<li><strong>value</strong> &#8211; scalar value.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and type as the input arrays.</li>
<li><strong>mask</strong> &#8211; optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the per-element bit-wise logical disjunction for:</p>
<blockquote>
<div><ul>
<li><p class="first">Two arrays when <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">src2</span></tt> have the same size:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/4cf9f5456f4c0f8ed149cbb35c1ebc098408fd03.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0"/></p>
</div></div></blockquote>
</li>
<li><p class="first">An array and a scalar when <tt class="docutils literal"><span class="pre">src2</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src1.channels()</span></tt>:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/23ef10103cd814635b58e6c9f633d68472c27d25.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0"/></p>
</div></div></blockquote>
</li>
<li><p class="first">A scalar and an array when <tt class="docutils literal"><span class="pre">src1</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src2.channels()</span></tt>:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/d62d98568402b1a7d159774c3d92a8f94852b40e.png" alt="\texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0"/></p>
</div></div></blockquote>
</li>
</ul>
</div></blockquote>
<p>In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.</p>
</div>
<div class="section" id="bitwise-xor">
<h2>bitwise_xor<a class="headerlink" href="#bitwise-xor" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element bit-wise &#8220;exclusive or&#8221; operation on two arrays or an array and a scalar.</p>
<dl class="function">
<dt id="void bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">bitwise_xor</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.bitwise_xor">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">bitwise_xor</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.bitwise_xor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvXor(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvXor</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvXor(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvXorS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvXorS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>value</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvXorS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Xor">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Xor</tt><big>(</big>src1, src2, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.Xor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.XorS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">XorS</tt><big>(</big>src, value, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.XorS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar.</li>
<li><strong>src</strong> &#8211; single input array.</li>
<li><strong>value</strong> &#8211; scalar value.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and type as the input arrays.</li>
<li><strong>mask</strong> &#8211; optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the per-element bit-wise logical &#8220;exclusive-or&#8221; operation for:</p>
<blockquote>
<div><ul>
<li><p class="first">Two arrays when <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">src2</span></tt> have the same size:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/cd58aaa26cb910a1aa437e2ebaf57ab0b154edf2.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0"/></p>
</div></div></blockquote>
</li>
<li><p class="first">An array and a scalar when <tt class="docutils literal"><span class="pre">src2</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src1.channels()</span></tt>:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/b1983ab01f378caeae7f9166884dff92110d2709.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0"/></p>
</div></div></blockquote>
</li>
<li><p class="first">A scalar and an array when <tt class="docutils literal"><span class="pre">src1</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src2.channels()</span></tt>:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/edc9676cc423928b99cfb2f52133eec887103291.png" alt="\texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0"/></p>
</div></div></blockquote>
</li>
</ul>
</div></blockquote>
<p>In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the 2nd and 3rd cases above, the scalar is first converted to the array type.</p>
</div>
<div class="section" id="calccovarmatrix">
<h2>calcCovarMatrix<a class="headerlink" href="#calccovarmatrix" title="Permalink to this headline">¶</a></h2>
<p>Calculates the covariance matrix of a set of vectors.</p>
<dl class="function">
<dt id="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">calcCovarMatrix</tt><big>(</big>const Mat* <strong>samples</strong>, int <strong>nsamples</strong>, Mat&amp; <strong>covar</strong>, Mat&amp; <strong>mean</strong>, int <strong>flags</strong>, int <strong>ctype</strong>=CV_64F<big>)</big><a class="headerlink" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void calcCovarMatrix(InputArray samples, OutputArray covar, OutputArray mean, int flags, int ctype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">calcCovarMatrix</tt><big>(</big>InputArray <strong>samples</strong>, OutputArray <strong>covar</strong>, OutputArray <strong>mean</strong>, int <strong>flags</strong>, int <strong>ctype</strong>=CV_64F<big>)</big><a class="headerlink" href="#void calcCovarMatrix(InputArray samples, OutputArray covar, OutputArray mean, int flags, int ctype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.calcCovarMatrix">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">calcCovarMatrix</tt><big>(</big>samples, flags<span class="optional">[</span>, covar<span class="optional">[</span>, mean<span class="optional">[</span>, ctype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; covar, mean<a class="headerlink" href="#cv2.calcCovarMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCalcCovarMatrix(const CvArr** vects, int count, CvArr* cov_mat, CvArr* avg, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCalcCovarMatrix</tt><big>(</big>const CvArr** <strong>vects</strong>, int <strong>count</strong>, CvArr* <strong>cov_mat</strong>, CvArr* <strong>avg</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void cvCalcCovarMatrix(const CvArr** vects, int count, CvArr* cov_mat, CvArr* avg, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CalcCovarMatrix">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">CalcCovarMatrix</tt><big>(</big>vects, covMat, avg, flags<big>)</big> &rarr; None<a class="headerlink" href="#cv.CalcCovarMatrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>samples</strong> &#8211; samples stored either as separate matrices or as rows/columns of a single matrix.</li>
<li><strong>nsamples</strong> &#8211; number of samples when they are stored separately.</li>
<li><strong>covar</strong> &#8211; output covariance matrix of the type <tt class="docutils literal"><span class="pre">ctype</span></tt> and square size.</li>
<li><strong>ctype</strong> &#8211; type of the matrixl; it equals &#8216;CV_64F&#8217; by default.</li>
<li><strong>mean</strong> &#8211; input or output (depending on the flags) array as the average value of the input vectors.</li>
<li><strong>vects</strong> &#8211; a set of vectors.</li>
<li><strong>flags</strong> &#8211; <p>operation flags as a combination of the following values:</p>
<ul>
<li><strong>CV_COVAR_SCRAMBLED</strong> The output covariance matrix is calculated as:<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/3682242154dbbc0cbc9af33ce8ec3c5d09ce0035.png" alt="\texttt{scale}   \cdot  [  \texttt{vects}  [0]-  \texttt{mean}  , \texttt{vects}  [1]-  \texttt{mean}  ,...]^T  \cdot  [ \texttt{vects}  [0]- \texttt{mean}  , \texttt{vects}  [1]- \texttt{mean}  ,...],"/></p>
</div><p>The covariance matrix will be  <tt class="docutils literal"><span class="pre">nsamples</span> <span class="pre">x</span> <span class="pre">nsamples</span></tt>. Such an unusual covariance matrix is used for fast PCA of a set of very large vectors (see, for example, the EigenFaces technique for face recognition). Eigenvalues of this &#8220;scrambled&#8221; matrix match the eigenvalues of the true covariance matrix. The &#8220;true&#8221; eigenvectors can be easily calculated from the eigenvectors of the &#8220;scrambled&#8221; covariance matrix.</p>
</div></blockquote>
</li>
<li><strong>CV_COVAR_NORMAL</strong> The output covariance matrix is calculated as:<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/c1f37b3ac35c18157df5b664e24b4bd0f6963c71.png" alt="\texttt{scale}   \cdot  [  \texttt{vects}  [0]-  \texttt{mean}  , \texttt{vects}  [1]-  \texttt{mean}  ,...]  \cdot  [ \texttt{vects}  [0]- \texttt{mean}  , \texttt{vects}  [1]- \texttt{mean}  ,...]^T,"/></p>
</div><p><tt class="docutils literal"><span class="pre">covar</span></tt>  will be a square matrix of the same size as the total number of elements in each input vector. One and only one of  <tt class="docutils literal"><span class="pre">CV_COVAR_SCRAMBLED</span></tt>  and <tt class="docutils literal"><span class="pre">CV_COVAR_NORMAL</span></tt>  must be specified.</p>
</div></blockquote>
</li>
<li><strong>CV_COVAR_USE_AVG</strong> If the flag is specified, the function does not calculate  <tt class="docutils literal"><span class="pre">mean</span></tt>  from the input vectors but, instead, uses the passed  <tt class="docutils literal"><span class="pre">mean</span></tt>  vector. This is useful if  <tt class="docutils literal"><span class="pre">mean</span></tt>  has been pre-calculated or known in advance, or if the covariance matrix is calculated by parts. In this case, <tt class="docutils literal"><span class="pre">mean</span></tt>  is not a mean vector of the input sub-set of vectors but rather the mean vector of the whole set.</li>
<li><strong>CV_COVAR_SCALE</strong> If the flag is specified, the covariance matrix is scaled. In the &#8220;normal&#8221; mode,  <tt class="docutils literal"><span class="pre">scale</span></tt>  is  <tt class="docutils literal"><span class="pre">1./nsamples</span></tt> . In the &#8220;scrambled&#8221; mode,  <tt class="docutils literal"><span class="pre">scale</span></tt>  is the reciprocal of the total number of elements in each input vector. By default (if the flag is not specified), the covariance matrix is not scaled (  <tt class="docutils literal"><span class="pre">scale=1</span></tt> ).</li>
<li><strong>CV_COVAR_ROWS</strong> [Only useful in the second variant of the function] If the flag is specified, all the input vectors are stored as rows of the  <tt class="docutils literal"><span class="pre">samples</span></tt>  matrix.  <tt class="docutils literal"><span class="pre">mean</span></tt>  should be a single-row vector in this case.</li>
<li><strong>CV_COVAR_COLS</strong> [Only useful in the second variant of the function] If the flag is specified, all the input vectors are stored as columns of the  <tt class="docutils literal"><span class="pre">samples</span></tt>  matrix.  <tt class="docutils literal"><span class="pre">mean</span></tt>  should be a single-column vector in this case.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">calcCovarMatrix</span></tt> calculate the covariance matrix and, optionally, the mean vector of the set of input vectors.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PCA" title="class PCA"><tt class="xref ocv ocv-class docutils literal"><span class="pre">PCA</span></tt></a>,
<a class="reference internal" href="#void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)" title="void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mulTransposed()</span></tt></a>,
<a class="reference internal" href="#double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar)" title="double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mahalanobis()</span></tt></a></p>
</div>
</div>
<div class="section" id="carttopolar">
<h2>cartToPolar<a class="headerlink" href="#carttopolar" title="Permalink to this headline">¶</a></h2>
<p>Calculates the magnitude and angle of 2D vectors.</p>
<dl class="function">
<dt id="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">cartToPolar</tt><big>(</big>InputArray <strong>x</strong>, InputArray <strong>y</strong>, OutputArray <strong>magnitude</strong>, OutputArray <strong>angle</strong>, bool <strong>angleInDegrees</strong>=false<big>)</big><a class="headerlink" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.cartToPolar">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">cartToPolar</tt><big>(</big>x, y<span class="optional">[</span>, magnitude<span class="optional">[</span>, angle<span class="optional">[</span>, angleInDegrees<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; magnitude, angle<a class="headerlink" href="#cv2.cartToPolar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCartToPolar(const CvArr* x, const CvArr* y, CvArr* magnitude, CvArr* angle, int angle_in_degrees)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCartToPolar</tt><big>(</big>const CvArr* <strong>x</strong>, const CvArr* <strong>y</strong>, CvArr* <strong>magnitude</strong>, CvArr* <strong>angle</strong>=NULL, int <strong>angle_in_degrees</strong>=0 <big>)</big><a class="headerlink" href="#void cvCartToPolar(const CvArr* x, const CvArr* y, CvArr* magnitude, CvArr* angle, int angle_in_degrees)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CartToPolar">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">CartToPolar</tt><big>(</big>x, y, magnitude, angle=None, angleInDegrees=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.CartToPolar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; array of x-coordinates; this must be a single-precision or double-precision floating-point array.</li>
<li><strong>y</strong> &#8211; array of y-coordinates, that must have the same size and same type as <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
<li><strong>magnitude</strong> &#8211; output array of magnitudes of the same size and type as <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
<li><strong>angle</strong> &#8211; output array of angles that has the same size and type as <tt class="docutils literal"><span class="pre">x</span></tt>; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees).</li>
<li><strong>angleInDegrees</strong> &#8211; a flag, indicating whether the angles are measured in radians (which is by default), or in degrees.</li>
<li><strong>angle_in_degrees</strong> &#8211; a flag, indicating whether the angles are measured in radians, or in degrees (specific to C syntax).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">cartToPolar</span></tt> calculates either the magnitude, angle, or both for every 2D vector (x(I),y(I)):</p>
<div class="math">
<p><img src="../../../_images/math/78693973e52930b60324dd5d43f5eae01d653dff.png" alt="\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array}"/></p>
</div><p>The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../imgproc/doc/filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/filtering.html#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></tt></a></p>
</div>
</div>
<div class="section" id="checkrange">
<h2>checkRange<a class="headerlink" href="#checkrange" title="Permalink to this headline">¶</a></h2>
<p>Checks every element of an input array for invalid values.</p>
<dl class="function">
<dt id="bool checkRange(InputArray a, bool quiet, Point* pos, double minVal, double maxVal)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descname">checkRange</tt><big>(</big>InputArray <strong>a</strong>, bool <strong>quiet</strong>=true, Point* <strong>pos</strong>=0, double <strong>minVal</strong>=-DBL_MAX, double <strong>maxVal</strong>=DBL_MAX <big>)</big><a class="headerlink" href="#bool checkRange(InputArray a, bool quiet, Point* pos, double minVal, double maxVal)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.checkRange">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">checkRange</tt><big>(</big>a<span class="optional">[</span>, quiet<span class="optional">[</span>, minVal<span class="optional">[</span>, maxVal<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval, pos<a class="headerlink" href="#cv2.checkRange" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; input array.</li>
<li><strong>quiet</strong> &#8211; a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception.</li>
<li><strong>pos</strong> &#8211; optional output parameter, where the position of the first outlier is stored; in the second function <tt class="docutils literal"><span class="pre">pos</span></tt>, when not NULL, must be a pointer to array of <tt class="docutils literal"><span class="pre">src.dims</span></tt> elements.</li>
<li><strong>minVal</strong> &#8211; inclusive lower boundary of valid values range.</li>
<li><strong>maxVal</strong> &#8211; exclusive upper boundary of valid values range.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">checkRange</span></tt> check that every array element is neither NaN nor
infinite. When <tt class="docutils literal"><span class="pre">minVal</span> <span class="pre">&lt;</span> <span class="pre">-DBL_MAX</span></tt> and <tt class="docutils literal"><span class="pre">maxVal</span> <span class="pre">&lt;</span> <span class="pre">DBL_MAX</span></tt>, the functions also check that each value is between <tt class="docutils literal"><span class="pre">minVal</span></tt> and <tt class="docutils literal"><span class="pre">maxVal</span></tt>. In case of multi-channel arrays, each channel is processed independently.
If some values are out of range, position of the first outlier is stored in <tt class="docutils literal"><span class="pre">pos</span></tt> (when
<tt class="docutils literal"><span class="pre">pos</span> <span class="pre">!=</span> <span class="pre">NULL</span></tt>). Then, the functions either return false (when <tt class="docutils literal"><span class="pre">quiet=true</span></tt>) or throw an exception.</p>
</div>
<div class="section" id="compare">
<h2>compare<a class="headerlink" href="#compare" title="Permalink to this headline">¶</a></h2>
<p>Performs the per-element comparison of two arrays or an array and scalar value.</p>
<dl class="function">
<dt id="void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">compare</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, int <strong>cmpop</strong><big>)</big><a class="headerlink" href="#void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.compare">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">compare</tt><big>(</big>src1, src2, cmpop<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.compare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCmp(const CvArr* src1, const CvArr* src2, CvArr* dst, int cmp_op)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCmp</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, int <strong>cmp_op</strong><big>)</big><a class="headerlink" href="#void cvCmp(const CvArr* src1, const CvArr* src2, CvArr* dst, int cmp_op)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Cmp">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Cmp</tt><big>(</big>src1, src2, dst, cmpOp<big>)</big> &rarr; None<a class="headerlink" href="#cv.Cmp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCmpS(const CvArr* src, double value, CvArr* dst, int cmp_op)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCmpS</tt><big>(</big>const CvArr* <strong>src</strong>, double <strong>value</strong>, CvArr* <strong>dst</strong>, int <strong>cmp_op</strong><big>)</big><a class="headerlink" href="#void cvCmpS(const CvArr* src, double value, CvArr* dst, int cmp_op)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CmpS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">CmpS</tt><big>(</big>src, value, dst, cmpOp<big>)</big> &rarr; None<a class="headerlink" href="#cv.CmpS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar (in the case of <tt class="docutils literal"><span class="pre">cvCmp</span></tt>, <tt class="docutils literal"><span class="pre">cv.Cmp</span></tt>, <tt class="docutils literal"><span class="pre">cvCmpS</span></tt>, <tt class="docutils literal"><span class="pre">cv.CmpS</span></tt> it is always an array); when it is an array, it must have a single channel.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar (in the case of <tt class="docutils literal"><span class="pre">cvCmp</span></tt> and <tt class="docutils literal"><span class="pre">cv.Cmp</span></tt> it is always an array; in the case of <tt class="docutils literal"><span class="pre">cvCmpS</span></tt>, <tt class="docutils literal"><span class="pre">cv.CmpS</span></tt> it is always a scalar); when it is an array, it must have a single channel.</li>
<li><strong>src</strong> &#8211; single input array.</li>
<li><strong>value</strong> &#8211; scalar value.</li>
<li><strong>dst</strong> &#8211; output array that has the same size and type as the input arrays.</li>
<li><strong>cmpop</strong> &#8211; <p>a flag, that specifies correspondence between the arrays:</p>
<ul>
<li><strong>CMP_EQ</strong> <tt class="docutils literal"><span class="pre">src1</span></tt> is equal to <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>CMP_GT</strong> <tt class="docutils literal"><span class="pre">src1</span></tt> is greater than <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>CMP_GE</strong> <tt class="docutils literal"><span class="pre">src1</span></tt> is greater than or equal to <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>CMP_LT</strong> <tt class="docutils literal"><span class="pre">src1</span></tt> is less than <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>CMP_LE</strong> <tt class="docutils literal"><span class="pre">src1</span></tt> is less than or equal to <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>CMP_NE</strong> <tt class="docutils literal"><span class="pre">src1</span></tt> is unequal to <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function compares:</p>
<blockquote>
<div><ul>
<li><p class="first">Elements of two arrays when <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">src2</span></tt> have the same size:</p>
<div class="math">
<p><img src="../../../_images/math/1ce52482a74e48aea5ed77252cd1f690fc8b907c.png" alt="\texttt{dst} (I) =  \texttt{src1} (I)  \,\texttt{cmpop}\, \texttt{src2} (I)"/></p>
</div></li>
<li><p class="first">Elements of <tt class="docutils literal"><span class="pre">src1</span></tt> with a scalar <tt class="docutils literal"><span class="pre">src2</span></tt> when <tt class="docutils literal"><span class="pre">src2</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has a single element:</p>
<div class="math">
<p><img src="../../../_images/math/0d16526f067a635170c856d7efb6c178d213a00d.png" alt="\texttt{dst} (I) =  \texttt{src1}(I) \,\texttt{cmpop}\,  \texttt{src2}"/></p>
</div></li>
<li><p class="first"><tt class="docutils literal"><span class="pre">src1</span></tt> with elements of <tt class="docutils literal"><span class="pre">src2</span></tt> when <tt class="docutils literal"><span class="pre">src1</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has a single element:</p>
<div class="math">
<p><img src="../../../_images/math/e79b6188d919b13794e63c4ba15cae22c7622549.png" alt="\texttt{dst} (I) =  \texttt{src1}  \,\texttt{cmpop}\, \texttt{src2} (I)"/></p>
</div></li>
</ul>
</div></blockquote>
<p>When the comparison result is true, the corresponding element of output array is set to 255.
The comparison operations can be replaced with the equivalent matrix expressions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">dst1</span> <span class="o">=</span> <span class="n">src1</span> <span class="o">&gt;=</span> <span class="n">src2</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">dst2</span> <span class="o">=</span> <span class="n">src1</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#bool checkRange(InputArray a, bool quiet, Point* pos, double minVal, double maxVal)" title="bool checkRange(InputArray a, bool quiet, Point* pos, double minVal, double maxVal)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">checkRange()</span></tt></a>,
<a class="reference internal" href="#MatExpr min(const Mat&amp; a, const Mat&amp; b)" title="MatExpr min(const Mat&amp; a, const Mat&amp; b)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">min()</span></tt></a>,
<a class="reference internal" href="#MatExpr max(const Mat&amp; a, const Mat&amp; b)" title="MatExpr max(const Mat&amp; a, const Mat&amp; b)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">max()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/miscellaneous_transformations.html#double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)" title="double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">threshold()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="completesymm">
<h2>completeSymm<a class="headerlink" href="#completesymm" title="Permalink to this headline">¶</a></h2>
<p>Copies the lower or the upper half of a square matrix to another half.</p>
<dl class="function">
<dt id="void completeSymm(InputOutputArray mtx, bool lowerToUpper)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">completeSymm</tt><big>(</big>InputOutputArray <strong>mtx</strong>, bool <strong>lowerToUpper</strong>=false<big>)</big><a class="headerlink" href="#void completeSymm(InputOutputArray mtx, bool lowerToUpper)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.completeSymm">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">completeSymm</tt><big>(</big>mtx<span class="optional">[</span>, lowerToUpper<span class="optional">]</span><big>)</big> &rarr; None<a class="headerlink" href="#cv2.completeSymm" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mtx</strong> &#8211; input-output floating-point square matrix.</li>
<li><strong>lowerToUpper</strong> &#8211; operation flag; if true, the lower half is copied to the upper half. Otherwise, the upper half is copied to the lower half.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">completeSymm</span></tt> copies the lower half of a square matrix to its another half. The matrix diagonal remains unchanged:</p>
<blockquote>
<div><ul class="simple">
<li><img class="math" src="../../../_images/math/11208783a5571965b987a90e51f3da82e4576f21.png" alt="\texttt{mtx}_{ij}=\texttt{mtx}_{ji}"/>     for
<img class="math" src="../../../_images/math/23166a59a6df7d262929f4e7e4803c9da65e6504.png" alt="i &gt; j"/>     if <tt class="docutils literal"><span class="pre">lowerToUpper=false</span></tt></li>
<li><img class="math" src="../../../_images/math/11208783a5571965b987a90e51f3da82e4576f21.png" alt="\texttt{mtx}_{ij}=\texttt{mtx}_{ji}"/>     for
<img class="math" src="../../../_images/math/478f5d7d31a103e7a383486cdf317eb599ac9ebf.png" alt="i &lt; j"/>     if <tt class="docutils literal"><span class="pre">lowerToUpper=true</span></tt></li>
</ul>
</div></blockquote>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void flip(InputArray src, OutputArray dst, int flipCode)" title="void flip(InputArray src, OutputArray dst, int flipCode)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">flip()</span></tt></a>,
<a class="reference internal" href="#void transpose(InputArray src, OutputArray dst)" title="void transpose(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transpose()</span></tt></a></p>
</div>
</div>
<div class="section" id="convertscaleabs">
<h2>convertScaleAbs<a class="headerlink" href="#convertscaleabs" title="Permalink to this headline">¶</a></h2>
<p>Scales, calculates absolute values, and converts the result to 8-bit.</p>
<dl class="function">
<dt id="void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">convertScaleAbs</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, double <strong>alpha</strong>=1, double <strong>beta</strong>=0<big>)</big><a class="headerlink" href="#void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.convertScaleAbs">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">convertScaleAbs</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, alpha<span class="optional">[</span>, beta<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.convertScaleAbs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvConvertScaleAbs(const CvArr* src, CvArr* dst, double scale, double shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvConvertScaleAbs</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>scale</strong>=1, double <strong>shift</strong>=0<big>)</big><a class="headerlink" href="#void cvConvertScaleAbs(const CvArr* src, CvArr* dst, double scale, double shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ConvertScaleAbs">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">ConvertScaleAbs</tt><big>(</big>src, dst, scale=1.0, shift=0.0<big>)</big> &rarr; None<a class="headerlink" href="#cv.ConvertScaleAbs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array.</li>
<li><strong>alpha</strong> &#8211; optional scale factor.</li>
<li><strong>beta</strong> &#8211; optional delta added to the scaled values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>On each element of the input array, the function <tt class="docutils literal"><span class="pre">convertScaleAbs</span></tt> performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type:</p>
<div class="math">
<p><img src="../../../_images/math/5ca28093f0a8eca32bcf6d54a644b4bcaa07ad72.png" alt="\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)"/></p>
</div><p>In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the <tt class="docutils literal"><span class="pre">Mat::convertTo</span></tt> method (or by using matrix expressions) and then by calculating an absolute value of the result. For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">);</span>
<span class="n">randu</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">),</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
<span class="c1">// Mat_&lt;float&gt; B = abs(A*5+3) will also do the job,</span>
<span class="c1">// but it will allocate a temporary matrix</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>,
<a class="reference internal" href="#MatExpr abs(const Mat&amp; m)" title="MatExpr abs(const Mat&amp; m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">abs()</span></tt></a></p>
</div>
</div>
<div class="section" id="countnonzero">
<h2>countNonZero<a class="headerlink" href="#countnonzero" title="Permalink to this headline">¶</a></h2>
<p>Counts non-zero array elements.</p>
<dl class="function">
<dt id="int countNonZero(InputArray src)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">countNonZero</tt><big>(</big>InputArray <strong>src</strong><big>)</big><a class="headerlink" href="#int countNonZero(InputArray src)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.countNonZero">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">countNonZero</tt><big>(</big>src<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.countNonZero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvCountNonZero(const CvArr* arr)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvCountNonZero</tt><big>(</big>const CvArr* <strong>arr</strong><big>)</big><a class="headerlink" href="#int cvCountNonZero(const CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CountNonZero">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">CountNonZero</tt><big>(</big>arr<big>)</big> &rarr; int<a class="headerlink" href="#cv.CountNonZero" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src</strong> &#8211; single-channel array.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns the number of non-zero elements in <tt class="docutils literal"><span class="pre">src</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/3892358598b615817bf6864f9aea40fe1f6160ad.png" alt="\sum _{I: \; \texttt{src} (I) \ne0 } 1"/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Scalar mean(InputArray src, InputArray mask)" title="Scalar mean(InputArray src, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mean()</span></tt></a>,
<a class="reference internal" href="#void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)" title="void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">meanStdDev()</span></tt></a>,
<a class="reference internal" href="#double norm(InputArray src1, int normType, InputArray mask)" title="double norm(InputArray src1, int normType, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">norm()</span></tt></a>,
<a class="reference internal" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minMaxLoc()</span></tt></a>,
<a class="reference internal" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)" title="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcCovarMatrix()</span></tt></a></p>
</div>
</div>
<div class="section" id="cvarrtomat">
<h2>cvarrToMat<a class="headerlink" href="#cvarrtomat" title="Permalink to this headline">¶</a></h2>
<p>Converts <tt class="docutils literal"><span class="pre">CvMat</span></tt>, <tt class="docutils literal"><span class="pre">IplImage</span></tt> , or <tt class="docutils literal"><span class="pre">CvMatND</span></tt> to <tt class="docutils literal"><span class="pre">Mat</span></tt>.</p>
<dl class="function">
<dt id="Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">cvarrToMat</tt><big>(</big>const CvArr* <strong>arr</strong>, bool <strong>copyData</strong>=false, bool <strong>allowND</strong>=true, int <strong>coiMode</strong>=0 <big>)</big><a class="headerlink" href="#Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; input <tt class="docutils literal"><span class="pre">CvMat</span></tt>, <tt class="docutils literal"><span class="pre">IplImage</span></tt> , or  <tt class="docutils literal"><span class="pre">CvMatND</span></tt>.</li>
<li><strong>copyData</strong> &#8211; when false (default value), no data is copied and only the new header is created, in this case, the original array should not be deallocated while the new matrix header is used; if the parameter is true, all the data is copied and you may deallocate the original array right after the conversion.</li>
<li><strong>allowND</strong> &#8211; when true (default value), <tt class="docutils literal"><span class="pre">CvMatND</span></tt> is converted to 2-dimensional <tt class="docutils literal"><span class="pre">Mat</span></tt>, if it is possible (see the discussion below); if it is not possible, or when the parameter is false, the function will report an error.</li>
<li><strong>coiMode</strong> &#8211; <p>parameter specifying how the IplImage COI (when set) is handled.</p>
<ul>
<li>If  <tt class="docutils literal"><span class="pre">coiMode=0</span></tt> and COI is set, the function reports an error.</li>
<li>If  <tt class="docutils literal"><span class="pre">coiMode=1</span></tt> , the function never reports an error. Instead, it returns the header to the whole original image and you will have to check and process COI manually. See  <a class="reference internal" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">extractImageCOI()</span></tt></a> .</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">cvarrToMat</span></tt> converts <tt class="docutils literal"><span class="pre">CvMat</span></tt>, <tt class="docutils literal"><span class="pre">IplImage</span></tt> , or <tt class="docutils literal"><span class="pre">CvMatND</span></tt> header to
<a class="reference internal" href="basic_structures.html#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> header, and optionally duplicates the underlying data. The constructed header is returned by the function.</p>
<p>When <tt class="docutils literal"><span class="pre">copyData=false</span></tt> , the conversion is done really fast (in O(1) time) and the newly created matrix header will have <tt class="docutils literal"><span class="pre">refcount=0</span></tt> , which means that no reference counting is done for the matrix data. In this case, you have to preserve the data until the new header is destructed. Otherwise, when <tt class="docutils literal"><span class="pre">copyData=true</span></tt> , the new buffer is allocated and managed as if you created a new matrix from scratch and copied the data there. That is, <tt class="docutils literal"><span class="pre">cvarrToMat(arr,</span> <span class="pre">true)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">cvarrToMat(arr,</span> <span class="pre">false).clone()</span></tt> (assuming that COI is not set). The function provides a uniform way of supporting
<tt class="docutils literal"><span class="pre">CvArr</span></tt> paradigm in the code that is migrated to use new-style data structures internally. The reverse transformation, from
<tt class="docutils literal"><span class="pre">Mat</span></tt> to
<tt class="docutils literal"><span class="pre">CvMat</span></tt> or
<tt class="docutils literal"><span class="pre">IplImage</span></tt> can be done by a simple assignment:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">CvMat</span><span class="o">*</span> <span class="n">A</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
<span class="n">cvSetIdentity</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">IplImage</span> <span class="n">A1</span><span class="p">;</span> <span class="n">cvGetImage</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A1</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">B</span> <span class="o">=</span> <span class="n">cvarrToMat</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">B1</span> <span class="o">=</span> <span class="n">cvarrToMat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A1</span><span class="p">);</span>
<span class="n">IplImage</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>
<span class="n">CvMat</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">B1</span><span class="p">;</span>
<span class="c1">// now A, A1, B, B1, C and C1 are different headers</span>
<span class="c1">// for the same 10x10 floating-point array.</span>
<span class="c1">// note that you will need to use &quot;&amp;&quot;</span>
<span class="c1">// to pass C &amp; C1 to OpenCV functions, for example:</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cvNorm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">C1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CV_L2</span><span class="p">));</span>
</pre></div>
</div>
<p>Normally, the function is used to convert an old-style 2D array (
<tt class="docutils literal"><span class="pre">CvMat</span></tt> or
<tt class="docutils literal"><span class="pre">IplImage</span></tt> ) to <tt class="docutils literal"><span class="pre">Mat</span></tt> . However, the function can also take
<tt class="docutils literal"><span class="pre">CvMatND</span></tt> as an input and create
<tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat()</span></tt> for it, if it is possible. And, for <tt class="docutils literal"><span class="pre">CvMatND</span> <span class="pre">A</span></tt> , it is possible if and only if <tt class="docutils literal"><span class="pre">A.dim[i].size*A.dim.step[i]</span> <span class="pre">==</span> <span class="pre">A.dim.step[i-1]</span></tt> for all or for all but one <tt class="docutils literal"><span class="pre">i,</span> <span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">A.dims</span></tt> . That is, the matrix data should be continuous or it should be representable as a sequence of continuous matrices. By using this function in this way, you can process
<tt class="docutils literal"><span class="pre">CvMatND</span></tt> using an arbitrary element-wise function.</p>
<p>The last parameter, <tt class="docutils literal"><span class="pre">coiMode</span></tt> , specifies how to deal with an image with COI set. By default, it is 0 and the function reports an error when an image with COI comes in. And <tt class="docutils literal"><span class="pre">coiMode=1</span></tt> means that no error is signalled. You have to check COI presence and handle it manually. The modern structures, such as
<a class="reference internal" href="basic_structures.html#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> and
<tt class="docutils literal"><span class="pre">MatND</span></tt> do not support COI natively. To process an individual channel of a new-style array, you need either to organize a loop over the array (for example, using matrix iterators) where the channel of interest will be processed, or extract the COI using
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> (for new-style arrays) or
<a class="reference internal" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">extractImageCOI()</span></tt></a> (for old-style arrays), process this individual channel, and insert it back to the output array if needed (using
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> or
<a class="reference internal" href="#void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)" title="void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">insertImageCOI()</span></tt></a> , respectively).</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="old_basic_structures.html#IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)" title="IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvGetImage()</span></tt></a>,
<a class="reference internal" href="old_basic_structures.html#CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)" title="CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvGetMat()</span></tt></a>,
<a class="reference internal" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">extractImageCOI()</span></tt></a>,
<a class="reference internal" href="#void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)" title="void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">insertImageCOI()</span></tt></a>,
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a></p>
</div>
</div>
<div class="section" id="dct">
<h2>dct<a class="headerlink" href="#dct" title="Permalink to this headline">¶</a></h2>
<p>Performs a forward or inverse discrete Cosine transform of 1D or 2D array.</p>
<dl class="function">
<dt id="void dct(InputArray src, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">dct</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=0<big>)</big><a class="headerlink" href="#void dct(InputArray src, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.dct">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">dct</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.dct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDCT(const CvArr* src, CvArr* dst, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvDCT</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void cvDCT(const CvArr* src, CvArr* dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.DCT">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">DCT</tt><big>(</big>src, dst, flags<big>)</big> &rarr; None<a class="headerlink" href="#cv.DCT" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input floating-point array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>flags</strong> &#8211; <p>transformation flags as a combination of the following values:</p>
<ul>
<li><strong>DCT_INVERSE</strong> performs an inverse 1D or 2D transform instead of the default forward transform.</li>
<li><strong>DCT_ROWS</strong> performs a forward or inverse transform of every individual row of the input matrix. This flag enables you to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself) to perform 3D and higher-dimensional transforms and so forth.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">dct</span></tt> performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D floating-point array:</p>
<ul>
<li><p class="first">Forward Cosine transform of a 1D vector of <tt class="docutils literal"><span class="pre">N</span></tt> elements:</p>
<div class="math">
<p><img src="../../../_images/math/4696cbded1f80b1b15adaaa1855239e183b470df.png" alt="Y = C^{(N)}  \cdot X"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/656ab918b8bb4bdb54a2c2c59df3ac1deee50195.png" alt="C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )"/></p>
</div><p>and</p>
<p><img class="math" src="../../../_images/math/5303093010740cf1bed2cf02c7c58b13ae0f37a3.png" alt="\alpha_0=1"/>, <img class="math" src="../../../_images/math/efe05d426c875df68fbecfb244c629b279fa8db4.png" alt="\alpha_j=2"/> for <em>j &gt; 0</em>.</p>
</li>
<li><p class="first">Inverse Cosine transform of a 1D vector of <tt class="docutils literal"><span class="pre">N</span></tt> elements:</p>
<div class="math">
<p><img src="../../../_images/math/d154ed25a5dd68356574b291c62b985466abd02d.png" alt="X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y"/></p>
</div><p>(since
<img class="math" src="../../../_images/math/fbb70b93ebd5683f964376cca2d83fd700d55c9b.png" alt="C^{(N)}"/> is an orthogonal matrix,
<img class="math" src="../../../_images/math/8e3d15c8d69223e91a4d67e0379594d5463bf740.png" alt="C^{(N)} \cdot \left(C^{(N)}\right)^T = I"/> )</p>
</li>
<li><p class="first">Forward 2D Cosine transform of <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> matrix:</p>
<div class="math">
<p><img src="../../../_images/math/17da33bf01f599a3b0d2b236964b75fc209467f0.png" alt="Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T"/></p>
</div></li>
<li><p class="first">Inverse 2D Cosine transform of <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> matrix:</p>
<div class="math">
<p><img src="../../../_images/math/b95601c913a148af8df7936f317a4acd09bb8741.png" alt="X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)}"/></p>
</div></li>
</ul>
<p>The function chooses the mode of operation by looking at the flags and size of the input array:</p>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">DCT_INVERSE)</span> <span class="pre">==</span> <span class="pre">0</span></tt> , the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform.</li>
<li>If <tt class="docutils literal"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">DCT_ROWS)</span> <span class="pre">!=</span> <span class="pre">0</span></tt> , the function performs a 1D transform of each row.</li>
<li>If the array is a single column or a single row, the function performs a 1D transform.</li>
<li>If none of the above is true, the function performs a 2D transform.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Currently <tt class="docutils literal"><span class="pre">dct</span></tt> supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you can pad the array when necessary.</p>
<p>Also, the function performance depends very much, and not monotonically, on the array size (see
<a class="reference internal" href="#int getOptimalDFTSize(int vecsize)" title="int getOptimalDFTSize(int vecsize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalDFTSize()</span></tt></a> ). In the current implementation DCT of a vector of size <tt class="docutils literal"><span class="pre">N</span></tt> is calculated via DFT of a vector of size <tt class="docutils literal"><span class="pre">N/2</span></tt> . Thus, the optimal DCT size <tt class="docutils literal"><span class="pre">N1</span> <span class="pre">&gt;=</span> <span class="pre">N</span></tt> can be calculated as:</p>
<div class="last highlight-cpp"><div class="highlight"><pre><span class="n">size_t</span> <span class="n">getOptimalDCTSize</span><span class="p">(</span><span class="n">size_t</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">getOptimalDFTSize</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
<span class="n">N1</span> <span class="o">=</span> <span class="n">getOptimalDCTSize</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a> , <a class="reference internal" href="#int getOptimalDFTSize(int vecsize)" title="int getOptimalDFTSize(int vecsize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalDFTSize()</span></tt></a> , <a class="reference internal" href="#void idct(InputArray src, OutputArray dst, int flags)" title="void idct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">idct()</span></tt></a></p>
</div>
</div>
<div class="section" id="dft">
<h2>dft<a class="headerlink" href="#dft" title="Permalink to this headline">¶</a></h2>
<p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</p>
<dl class="function">
<dt id="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">dft</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=0, int <strong>nonzeroRows</strong>=0<big>)</big><a class="headerlink" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.dft">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">dft</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">[</span>, nonzeroRows<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.dft" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDFT(const CvArr* src, CvArr* dst, int flags, int nonzero_rows)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvDFT</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>flags</strong>, int <strong>nonzero_rows</strong>=0 <big>)</big><a class="headerlink" href="#void cvDFT(const CvArr* src, CvArr* dst, int flags, int nonzero_rows)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.DFT">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">DFT</tt><big>(</big>src, dst, flags, nonzeroRows=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.DFT" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array that could be real or complex.</li>
<li><strong>dst</strong> &#8211; output array whose size and type depends on the  <tt class="docutils literal"><span class="pre">flags</span></tt> .</li>
<li><strong>flags</strong> &#8211; <p>transformation flags, representing a combination of the following values:</p>
<ul>
<li><strong>DFT_INVERSE</strong> performs an inverse 1D or 2D transform instead of the default forward transform.</li>
<li><strong>DFT_SCALE</strong> scales the result: divide it by the number of array elements. Normally, it is combined with  <tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt>.</li>
<li><strong>DFT_ROWS</strong> performs a forward or inverse transform of every individual row of the input matrix; this flag enables you to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself) to perform 3D and higher-dimensional transformations and so forth.</li>
<li><strong>DFT_COMPLEX_OUTPUT</strong> performs a forward transformation of 1D or 2D real array; the result, though being a complex array, has complex-conjugate symmetry (<em>CCS</em>, see the function description below for details), and such an array can be packed into a real array of the same size as input, which is the fastest option and which is what the function does by default; however, you may wish to get a full complex array (for simpler spectrum analysis, and so on) - pass the flag to enable the function to produce a full-size complex output array.</li>
<li><strong>DFT_REAL_OUTPUT</strong> performs an inverse transformation of a 1D or 2D complex array; the result is normally a complex array of the same size, however, if the input array has conjugate-complex symmetry (for example, it is a result of forward transformation with  <tt class="docutils literal"><span class="pre">DFT_COMPLEX_OUTPUT</span></tt>  flag), the output is a real array; while the function itself does not check whether the input is symmetrical or not, you can pass the flag and then the function will assume the symmetry and produce the real output array (note that when the input is packed into a real array and inverse transformation is executed, the function treats the input as a packed complex-conjugate symmetrical array, and the output will also be a real array).</li>
</ul>
</li>
<li><strong>nonzeroRows</strong> &#8211; when the parameter is not zero, the function assumes that only the first <tt class="docutils literal"><span class="pre">nonzeroRows</span></tt> rows of the input array (<tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt> is not set) or only the first <tt class="docutils literal"><span class="pre">nonzeroRows</span></tt> of the output array (<tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt> is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function performs one of the following:</p>
<ul>
<li><p class="first">Forward the Fourier transform of a 1D vector of <tt class="docutils literal"><span class="pre">N</span></tt> elements:</p>
<div class="math">
<p><img src="../../../_images/math/89c208fbbf95b34a05d97a3801d841834c176f9c.png" alt="Y = F^{(N)}  \cdot X,"/></p>
</div><p>where
<img class="math" src="../../../_images/math/cd51d0c583036fc69905bf658a5cacfab063ac4a.png" alt="F^{(N)}_{jk}=\exp(-2\pi i j k/N)"/> and
<img class="math" src="../../../_images/math/75952e52a3dc061d24146c0df9062a54a5ce5a5e.png" alt="i=\sqrt{-1}"/></p>
</li>
<li><p class="first">Inverse the Fourier transform of a 1D vector of <tt class="docutils literal"><span class="pre">N</span></tt> elements:</p>
<div class="math">
<p><img src="../../../_images/math/26a528be6328f2f146573ecb5c4d453e76d2072b.png" alt="\begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array}"/></p>
</div><p>where
<img class="math" src="../../../_images/math/38746d76a1a92aa0a376d01320ae3cf1ccaaa843.png" alt="F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T"/></p>
</li>
<li><p class="first">Forward the 2D Fourier transform of a <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> matrix:</p>
<div class="math">
<p><img src="../../../_images/math/26d18de8a605ff0fbee7475b5d564a2486a907f8.png" alt="Y = F^{(M)}  \cdot X  \cdot F^{(N)}"/></p>
</div></li>
<li><p class="first">Inverse the 2D Fourier transform of a <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> matrix:</p>
<div class="math">
<p><img src="../../../_images/math/2d69d454c4a6349926414336bdadc176eea1ca7e.png" alt="\begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array}"/></p>
</div></li>
</ul>
<p>In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called <em>CCS</em> (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D <em>CCS</em> spectrum looks:</p>
<div class="math">
<p><img src="../../../_images/math/58ca3a644fb9956e8f953c8f9cc56891cea21ece.png" alt="\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp;  \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2}  \\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp;  \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2}  \\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp;  \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2}  \\ \hdotsfor{9} \\ Re Y_{M/2-1,0} &amp;  Re Y_{M-3,1}  &amp; Im Y_{M-3,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2}  \\ Im Y_{M/2-1,0} &amp;  Re Y_{M-2,1}  &amp; Im Y_{M-2,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2}  \\ Re Y_{M/2,0}  &amp;  Re Y_{M-1,1} &amp;  Im Y_{M-1,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix}"/></p>
</div><p>In case of 1D transform of a real vector, the output looks like the first row of the matrix above.</p>
<p>So, the function chooses an operation mode depending on the flags and size of the input array:</p>
<blockquote>
<div><ul>
<li><p class="first">If <tt class="docutils literal"><span class="pre">DFT_ROWS</span></tt> is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when <tt class="docutils literal"><span class="pre">DFT_ROWS</span></tt> is set. Otherwise, it performs a 2D transform.</p>
</li>
<li><p class="first">If the input array is real and <tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt> is not set, the function performs a forward 1D or 2D transform:</p>
<blockquote>
<div><ul class="simple">
<li>When <tt class="docutils literal"><span class="pre">DFT_COMPLEX_OUTPUT</span></tt> is set, the output is a complex matrix of the same size as input.</li>
<li>When <tt class="docutils literal"><span class="pre">DFT_COMPLEX_OUTPUT</span></tt> is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the <tt class="docutils literal"><span class="pre">DFT_ROWS</span></tt>         flag), each row of the output matrix looks like the first row of the matrix above.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">If the input array is complex and either <tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt>     or <tt class="docutils literal"><span class="pre">DFT_REAL_OUTPUT</span></tt>     are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags <tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt> and <tt class="docutils literal"><span class="pre">DFT_ROWS</span></tt>.</p>
</li>
<li><p class="first">When <tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt> is set and the input array is real, or it is complex but <tt class="docutils literal"><span class="pre">DFT_REAL_OUTPUT</span></tt>     is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags <tt class="docutils literal"><span class="pre">DFT_INVERSE</span></tt> and <tt class="docutils literal"><span class="pre">DFT_ROWS</span></tt>.</p>
</li>
</ul>
</div></blockquote>
<p>If <tt class="docutils literal"><span class="pre">DFT_SCALE</span></tt> is set, the scaling is done after the transformation.</p>
<p>Unlike <a class="reference internal" href="#void dct(InputArray src, OutputArray dst, int flags)" title="void dct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dct()</span></tt></a> , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the <a class="reference internal" href="#int getOptimalDFTSize(int vecsize)" title="int getOptimalDFTSize(int vecsize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalDFTSize()</span></tt></a> method.</p>
<p>The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="n">convolveDFT</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">A</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">B</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// reallocate the output array if needed</span>
    <span class="n">C</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="n">B</span><span class="p">.</span><span class="n">rows</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span> <span class="o">-</span> <span class="n">B</span><span class="p">.</span><span class="n">cols</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">dftSize</span><span class="p">;</span>
    <span class="c1">// calculate the size of DFT transform</span>
    <span class="n">dftSize</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">getOptimalDFTSize</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">B</span><span class="p">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">dftSize</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">getOptimalDFTSize</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">B</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// allocate temporary buffers and initialize them with 0&#39;s</span>
    <span class="n">Mat</span> <span class="n">tempA</span><span class="p">(</span><span class="n">dftSize</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">Mat</span> <span class="n">tempB</span><span class="p">(</span><span class="n">dftSize</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="c1">// copy A and B to the top-left corners of tempA and tempB, respectively</span>
    <span class="n">Mat</span> <span class="n">roiA</span><span class="p">(</span><span class="n">tempA</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">A</span><span class="p">.</span><span class="n">rows</span><span class="p">));</span>
    <span class="n">A</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">roiA</span><span class="p">);</span>
    <span class="n">Mat</span> <span class="n">roiB</span><span class="p">(</span><span class="n">tempB</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">B</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">B</span><span class="p">.</span><span class="n">rows</span><span class="p">));</span>
    <span class="n">B</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">roiB</span><span class="p">);</span>

    <span class="c1">// now transform the padded A &amp; B in-place;</span>
    <span class="c1">// use &quot;nonzeroRows&quot; hint for faster processing</span>
    <span class="n">dft</span><span class="p">(</span><span class="n">tempA</span><span class="p">,</span> <span class="n">tempA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>
    <span class="n">dft</span><span class="p">(</span><span class="n">tempB</span><span class="p">,</span> <span class="n">tempB</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>

    <span class="c1">// multiply the spectrums;</span>
    <span class="c1">// the function handles packed spectrum representations well</span>
    <span class="n">mulSpectrums</span><span class="p">(</span><span class="n">tempA</span><span class="p">,</span> <span class="n">tempB</span><span class="p">,</span> <span class="n">tempA</span><span class="p">);</span>

    <span class="c1">// transform the product back from the frequency domain.</span>
    <span class="c1">// Even though all the result rows will be non-zero,</span>
    <span class="c1">// you need only the first C.rows of them, and thus you</span>
    <span class="c1">// pass nonzeroRows == C.rows</span>
    <span class="n">dft</span><span class="p">(</span><span class="n">tempA</span><span class="p">,</span> <span class="n">tempA</span><span class="p">,</span> <span class="n">DFT_INVERSE</span> <span class="o">+</span> <span class="n">DFT_SCALE</span><span class="p">,</span> <span class="n">C</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>

    <span class="c1">// now copy the result back to C.</span>
    <span class="n">tempA</span><span class="p">(</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">C</span><span class="p">.</span><span class="n">rows</span><span class="p">)).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>

    <span class="c1">// all the temporary buffers will be deallocated automatically</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To optimize this sample, consider the following approaches:</p>
<ul class="simple">
<li>Since <tt class="docutils literal"><span class="pre">nonzeroRows</span> <span class="pre">!=</span> <span class="pre">0</span></tt> is passed to the forward transform calls and since  <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are copied to the top-left corners of <tt class="docutils literal"><span class="pre">tempA</span></tt> and <tt class="docutils literal"><span class="pre">tempB</span></tt>, respectively, it is not necessary to clear the whole <tt class="docutils literal"><span class="pre">tempA</span></tt> and <tt class="docutils literal"><span class="pre">tempB</span></tt>. It is only necessary to clear the <tt class="docutils literal"><span class="pre">tempA.cols</span> <span class="pre">-</span> <span class="pre">A.cols</span></tt> ( <tt class="docutils literal"><span class="pre">tempB.cols</span> <span class="pre">-</span> <span class="pre">B.cols</span></tt>) rightmost columns of the matrices.</li>
<li>This DFT-based convolution does not have to be applied to the whole big arrays, especially if <tt class="docutils literal"><span class="pre">B</span></tt>     is significantly smaller than <tt class="docutils literal"><span class="pre">A</span></tt> or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array <tt class="docutils literal"><span class="pre">C</span></tt>     into multiple tiles. For each tile, estimate which parts of <tt class="docutils literal"><span class="pre">A</span></tt>     and <tt class="docutils literal"><span class="pre">B</span></tt>     are required to calculate convolution in this tile. If the tiles in <tt class="docutils literal"><span class="pre">C</span></tt>     are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in <tt class="docutils literal"><span class="pre">C</span></tt>     is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays <tt class="docutils literal"><span class="pre">tempA</span></tt>     and <tt class="docutils literal"><span class="pre">tempB</span></tt>     become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle.</li>
<li>If different tiles in <tt class="docutils literal"><span class="pre">C</span></tt>     can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded.</li>
</ul>
<p>All of the above improvements have been implemented in <a class="reference internal" href="../../imgproc/doc/object_detection.html#void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)" title="void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">matchTemplate()</span></tt></a> and <a class="reference internal" href="../../imgproc/doc/filtering.html#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a> . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to &#8220;flip&#8221; the second convolution operand <tt class="docutils literal"><span class="pre">B</span></tt> vertically and horizontally using <a class="reference internal" href="#void flip(InputArray src, OutputArray dst, int flipCode)" title="void flip(InputArray src, OutputArray dst, int flipCode)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">flip()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dct(InputArray src, OutputArray dst, int flags)" title="void dct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dct()</span></tt></a> , <a class="reference internal" href="#int getOptimalDFTSize(int vecsize)" title="int getOptimalDFTSize(int vecsize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalDFTSize()</span></tt></a> , <a class="reference internal" href="#void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)" title="void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mulSpectrums()</span></tt></a>, <a class="reference internal" href="../../imgproc/doc/filtering.html#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a> , <a class="reference internal" href="../../imgproc/doc/object_detection.html#void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)" title="void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">matchTemplate()</span></tt></a> , <a class="reference internal" href="#void flip(InputArray src, OutputArray dst, int flipCode)" title="void flip(InputArray src, OutputArray dst, int flipCode)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">flip()</span></tt></a> , <a class="reference internal" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a> , <a class="reference internal" href="#void magnitude(InputArray x, InputArray y, OutputArray magnitude)" title="void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">magnitude()</span></tt></a> , <a class="reference internal" href="#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)" title="void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">phase()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp</li>
<li>(Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python2/deconvolution.py</li>
<li>(Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python2/dft.py</li>
</ul>
</div>
</div>
<div class="section" id="divide">
<h2>divide<a class="headerlink" href="#divide" title="Permalink to this headline">¶</a></h2>
<p>Performs per-element division of two arrays or a scalar by an array.</p>
<dl class="function">
<dt id="void divide(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">divide</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, double <strong>scale</strong>=1, int <strong>dtype</strong>=-1<big>)</big><a class="headerlink" href="#void divide(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void divide(double scale, InputArray src2, OutputArray dst, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">divide</tt><big>(</big>double <strong>scale</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, int <strong>dtype</strong>=-1<big>)</big><a class="headerlink" href="#void divide(double scale, InputArray src2, OutputArray dst, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.divide">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">divide</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, scale<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.divide" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt>
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">divide</tt><big>(</big>scale, src2<span class="optional">[</span>, dst<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst</dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDiv(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvDiv</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, double <strong>scale</strong>=1<big>)</big><a class="headerlink" href="#void cvDiv(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Div">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Div</tt><big>(</big>src1, src2, dst, scale=1<big>)</big> &rarr; None<a class="headerlink" href="#cv.Div" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>scale</strong> &#8211; scalar factor.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>dtype</strong> &#8211; optional depth of the output array; if <tt class="docutils literal"><span class="pre">-1</span></tt>, <tt class="docutils literal"><span class="pre">dst</span></tt> will have depth <tt class="docutils literal"><span class="pre">src2.depth()</span></tt>, but in case of an array-by-array division, you can only pass <tt class="docutils literal"><span class="pre">-1</span></tt> when <tt class="docutils literal"><span class="pre">src1.depth()==src2.depth()</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">divide</span></tt> divide one array by another:</p>
<div class="math">
<p><img src="../../../_images/math/b95a5073fc087b8fc404bc7795982e1570891bd3.png" alt="\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}"/></p>
</div><p>or a scalar by an array when there is no <tt class="docutils literal"><span class="pre">src1</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/8d762e1a527b3613404ec26a98faffd43d1ceb78.png" alt="\texttt{dst(I) = saturate(scale/src2(I))}"/></p>
</div><p>When <tt class="docutils literal"><span class="pre">src2(I)</span></tt> is zero, <tt class="docutils literal"><span class="pre">dst(I)</span></tt> will also be zero. Different channels of multi-channel arrays are processed independently.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saturation is not applied when the output array has the depth <tt class="docutils literal"><span class="pre">CV_32S</span></tt>. You may even get result of an incorrect sign in the case of overflow.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)" title="void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">multiply()</span></tt></a>,
<a class="reference internal" href="../../contrib/doc/openfabmap.html#virtual void add(const Mat&amp; queryImgDescriptor)" title="virtual void add(const Mat&amp; queryImgDescriptor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">add()</span></tt></a>,
<a class="reference internal" href="#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">subtract()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="determinant">
<h2>determinant<a class="headerlink" href="#determinant" title="Permalink to this headline">¶</a></h2>
<p>Returns the determinant of a square floating-point matrix.</p>
<dl class="function">
<dt id="double determinant(InputArray mtx)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">determinant</tt><big>(</big>InputArray <strong>mtx</strong><big>)</big><a class="headerlink" href="#double determinant(InputArray mtx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.determinant">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">determinant</tt><big>(</big>mtx<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.determinant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvDet(const CvArr* mat)">
<strong>C:</strong><tt class="descname"> </tt>double <tt class="descname">cvDet</tt><big>(</big>const CvArr* <strong>mat</strong><big>)</big><a class="headerlink" href="#double cvDet(const CvArr* mat)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Det">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Det</tt><big>(</big>mat<big>)</big> &rarr; float<a class="headerlink" href="#cv.Det" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mtx</strong> &#8211; input matrix that must have <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="docutils literal"><span class="pre">CV_64FC1</span></tt> type and square size.</li>
<li><strong>mat</strong> &#8211; input matrix that must have <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="docutils literal"><span class="pre">CV_64FC1</span></tt> type and square size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">determinant</span></tt> calculates and returns the determinant of the specified matrix. For small matrices ( <tt class="docutils literal"><span class="pre">mtx.cols=mtx.rows&lt;=3</span></tt> ),
the direct method is used. For larger matrices, the function uses LU factorization with partial pivoting.</p>
<p>For symmetric positively-determined matrices, it is also possible to use <a class="reference internal" href="#bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)" title="bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">eigen()</span></tt></a> decomposition to calculate the determinant.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Scalar trace(InputArray mtx)" title="Scalar trace(InputArray mtx)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">trace()</span></tt></a>,
<a class="reference internal" href="#double invert(InputArray src, OutputArray dst, int flags)" title="double invert(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">invert()</span></tt></a>,
<a class="reference internal" href="#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)" title="bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">solve()</span></tt></a>,
<a class="reference internal" href="#bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)" title="bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">eigen()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="eigen">
<h2>eigen<a class="headerlink" href="#eigen" title="Permalink to this headline">¶</a></h2>
<p>Calculates eigenvalues and eigenvectors of a symmetric matrix.</p>
<dl class="function">
<dt id="bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descname">eigen</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>eigenvalues</strong>, int <strong>lowindex</strong>=-1, int <strong>highindex</strong>=-1<big>)</big><a class="headerlink" href="#bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors, int lowindex,int highindex)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descname">eigen</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>eigenvalues</strong>, OutputArray <strong>eigenvectors</strong>, int <strong>lowindex</strong>=-1, int <strong>highindex</strong>=-1<big>)</big><a class="headerlink" href="#bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors, int lowindex,int highindex)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.eigen">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">eigen</tt><big>(</big>src, computeEigenvectors<span class="optional">[</span>, eigenvalues<span class="optional">[</span>, eigenvectors<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval, eigenvalues, eigenvectors<a class="headerlink" href="#cv2.eigen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvEigenVV(CvArr* mat, CvArr* evects, CvArr* evals, double eps, int lowindex, int highindex)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvEigenVV</tt><big>(</big>CvArr* <strong>mat</strong>, CvArr* <strong>evects</strong>, CvArr* <strong>evals</strong>, double <strong>eps</strong>=0, int <strong>lowindex</strong>=-1, int <strong>highindex</strong>=-1 <big>)</big><a class="headerlink" href="#void cvEigenVV(CvArr* mat, CvArr* evects, CvArr* evals, double eps, int lowindex, int highindex)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.EigenVV">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">EigenVV</tt><big>(</big>mat, evects, evals, eps, lowindex=-1, highindex=-1<big>)</big> &rarr; None<a class="headerlink" href="#cv.EigenVV" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input matrix that must have <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt> or <tt class="docutils literal"><span class="pre">CV_64FC1</span></tt> type, square size and be symmetrical (<tt class="docutils literal"><span class="pre">src</span></tt> <sup>T</sup> == <tt class="docutils literal"><span class="pre">src</span></tt>).</li>
<li><strong>eigenvalues</strong> &#8211; output vector of eigenvalues of the same type as <tt class="docutils literal"><span class="pre">src</span></tt>; the eigenvalues are stored in the descending order.</li>
<li><strong>eigenvectors</strong> &#8211; output matrix of eigenvectors; it has the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>; the eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.</li>
<li><strong>lowindex</strong> &#8211; optional index of largest eigenvalue/-vector to calculate; the parameter is ignored in the current implementation.</li>
<li><strong>highindex</strong> &#8211; optional index of smallest eigenvalue/-vector to calculate; the parameter is ignored in the current implementation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">eigen</span></tt> calculate just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix <tt class="docutils literal"><span class="pre">src</span></tt> :</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">src</span><span class="o">*</span><span class="n">eigenvectors</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">t</span><span class="p">()</span> <span class="o">=</span> <span class="n">eigenvalues</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">srcType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">eigenvectors</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">t</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in the new and the old interfaces different ordering of eigenvalues and eigenvectors parameters is used.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void completeSymm(InputOutputArray mtx, bool lowerToUpper)" title="void completeSymm(InputOutputArray mtx, bool lowerToUpper)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">completeSymm()</span></tt></a> , <a class="reference internal" href="#PCA" title="class PCA"><tt class="xref ocv ocv-class docutils literal"><span class="pre">PCA</span></tt></a></p>
</div>
</div>
<div class="section" id="exp">
<h2>exp<a class="headerlink" href="#exp" title="Permalink to this headline">¶</a></h2>
<p>Calculates the exponent of every array element.</p>
<dl class="function">
<dt id="void exp(InputArray src, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">exp</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void exp(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.exp">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">exp</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.exp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvExp(const CvArr* src, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvExp</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvExp(const CvArr* src, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Exp">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Exp</tt><big>(</big>src, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Exp" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">exp</span></tt> calculates the exponent of every element of the input array:</p>
<div class="math">
<p><img src="../../../_images/math/46bb08a14279534d964e0163b30c07dc5bb04795.png" alt="\texttt{dst} [I] = e^{ src(I) }"/></p>
</div><p>The maximum relative error is about <tt class="docutils literal"><span class="pre">7e-6</span></tt> for single-precision input and less than <tt class="docutils literal"><span class="pre">1e-10</span></tt> for double-precision input. Currently, the function converts denormalized values to zeros on output. Special values (NaN, Inf) are not handled.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void log(InputArray src, OutputArray dst)" title="void log(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">log()</span></tt></a> , <a class="reference internal" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a> , <a class="reference internal" href="#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)" title="void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">polarToCart()</span></tt></a> , <a class="reference internal" href="#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)" title="void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">phase()</span></tt></a> , <a class="reference internal" href="#void pow(InputArray src, double power, OutputArray dst)" title="void pow(InputArray src, double power, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pow()</span></tt></a> , <a class="reference internal" href="#void sqrt(InputArray src, OutputArray dst)" title="void sqrt(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sqrt()</span></tt></a> , <a class="reference internal" href="#void magnitude(InputArray x, InputArray y, OutputArray magnitude)" title="void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">magnitude()</span></tt></a></p>
</div>
</div>
<div class="section" id="extractimagecoi">
<h2>extractImageCOI<a class="headerlink" href="#extractimagecoi" title="Permalink to this headline">¶</a></h2>
<p>Extracts the selected image channel.</p>
<dl class="function">
<dt id="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">extractImageCOI</tt><big>(</big>const CvArr* <strong>arr</strong>, OutputArray <strong>coiimg</strong>, int <strong>coi</strong>=-1 <big>)</big><a class="headerlink" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; input array; it should be a pointer to <tt class="docutils literal"><span class="pre">CvMat</span></tt> or <tt class="docutils literal"><span class="pre">IplImage</span></tt>.</li>
<li><strong>coiimg</strong> &#8211; output array with a single channel and the same size and depth as <tt class="docutils literal"><span class="pre">arr</span></tt>.</li>
<li><strong>coi</strong> &#8211; if the parameter is <tt class="docutils literal"><span class="pre">&gt;=0</span></tt>, it specifies the channel to extract, if it is <tt class="docutils literal"><span class="pre">&lt;0</span></tt> and <tt class="docutils literal"><span class="pre">arr</span></tt> is a pointer to <tt class="docutils literal"><span class="pre">IplImage</span></tt> with a valid COI set, the selected COI is extracted.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">extractImageCOI</span></tt> is used to extract an image COI from an old-style array and put the result to the new-style C++ matrix. As usual, the output matrix is reallocated using <tt class="docutils literal"><span class="pre">Mat::create</span></tt> if needed.</p>
<p>To extract a channel from a new-style matrix, use
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> or
<a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> , <a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> , <a class="reference internal" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="void merge(const Mat* mv, size_t count, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">merge()</span></tt></a> , <a class="reference internal" href="#Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)" title="Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cvarrToMat()</span></tt></a> , <a class="reference internal" href="old_basic_structures.html#void cvSetImageCOI(IplImage* image, int coi)" title="void cvSetImageCOI(IplImage* image, int coi)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvSetImageCOI()</span></tt></a> , <a class="reference internal" href="old_basic_structures.html#int cvGetImageCOI(const IplImage* image)" title="int cvGetImageCOI(const IplImage* image)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvGetImageCOI()</span></tt></a></p>
</div>
</div>
<div class="section" id="insertimagecoi">
<h2>insertImageCOI<a class="headerlink" href="#insertimagecoi" title="Permalink to this headline">¶</a></h2>
<p>Copies the selected image channel from a new-style C++ matrix to the old-style C array.</p>
<dl class="function">
<dt id="void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">insertImageCOI</tt><big>(</big>InputArray <strong>coiimg</strong>, CvArr* <strong>arr</strong>, int <strong>coi</strong>=-1 <big>)</big><a class="headerlink" href="#void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coiimg</strong> &#8211; input array with a single channel and the same size and depth as <tt class="docutils literal"><span class="pre">arr</span></tt>.</li>
<li><strong>arr</strong> &#8211; output array, it should be a pointer to <tt class="docutils literal"><span class="pre">CvMat</span></tt> or <tt class="docutils literal"><span class="pre">IplImage</span></tt>.</li>
<li><strong>coi</strong> &#8211; if the parameter is <tt class="docutils literal"><span class="pre">&gt;=0</span></tt>, it specifies the channel to insert, if it is <tt class="docutils literal"><span class="pre">&lt;0</span></tt> and <tt class="docutils literal"><span class="pre">arr</span></tt> is a pointer to <tt class="docutils literal"><span class="pre">IplImage</span></tt> with a  valid COI set, the selected COI is extracted.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">insertImageCOI</span></tt> is used to extract an image COI from a new-style C++ matrix and put the result to the old-style array.</p>
<p>The sample below illustrates how to use the function:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">temp</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="n">CV_8UC1</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">));</span>
<span class="n">IplImage</span><span class="o">*</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span> <span class="n">IPL_DEPTH_8U</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">insertImageCOI</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//insert to the first channel</span>
<span class="n">cvNamedWindow</span><span class="p">(</span><span class="s">&quot;window&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">cvShowImage</span><span class="p">(</span><span class="s">&quot;window&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">);</span> <span class="c1">//you should see green image, because channel number 1 is green (BGR)</span>
<span class="n">cvWaitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">cvDestroyAllWindows</span><span class="p">();</span>
<span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">img</span><span class="p">);</span>
</pre></div>
</div>
<p>To insert a channel to a new-style matrix, use
<a class="reference internal" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="void merge(const Mat* mv, size_t count, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">merge()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> , <a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> , <a class="reference internal" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="void merge(const Mat* mv, size_t count, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">merge()</span></tt></a> , <a class="reference internal" href="#Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)" title="Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cvarrToMat()</span></tt></a> , <a class="reference internal" href="old_basic_structures.html#void cvSetImageCOI(IplImage* image, int coi)" title="void cvSetImageCOI(IplImage* image, int coi)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvSetImageCOI()</span></tt></a> , <a class="reference internal" href="old_basic_structures.html#int cvGetImageCOI(const IplImage* image)" title="int cvGetImageCOI(const IplImage* image)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvGetImageCOI()</span></tt></a></p>
</div>
</div>
<div class="section" id="flip">
<h2>flip<a class="headerlink" href="#flip" title="Permalink to this headline">¶</a></h2>
<p>Flips a 2D array around vertical, horizontal, or both axes.</p>
<dl class="function">
<dt id="void flip(InputArray src, OutputArray dst, int flipCode)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">flip</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flipCode</strong><big>)</big><a class="headerlink" href="#void flip(InputArray src, OutputArray dst, int flipCode)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.flip">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">flip</tt><big>(</big>src, flipCode<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.flip" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFlip(const CvArr* src, CvArr* dst, int flip_mode)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvFlip</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>=NULL, int <strong>flip_mode</strong>=0 <big>)</big><a class="headerlink" href="#void cvFlip(const CvArr* src, CvArr* dst, int flip_mode)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Flip">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Flip</tt><big>(</big>src, dst=None, flipMode=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.Flip" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>flipCode</strong> &#8211; a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes (see the discussion below for the formulas).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">flip</span></tt> flips the array in one of three different ways (row and column indices are 0-based):</p>
<div class="math">
<p><img src="../../../_images/math/cff3f0d8fac6e2e657ced3886c9369652eec02b4.png" alt="\texttt{dst} _{ij} =
\left\{
\begin{array}{l l}
\texttt{src} _{\texttt{src.rows}-i-1,j} &amp; if\;  \texttt{flipCode} = 0 \\
\texttt{src} _{i, \texttt{src.cols} -j-1} &amp; if\;  \texttt{flipCode} &gt; 0 \\
\texttt{src} _{ \texttt{src.rows} -i-1, \texttt{src.cols} -j-1} &amp; if\; \texttt{flipCode} &lt; 0 \\
\end{array}
\right."/></p>
</div><p>The example scenarios of using the function are the following:</p>
<blockquote>
<div><ul class="simple">
<li>Vertical flipping of the image (<tt class="docutils literal"><span class="pre">flipCode</span> <span class="pre">==</span> <span class="pre">0</span></tt>) to switch between top-left and bottom-left image origin. This is a typical operation in video processing on Microsoft Windows* OS.</li>
<li>Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-axis symmetry (<tt class="docutils literal"><span class="pre">flipCode</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>).</li>
<li>Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry (<tt class="docutils literal"><span class="pre">flipCode</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt>).</li>
<li>Reversing the order of point arrays (<tt class="docutils literal"><span class="pre">flipCode</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt> or <tt class="docutils literal"><span class="pre">flipCode</span> <span class="pre">==</span> <span class="pre">0</span></tt>).</li>
</ul>
</div></blockquote>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void transpose(InputArray src, OutputArray dst)" title="void transpose(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transpose()</span></tt></a> , <a class="reference internal" href="#void repeat(InputArray src, int ny, int nx, OutputArray dst)" title="void repeat(InputArray src, int ny, int nx, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">repeat()</span></tt></a> , <a class="reference internal" href="#void completeSymm(InputOutputArray mtx, bool lowerToUpper)" title="void completeSymm(InputOutputArray mtx, bool lowerToUpper)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">completeSymm()</span></tt></a></p>
</div>
</div>
<div class="section" id="gemm">
<h2>gemm<a class="headerlink" href="#gemm" title="Permalink to this headline">¶</a></h2>
<p>Performs generalized matrix multiplication.</p>
<dl class="function">
<dt id="void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">gemm</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, double <strong>alpha</strong>, InputArray <strong>src3</strong>, double <strong>gamma</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=0 <big>)</big><a class="headerlink" href="#void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.gemm">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">gemm</tt><big>(</big>src1, src2, alpha, src3, gamma<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.gemm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvGEMM(const CvArr* src1, const CvArr* src2, double alpha, const CvArr* src3, double beta, CvArr* dst, int tABC)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvGEMM</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, double <strong>alpha</strong>, const CvArr* <strong>src3</strong>, double <strong>beta</strong>, CvArr* <strong>dst</strong>, int <strong>tABC</strong>=0<big>)</big><a class="headerlink" href="#void cvGEMM(const CvArr* src1, const CvArr* src2, double alpha, const CvArr* src3, double beta, CvArr* dst, int tABC)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GEMM">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">GEMM</tt><big>(</big>src1, src2, alpha, src3, beta, dst, tABC=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.GEMM" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first multiplied input matrix that should have <tt class="docutils literal"><span class="pre">CV_32FC1</span></tt>, <tt class="docutils literal"><span class="pre">CV_64FC1</span></tt>, <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt>, or <tt class="docutils literal"><span class="pre">CV_64FC2</span></tt> type.</li>
<li><strong>src2</strong> &#8211; second multiplied input matrix of the same type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>alpha</strong> &#8211; weight of the matrix product.</li>
<li><strong>src3</strong> &#8211; third optional delta matrix added to the matrix product; it should have the same type as <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>beta</strong> &#8211; weight of <tt class="docutils literal"><span class="pre">src3</span></tt>.</li>
<li><strong>dst</strong> &#8211; output matrix; it has the proper size and the same type as input matrices.</li>
<li><strong>flags</strong> &#8211; <p>operation flags:</p>
<ul>
<li><strong>GEMM_1_T</strong> transposes <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>GEMM_2_T</strong> transposes <tt class="docutils literal"><span class="pre">src2</span></tt>.</li>
<li><strong>GEMM_3_T</strong> transposes <tt class="docutils literal"><span class="pre">src3</span></tt>.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function performs generalized matrix multiplication similar to the <tt class="docutils literal"><span class="pre">gemm</span></tt> functions in BLAS level 3. For example, <tt class="docutils literal"><span class="pre">gemm(src1,</span> <span class="pre">src2,</span> <span class="pre">alpha,</span> <span class="pre">src3,</span> <span class="pre">beta,</span> <span class="pre">dst,</span> <span class="pre">GEMM_1_T</span> <span class="pre">+</span> <span class="pre">GEMM_3_T)</span></tt> corresponds to</p>
<div class="math">
<p><img src="../../../_images/math/2cb8dcd21f9cb572b2c6a37681e6af94bd2daa02.png" alt="\texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T"/></p>
</div><p>The function can be replaced with a matrix expression. For example, the above call can be replaced with:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">dst</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">src1</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">src2</span> <span class="o">+</span> <span class="n">beta</span><span class="o">*</span><span class="n">src3</span><span class="p">.</span><span class="n">t</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)" title="void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mulTransposed()</span></tt></a> , <a class="reference internal" href="#void transform(InputArray src, OutputArray dst, InputArray m)" title="void transform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transform()</span></tt></a> , <a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="getconvertelem">
<h2>getConvertElem<a class="headerlink" href="#getconvertelem" title="Permalink to this headline">¶</a></h2>
<p>Returns a conversion function for a single pixel.</p>
<dl class="function">
<dt id="ConvertData getConvertElem(int fromType, int toType)">
<strong>C++:</strong><tt class="descname"> </tt>ConvertData <tt class="descname">getConvertElem</tt><big>(</big>int <strong>fromType</strong>, int <strong>toType</strong><big>)</big><a class="headerlink" href="#ConvertData getConvertElem(int fromType, int toType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ConvertScaleData getConvertScaleElem(int fromType, int toType)">
<strong>C++:</strong><tt class="descname"> </tt>ConvertScaleData <tt class="descname">getConvertScaleElem</tt><big>(</big>int <strong>fromType</strong>, int <strong>toType</strong><big>)</big><a class="headerlink" href="#ConvertScaleData getConvertScaleElem(int fromType, int toType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fromType</strong> &#8211; input pixel type.</li>
<li><strong>toType</strong> &#8211; output pixel type.</li>
<li><strong>from</strong> &#8211; callback parameter: pointer to the input pixel.</li>
<li><strong>to</strong> &#8211; callback parameter: pointer to the output pixel</li>
<li><strong>cn</strong> &#8211; callback parameter: the number of channels; it can be arbitrary, 1, 100, 100000, etc.</li>
<li><strong>alpha</strong> &#8211; <tt class="docutils literal"><span class="pre">ConvertScaleData</span></tt> callback optional parameter: the scale factor.</li>
<li><strong>beta</strong> &#8211; <tt class="docutils literal"><span class="pre">ConvertScaleData</span></tt> callback optional parameter: the delta or offset.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">getConvertElem</span></tt> and <tt class="docutils literal"><span class="pre">getConvertScaleElem</span></tt> return pointers to the functions for converting individual pixels from one type to another. While the main function purpose is to convert single pixels (actually, for converting sparse matrices from one type to another), you can use them to convert the whole row of a dense matrix or the whole matrix at once, by setting <tt class="docutils literal"><span class="pre">cn</span> <span class="pre">=</span> <span class="pre">matrix.cols*matrix.rows*matrix.channels()</span></tt> if the matrix data is continuous.</p>
<p><tt class="docutils literal"><span class="pre">ConvertData</span></tt> and <tt class="docutils literal"><span class="pre">ConvertScaleData</span></tt> are defined as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ConvertData</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">from</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="p">)</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ConvertScaleData</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">from</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">to</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span> <span class="kt">double</span> <span class="n">beta</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a> , <a class="reference internal" href="basic_structures.html#void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const" title="void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">SparseMat::convertTo()</span></tt></a></p>
</div>
</div>
<div class="section" id="getoptimaldftsize">
<h2>getOptimalDFTSize<a class="headerlink" href="#getoptimaldftsize" title="Permalink to this headline">¶</a></h2>
<p>Returns the optimal DFT size for a given vector size.</p>
<dl class="function">
<dt id="int getOptimalDFTSize(int vecsize)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">getOptimalDFTSize</tt><big>(</big>int <strong>vecsize</strong><big>)</big><a class="headerlink" href="#int getOptimalDFTSize(int vecsize)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getOptimalDFTSize">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getOptimalDFTSize</tt><big>(</big>vecsize<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getOptimalDFTSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvGetOptimalDFTSize(int size0)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvGetOptimalDFTSize</tt><big>(</big>int <strong>size0</strong><big>)</big><a class="headerlink" href="#int cvGetOptimalDFTSize(int size0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetOptimalDFTSize">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">GetOptimalDFTSize</tt><big>(</big>size0<big>)</big> &rarr; int<a class="headerlink" href="#cv.GetOptimalDFTSize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vecsize</strong> &#8211; vector size.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>DFT performance is not a monotonic function of a vector size. Therefore, when you calculate convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to pad the input data with zeros to get a bit larger array that can be transformed much faster than the original one.
Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process. Though, the arrays whose size is a product of 2&#8217;s, 3&#8217;s, and 5&#8217;s (for example, 300 = 5*5*3*2*2) are also processed quite efficiently.</p>
<p>The function <tt class="docutils literal"><span class="pre">getOptimalDFTSize</span></tt> returns the minimum number <tt class="docutils literal"><span class="pre">N</span></tt> that is greater than or equal to <tt class="docutils literal"><span class="pre">vecsize</span></tt>  so that the DFT of a vector of size <tt class="docutils literal"><span class="pre">N</span></tt> can be processed efficiently. In the current implementation <tt class="docutils literal"><span class="pre">N</span></tt> = 2 <sup>p</sup> * 3 <sup>q</sup> * 5 <sup>r</sup> for some integer <tt class="docutils literal"><span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">q</span></tt>, <tt class="docutils literal"><span class="pre">r</span></tt>.</p>
<p>The function returns a negative number if <tt class="docutils literal"><span class="pre">vecsize</span></tt> is too large (very close to <tt class="docutils literal"><span class="pre">INT_MAX</span></tt> ).</p>
<p>While the function cannot be used directly to estimate the optimal vector size for DCT transform (since the current DCT implementation supports only even-size vectors), it can be easily processed as <tt class="docutils literal"><span class="pre">getOptimalDFTSize((vecsize+1)/2)*2</span></tt>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a> , <a class="reference internal" href="#void dct(InputArray src, OutputArray dst, int flags)" title="void dct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dct()</span></tt></a> , <a class="reference internal" href="#void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">idft()</span></tt></a> , <a class="reference internal" href="#void idct(InputArray src, OutputArray dst, int flags)" title="void idct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">idct()</span></tt></a> , <a class="reference internal" href="#void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)" title="void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mulSpectrums()</span></tt></a></p>
</div>
</div>
<div class="section" id="idct">
<h2>idct<a class="headerlink" href="#idct" title="Permalink to this headline">¶</a></h2>
<p>Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</p>
<dl class="function">
<dt id="void idct(InputArray src, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">idct</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=0<big>)</big><a class="headerlink" href="#void idct(InputArray src, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.idct">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">idct</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.idct" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input floating-point single-channel array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>flags</strong> &#8211; operation flags.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><tt class="docutils literal"><span class="pre">idct(src,</span> <span class="pre">dst,</span> <span class="pre">flags)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">dct(src,</span> <span class="pre">dst,</span> <span class="pre">flags</span> <span class="pre">|</span> <span class="pre">DCT_INVERSE)</span></tt>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dct(InputArray src, OutputArray dst, int flags)" title="void dct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dct()</span></tt></a>,
<a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a>,
<a class="reference internal" href="#void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">idft()</span></tt></a>,
<a class="reference internal" href="#int getOptimalDFTSize(int vecsize)" title="int getOptimalDFTSize(int vecsize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalDFTSize()</span></tt></a></p>
</div>
</div>
<div class="section" id="idft">
<h2>idft<a class="headerlink" href="#idft" title="Permalink to this headline">¶</a></h2>
<p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</p>
<dl class="function">
<dt id="void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">idft</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=0, int <strong>nonzeroRows</strong>=0<big>)</big><a class="headerlink" href="#void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.idft">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">idft</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">[</span>, nonzeroRows<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.idft" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input floating-point real or complex array.</li>
<li><strong>dst</strong> &#8211; output array whose size and type depend on the <tt class="docutils literal"><span class="pre">flags</span></tt>.</li>
<li><strong>flags</strong> &#8211; operation flags (see <a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a>).</li>
<li><strong>nonzeroRows</strong> &#8211; number of <tt class="docutils literal"><span class="pre">dst</span></tt> rows to process; the rest of the rows have undefined content (see the convolution sample in  <a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a> description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><tt class="docutils literal"><span class="pre">idft(src,</span> <span class="pre">dst,</span> <span class="pre">flags)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">dft(src,</span> <span class="pre">dst,</span> <span class="pre">flags</span> <span class="pre">|</span> <span class="pre">DFT_INVERSE)</span></tt> .</p>
<p>See <a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a> for details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">None of <tt class="docutils literal"><span class="pre">dft</span></tt> and <tt class="docutils literal"><span class="pre">idft</span></tt> scales the result by default. So, you should pass <tt class="docutils literal"><span class="pre">DFT_SCALE</span></tt> to one of <tt class="docutils literal"><span class="pre">dft</span></tt> or <tt class="docutils literal"><span class="pre">idft</span></tt> explicitly to make these transforms mutually inverse.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a>,
<a class="reference internal" href="#void dct(InputArray src, OutputArray dst, int flags)" title="void dct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dct()</span></tt></a>,
<a class="reference internal" href="#void idct(InputArray src, OutputArray dst, int flags)" title="void idct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">idct()</span></tt></a>,
<a class="reference internal" href="#void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)" title="void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mulSpectrums()</span></tt></a>,
<a class="reference internal" href="#int getOptimalDFTSize(int vecsize)" title="int getOptimalDFTSize(int vecsize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getOptimalDFTSize()</span></tt></a></p>
</div>
</div>
<div class="section" id="inrange">
<h2>inRange<a class="headerlink" href="#inrange" title="Permalink to this headline">¶</a></h2>
<p>Checks if array elements lie between the elements of two other arrays.</p>
<dl class="function">
<dt id="void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">inRange</tt><big>(</big>InputArray <strong>src</strong>, InputArray <strong>lowerb</strong>, InputArray <strong>upperb</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.inRange">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">inRange</tt><big>(</big>src, lowerb, upperb<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.inRange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvInRange(const CvArr* src, const CvArr* lower, const CvArr* upper, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvInRange</tt><big>(</big>const CvArr* <strong>src</strong>, const CvArr* <strong>lower</strong>, const CvArr* <strong>upper</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvInRange(const CvArr* src, const CvArr* lower, const CvArr* upper, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvInRangeS(const CvArr* src, CvScalar lower, CvScalar upper, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvInRangeS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>lower</strong>, CvScalar <strong>upper</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvInRangeS(const CvArr* src, CvScalar lower, CvScalar upper, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.InRange">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">InRange</tt><big>(</big>src, lower, upper, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.InRange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.InRangeS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">InRangeS</tt><big>(</big>src, lower, upper, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.InRangeS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; first input array.</li>
<li><strong>lowerb</strong> &#8211; inclusive lower boundary array or a scalar.</li>
<li><strong>upperb</strong> &#8211; inclusive upper boundary array or a scalar.</li>
<li><strong>dst</strong> &#8211; output array of the same size as <tt class="docutils literal"><span class="pre">src</span></tt> and <tt class="docutils literal"><span class="pre">CV_8U</span></tt> type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function checks the range as follows:</p>
<blockquote>
<div><ul>
<li><p class="first">For every element of a single-channel input array:</p>
<div class="math">
<p><img src="../../../_images/math/1abc02980e04c8804f0608cad7218723643a357e.png" alt="\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0"/></p>
</div></li>
<li><p class="first">For two-channel arrays:</p>
<div class="math">
<p><img src="../../../_images/math/0f9cf3a044815706e004b478c32aafd091a3d340.png" alt="\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1"/></p>
</div></li>
<li><p class="first">and so forth.</p>
</li>
</ul>
</div></blockquote>
<p>That is, <tt class="docutils literal"><span class="pre">dst</span></tt> (I) is set to 255 (all <tt class="docutils literal"><span class="pre">1</span></tt> -bits) if <tt class="docutils literal"><span class="pre">src</span></tt> (I) is within the specified 1D, 2D, 3D, ... box and 0 otherwise.</p>
<p>When the lower and/or upper boundary parameters are scalars, the indexes <tt class="docutils literal"><span class="pre">(I)</span></tt> at <tt class="docutils literal"><span class="pre">lowerb</span></tt> and <tt class="docutils literal"><span class="pre">upperb</span></tt> in the above formulas should be omitted.</p>
</div>
<div class="section" id="invert">
<h2>invert<a class="headerlink" href="#invert" title="Permalink to this headline">¶</a></h2>
<p>Finds the inverse or pseudo-inverse of a matrix.</p>
<dl class="function">
<dt id="double invert(InputArray src, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">invert</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=DECOMP_LU<big>)</big><a class="headerlink" href="#double invert(InputArray src, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.invert">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">invert</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval, dst<a class="headerlink" href="#cv2.invert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvInvert(const CvArr* src, CvArr* dst, int method)">
<strong>C:</strong><tt class="descname"> </tt>double <tt class="descname">cvInvert</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>method</strong>=CV_LU <big>)</big><a class="headerlink" href="#double cvInvert(const CvArr* src, CvArr* dst, int method)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Invert">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Invert</tt><big>(</big>src, dst, method=CV_LU<big>)</big> &rarr; float<a class="headerlink" href="#cv.Invert" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input floating-point <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> matrix.</li>
<li><strong>dst</strong> &#8211; output matrix of <tt class="docutils literal"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">M</span></tt> size and the same type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>flags</strong> &#8211; <p>inversion method :</p>
<ul>
<li><strong>DECOMP_LU</strong> Gaussian elimination with the optimal pivot element chosen.</li>
<li><strong>DECOMP_SVD</strong> singular value decomposition (SVD) method.</li>
<li><strong>DECOMP_CHOLESKY</strong> Cholesky decomposition; the matrix must be symmetrical and positively defined.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">invert</span></tt> inverts the matrix <tt class="docutils literal"><span class="pre">src</span></tt> and stores the result in <tt class="docutils literal"><span class="pre">dst</span></tt> .
When the matrix <tt class="docutils literal"><span class="pre">src</span></tt> is singular or non-square, the function calculates the pseudo-inverse matrix (the <tt class="docutils literal"><span class="pre">dst</span></tt> matrix) so that <tt class="docutils literal"><span class="pre">norm(src*dst</span> <span class="pre">-</span> <span class="pre">I)</span></tt> is minimal, where I is an identity matrix.</p>
<p>In case of the <tt class="docutils literal"><span class="pre">DECOMP_LU</span></tt> method, the function returns non-zero value if the inverse has been successfully calculated and 0 if <tt class="docutils literal"><span class="pre">src</span></tt> is singular.</p>
<p>In case of the <tt class="docutils literal"><span class="pre">DECOMP_SVD</span></tt> method, the function returns the inverse condition number of <tt class="docutils literal"><span class="pre">src</span></tt> (the ratio of the smallest singular value to the largest singular value) and 0 if <tt class="docutils literal"><span class="pre">src</span></tt> is singular. The SVD method calculates a pseudo-inverse matrix if <tt class="docutils literal"><span class="pre">src</span></tt> is singular.</p>
<p>Similarly to <tt class="docutils literal"><span class="pre">DECOMP_LU</span></tt> , the method <tt class="docutils literal"><span class="pre">DECOMP_CHOLESKY</span></tt> works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in <tt class="docutils literal"><span class="pre">dst</span></tt> and returns non-zero. Otherwise, it returns 0.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)" title="bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">solve()</span></tt></a>,
<a class="reference internal" href="#SVD" title="class SVD"><tt class="xref ocv ocv-class docutils literal"><span class="pre">SVD</span></tt></a></p>
</div>
</div>
<div class="section" id="log">
<h2>log<a class="headerlink" href="#log" title="Permalink to this headline">¶</a></h2>
<p>Calculates the natural logarithm of every array element.</p>
<dl class="function">
<dt id="void log(InputArray src, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">log</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void log(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.log">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">log</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvLog(const CvArr* src, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvLog</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvLog(const CvArr* src, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Log">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Log</tt><big>(</big>src, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Log" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">log</span></tt> calculates the natural logarithm of the absolute value of every element of the input array:</p>
<div class="math">
<p><img src="../../../_images/math/31f796ea73b7d09c39b9fe95a3fabf5c32777e52.png" alt="\texttt{dst} (I) =  \fork{\log |\texttt{src}(I)|}{if $\texttt{src}(I) \ne 0$ }{\texttt{C}}{otherwise}"/></p>
</div><p>where <tt class="docutils literal"><span class="pre">C</span></tt> is a large negative number (about -700 in the current implementation).
The maximum relative error is about <tt class="docutils literal"><span class="pre">7e-6</span></tt> for single-precision input and less than <tt class="docutils literal"><span class="pre">1e-10</span></tt> for double-precision input. Special values (NaN, Inf) are not handled.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void exp(InputArray src, OutputArray dst)" title="void exp(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">exp()</span></tt></a>,
<a class="reference internal" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a>,
<a class="reference internal" href="#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)" title="void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">polarToCart()</span></tt></a>,
<a class="reference internal" href="#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)" title="void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">phase()</span></tt></a>,
<a class="reference internal" href="#void pow(InputArray src, double power, OutputArray dst)" title="void pow(InputArray src, double power, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pow()</span></tt></a>,
<a class="reference internal" href="#void sqrt(InputArray src, OutputArray dst)" title="void sqrt(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sqrt()</span></tt></a>,
<a class="reference internal" href="#void magnitude(InputArray x, InputArray y, OutputArray magnitude)" title="void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">magnitude()</span></tt></a></p>
</div>
</div>
<div class="section" id="lut">
<h2>LUT<a class="headerlink" href="#lut" title="Permalink to this headline">¶</a></h2>
<p>Performs a look-up table transform of an array.</p>
<dl class="function">
<dt id="void LUT(InputArray src, InputArray lut, OutputArray dst, int interpolation)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">LUT</tt><big>(</big>InputArray <strong>src</strong>, InputArray <strong>lut</strong>, OutputArray <strong>dst</strong>, int <strong>interpolation</strong>=0 <big>)</big><a class="headerlink" href="#void LUT(InputArray src, InputArray lut, OutputArray dst, int interpolation)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.LUT">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">LUT</tt><big>(</big>src, lut<span class="optional">[</span>, dst<span class="optional">[</span>, interpolation<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.LUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvLUT(const CvArr* src, CvArr* dst, const CvArr* lut)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvLUT</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>lut</strong><big>)</big><a class="headerlink" href="#void cvLUT(const CvArr* src, CvArr* dst, const CvArr* lut)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.LUT">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">LUT</tt><big>(</big>src, dst, lut<big>)</big> &rarr; None<a class="headerlink" href="#cv.LUT" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array of 8-bit elements.</li>
<li><strong>lut</strong> &#8211; look-up table of 256 elements; in case of multi-channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and number of channels as <tt class="docutils literal"><span class="pre">src</span></tt>, and the same depth as <tt class="docutils literal"><span class="pre">lut</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">LUT</span></tt> fills the output array with values from the look-up table. Indices of the entries are taken from the input array. That is, the function processes each element of <tt class="docutils literal"><span class="pre">src</span></tt> as follows:</p>
<div class="math">
<p><img src="../../../_images/math/b0a9b4f484bada5dce4f735afec9daf83ab558d5.png" alt="\texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/5833ed8ab578ab59dd4e54715129ecba3cb59f4e.png" alt="d =  \fork{0}{if \texttt{src} has depth \texttt{CV\_8U}}{128}{if \texttt{src} has depth \texttt{CV\_8S}}"/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)" title="void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">convertScaleAbs()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a></p>
</div>
</div>
<div class="section" id="magnitude">
<h2>magnitude<a class="headerlink" href="#magnitude" title="Permalink to this headline">¶</a></h2>
<p>Calculates the magnitude of 2D vectors.</p>
<dl class="function">
<dt id="void magnitude(InputArray x, InputArray y, OutputArray magnitude)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">magnitude</tt><big>(</big>InputArray <strong>x</strong>, InputArray <strong>y</strong>, OutputArray <strong>magnitude</strong><big>)</big><a class="headerlink" href="#void magnitude(InputArray x, InputArray y, OutputArray magnitude)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.magnitude">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">magnitude</tt><big>(</big>x, y<span class="optional">[</span>, magnitude<span class="optional">]</span><big>)</big> &rarr; magnitude<a class="headerlink" href="#cv2.magnitude" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; floating-point array of x-coordinates of the vectors.</li>
<li><strong>y</strong> &#8211; floating-point array of y-coordinates of the vectors; it must have the same size as <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
<li><strong>magnitude</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">magnitude</span></tt> calculates the magnitude of 2D vectors formed from the corresponding elements of <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> arrays:</p>
<div class="math">
<p><img src="../../../_images/math/533df9e3d68d1b895afab3bc648603e2c2a9a52c.png" alt="\texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}"/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a>,
<a class="reference internal" href="#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)" title="void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">polarToCart()</span></tt></a>,
<a class="reference internal" href="#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)" title="void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">phase()</span></tt></a>,
<a class="reference internal" href="#void sqrt(InputArray src, OutputArray dst)" title="void sqrt(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sqrt()</span></tt></a></p>
</div>
</div>
<div class="section" id="mahalanobis">
<h2>Mahalanobis<a class="headerlink" href="#mahalanobis" title="Permalink to this headline">¶</a></h2>
<p>Calculates the Mahalanobis distance between two vectors.</p>
<dl class="function">
<dt id="double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">Mahalanobis</tt><big>(</big>InputArray <strong>v1</strong>, InputArray <strong>v2</strong>, InputArray <strong>icovar</strong><big>)</big><a class="headerlink" href="#double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Mahalanobis">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">Mahalanobis</tt><big>(</big>v1, v2, icovar<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.Mahalanobis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvMahalanobis(const CvArr* vec1, const CvArr* vec2, const CvArr* mat)">
<strong>C:</strong><tt class="descname"> </tt>double <tt class="descname">cvMahalanobis</tt><big>(</big>const CvArr* <strong>vec1</strong>, const CvArr* <strong>vec2</strong>, const CvArr* <strong>mat</strong><big>)</big><a class="headerlink" href="#double cvMahalanobis(const CvArr* vec1, const CvArr* vec2, const CvArr* mat)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Mahalonobis">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Mahalonobis</tt><big>(</big>vec1, vec2, mat<big>)</big> &rarr; None<a class="headerlink" href="#cv.Mahalonobis" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vec1</strong> &#8211; first 1D input vector.</li>
<li><strong>vec2</strong> &#8211; second 1D input vector.</li>
<li><strong>icovar</strong> &#8211; inverse covariance matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">Mahalanobis</span></tt> calculates and returns the weighted distance between two vectors:</p>
<div class="math">
<p><img src="../../../_images/math/1d6e73d8fa77ecf2a2d9997e0117e26d2bf1e9f9.png" alt="d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }"/></p>
</div><p>The covariance matrix may be calculated using the
<a class="reference internal" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)" title="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcCovarMatrix()</span></tt></a> function and then inverted using the
<a class="reference internal" href="#double invert(InputArray src, OutputArray dst, int flags)" title="double invert(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">invert()</span></tt></a> function (preferably using the <tt class="docutils literal"><span class="pre">DECOMP_SVD</span></tt> method, as the most accurate).</p>
</div>
<div class="section" id="max">
<h2>max<a class="headerlink" href="#max" title="Permalink to this headline">¶</a></h2>
<p>Calculates per-element maximum of two arrays or an array and a scalar.</p>
<dl class="function">
<dt id="MatExpr max(const Mat&amp; a, const Mat&amp; b)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">max</tt><big>(</big>const Mat&amp; <strong>a</strong>, const Mat&amp; <strong>b</strong><big>)</big><a class="headerlink" href="#MatExpr max(const Mat& a, const Mat& b)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MatExpr max(const Mat&amp; a, double s)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">max</tt><big>(</big>const Mat&amp; <strong>a</strong>, double <strong>s</strong><big>)</big><a class="headerlink" href="#MatExpr max(const Mat& a, double s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MatExpr max(double s, const Mat&amp; a)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">max</tt><big>(</big>double <strong>s</strong>, const Mat&amp; <strong>a</strong><big>)</big><a class="headerlink" href="#MatExpr max(double s, const Mat& a)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void max(InputArray src1, InputArray src2, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">max</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void max(InputArray src1, InputArray src2, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void max(const Mat&amp; src1, const Mat&amp; src2, Mat&amp; dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">max</tt><big>(</big>const Mat&amp; <strong>src1</strong>, const Mat&amp; <strong>src2</strong>, Mat&amp; <strong>dst</strong><big>)</big><a class="headerlink" href="#void max(const Mat& src1, const Mat& src2, Mat& dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void max(const Mat&amp; src1, double src2, Mat&amp; dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">max</tt><big>(</big>const Mat&amp; <strong>src1</strong>, double <strong>src2</strong>, Mat&amp; <strong>dst</strong><big>)</big><a class="headerlink" href="#void max(const Mat& src1, double src2, Mat& dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.max">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">max</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMax(const CvArr* src1, const CvArr* src2, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMax</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvMax(const CvArr* src1, const CvArr* src2, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMaxS(const CvArr* src, double value, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMaxS</tt><big>(</big>const CvArr* <strong>src</strong>, double <strong>value</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvMaxS(const CvArr* src, double value, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Max">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Max</tt><big>(</big>src1, src2, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MaxS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MaxS</tt><big>(</big>src, value, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.MaxS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and type as  <tt class="docutils literal"><span class="pre">src1</span></tt> .</li>
<li><strong>value</strong> &#8211; real scalar value.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">max</span></tt> calculate the per-element maximum of two arrays:</p>
<div class="math">
<p><img src="../../../_images/math/51e5f69379786a2210a7a20683d1d3d1110118a1.png" alt="\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))"/></p>
</div><p>or array and a scalar:</p>
<div class="math">
<p><img src="../../../_images/math/967d24bc4b9269d13919b06f116e04bfe20bdac2.png" alt="\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )"/></p>
</div><p>In the second variant, when the input array is multi-channel, each channel is compared with <tt class="docutils literal"><span class="pre">value</span></tt> independently.</p>
<p>The first 3 variants of the function listed above are actually a part of
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a> . They return an expression object that can be further either transformed/ assigned to a matrix, or passed to a function, and so on.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#MatExpr min(const Mat&amp; a, const Mat&amp; b)" title="MatExpr min(const Mat&amp; a, const Mat&amp; b)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">min()</span></tt></a>,
<a class="reference internal" href="../../contrib/doc/openfabmap.html#void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)" title="void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">compare()</span></tt></a>,
<a class="reference internal" href="#void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)" title="void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">inRange()</span></tt></a>,
<a class="reference internal" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minMaxLoc()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="mean">
<h2>mean<a class="headerlink" href="#mean" title="Permalink to this headline">¶</a></h2>
<p>Calculates an average (mean) of array elements.</p>
<dl class="function">
<dt id="Scalar mean(InputArray src, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>Scalar <tt class="descname">mean</tt><big>(</big>InputArray <strong>src</strong>, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#Scalar mean(InputArray src, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.mean">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">mean</tt><big>(</big>src<span class="optional">[</span>, mask<span class="optional">]</span><big>)</big> &rarr; retval<a class="headerlink" href="#cv2.mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvScalar cvAvg(const CvArr* arr, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>CvScalar <tt class="descname">cvAvg</tt><big>(</big>const CvArr* <strong>arr</strong>, const CvArr* <strong>mask</strong>=NULL <big>)</big><a class="headerlink" href="#CvScalar cvAvg(const CvArr* arr, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Avg">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Avg</tt><big>(</big>arr, mask=None<big>)</big> &rarr; scalar<a class="headerlink" href="#cv.Avg" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array that should have from 1 to 4 channels so that the result can be stored in <a class="reference internal" href="basic_structures.html#Scalar_" title="class Scalar_"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Scalar_</span></tt></a> .</li>
<li><strong>mask</strong> &#8211; optional operation mask.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">mean</span></tt> calculates the mean value <tt class="docutils literal"><span class="pre">M</span></tt> of array elements, independently for each channel, and return it:</p>
<div class="math">
<p><img src="../../../_images/math/ea3b8e251b52d791f7b56ea8ef6e815048274c81.png" alt="\begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}"/></p>
</div><p>When all the mask elements are 0&#8217;s, the functions return <tt class="docutils literal"><span class="pre">Scalar::all(0)</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#int countNonZero(InputArray src)" title="int countNonZero(InputArray src)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">countNonZero()</span></tt></a>,
<a class="reference internal" href="#void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)" title="void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">meanStdDev()</span></tt></a>,
<a class="reference internal" href="#double norm(InputArray src1, int normType, InputArray mask)" title="double norm(InputArray src1, int normType, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">norm()</span></tt></a>,
<a class="reference internal" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minMaxLoc()</span></tt></a></p>
</div>
</div>
<div class="section" id="meanstddev">
<h2>meanStdDev<a class="headerlink" href="#meanstddev" title="Permalink to this headline">¶</a></h2>
<p>Calculates a mean and standard deviation of array elements.</p>
<dl class="function">
<dt id="void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">meanStdDev</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>mean</strong>, OutputArray <strong>stddev</strong>, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.meanStdDev">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">meanStdDev</tt><big>(</big>src<span class="optional">[</span>, mean<span class="optional">[</span>, stddev<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; mean, stddev<a class="headerlink" href="#cv2.meanStdDev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAvgSdv(const CvArr* arr, CvScalar* mean, CvScalar* std_dev, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvAvgSdv</tt><big>(</big>const CvArr* <strong>arr</strong>, CvScalar* <strong>mean</strong>, CvScalar* <strong>std_dev</strong>, const CvArr* <strong>mask</strong>=NULL <big>)</big><a class="headerlink" href="#void cvAvgSdv(const CvArr* arr, CvScalar* mean, CvScalar* std_dev, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AvgSdv">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">AvgSdv</tt><big>(</big>arr, mask=None) -&gt; (mean, stdDev<big>)</big><a class="headerlink" href="#cv.AvgSdv" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array that should have from 1 to 4 channels so that the results can be stored in  <a class="reference internal" href="basic_structures.html#Scalar_" title="class Scalar_"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Scalar_</span></tt></a> &#8216;s.</li>
<li><strong>mean</strong> &#8211; output parameter: calculated mean value.</li>
<li><strong>stddev</strong> &#8211; output parameter: calculateded standard deviation.</li>
<li><strong>mask</strong> &#8211; optional operation mask.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">meanStdDev</span></tt> calculates the mean and the standard deviation <tt class="docutils literal"><span class="pre">M</span></tt> of array elements independently for each channel and returns it via the output parameters:</p>
<div class="math">
<p><img src="../../../_images/math/c94c3dc82b1c139f10329f948f97ec50cd98a9f5.png" alt="\begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \\ \texttt{mean} _c =  \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}"/></p>
</div><p>When all the mask elements are 0&#8217;s, the functions return <tt class="docutils literal"><span class="pre">mean=stddev=Scalar::all(0)</span></tt> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-channel array <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> to the single-channel array <tt class="docutils literal"><span class="pre">M*N</span> <span class="pre">x</span> <span class="pre">mtx.channels()</span></tt> (only possible when the matrix is continuous) and then pass the matrix to <a class="reference internal" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)" title="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcCovarMatrix()</span></tt></a> .</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#int countNonZero(InputArray src)" title="int countNonZero(InputArray src)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">countNonZero()</span></tt></a>,
<a class="reference internal" href="#Scalar mean(InputArray src, InputArray mask)" title="Scalar mean(InputArray src, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mean()</span></tt></a>,
<a class="reference internal" href="#double norm(InputArray src1, int normType, InputArray mask)" title="double norm(InputArray src1, int normType, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">norm()</span></tt></a>,
<a class="reference internal" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minMaxLoc()</span></tt></a>,
<a class="reference internal" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)" title="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcCovarMatrix()</span></tt></a></p>
</div>
</div>
<div class="section" id="merge">
<h2>merge<a class="headerlink" href="#merge" title="Permalink to this headline">¶</a></h2>
<p>Creates one multichannel array out of several single-channel ones.</p>
<dl class="function">
<dt id="void merge(const Mat* mv, size_t count, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">merge</tt><big>(</big>const Mat* <strong>mv</strong>, size_t <strong>count</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void merge(InputArrayOfArrays mv, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">merge</tt><big>(</big>InputArrayOfArrays <strong>mv</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void merge(InputArrayOfArrays mv, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.merge">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">merge</tt><big>(</big>mv<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.merge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMerge(const CvArr* src0, const CvArr* src1, const CvArr* src2, const CvArr* src3, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMerge</tt><big>(</big>const CvArr* <strong>src0</strong>, const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, const CvArr* <strong>src3</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvMerge(const CvArr* src0, const CvArr* src1, const CvArr* src2, const CvArr* src3, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Merge">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Merge</tt><big>(</big>src0, src1, src2, src3, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Merge" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mv</strong> &#8211; input array or vector of matrices to be merged; all the matrices in <tt class="docutils literal"><span class="pre">mv</span></tt> must have the same size and the same depth.</li>
<li><strong>count</strong> &#8211; number of input matrices when <tt class="docutils literal"><span class="pre">mv</span></tt> is a plain C array; it must be greater than zero.</li>
<li><strong>dst</strong> &#8211; output array of the same size and the same depth as <tt class="docutils literal"><span class="pre">mv[0]</span></tt>; The number of channels will be the total number of channels in the matrix array.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">merge</span></tt> merge several arrays to make a single multi-channel array. That is, each element of the output array will be a concatenation of the elements of the input arrays, where elements of i-th input array are treated as <tt class="docutils literal"><span class="pre">mv[i].channels()</span></tt>-element vectors.</p>
<p>The function
<a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> does the reverse operation. If you need to shuffle channels in some other advanced way, use
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a>,
<a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#Mat Mat::reshape(int cn, int rows) const" title="Mat Mat::reshape(int cn, int rows) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::reshape()</span></tt></a></p>
</div>
</div>
<div class="section" id="min">
<h2>min<a class="headerlink" href="#min" title="Permalink to this headline">¶</a></h2>
<p>Calculates per-element minimum of two arrays or an array and a scalar.</p>
<dl class="function">
<dt id="MatExpr min(const Mat&amp; a, const Mat&amp; b)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">min</tt><big>(</big>const Mat&amp; <strong>a</strong>, const Mat&amp; <strong>b</strong><big>)</big><a class="headerlink" href="#MatExpr min(const Mat& a, const Mat& b)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MatExpr min(const Mat&amp; a, double s)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">min</tt><big>(</big>const Mat&amp; <strong>a</strong>, double <strong>s</strong><big>)</big><a class="headerlink" href="#MatExpr min(const Mat& a, double s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MatExpr min(double s, const Mat&amp; a)">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descname">min</tt><big>(</big>double <strong>s</strong>, const Mat&amp; <strong>a</strong><big>)</big><a class="headerlink" href="#MatExpr min(double s, const Mat& a)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void min(InputArray src1, InputArray src2, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">min</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void min(InputArray src1, InputArray src2, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void min(const Mat&amp; src1, const Mat&amp; src2, Mat&amp; dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">min</tt><big>(</big>const Mat&amp; <strong>src1</strong>, const Mat&amp; <strong>src2</strong>, Mat&amp; <strong>dst</strong><big>)</big><a class="headerlink" href="#void min(const Mat& src1, const Mat& src2, Mat& dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void min(const Mat&amp; src1, double src2, Mat&amp; dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">min</tt><big>(</big>const Mat&amp; <strong>src1</strong>, double <strong>src2</strong>, Mat&amp; <strong>dst</strong><big>)</big><a class="headerlink" href="#void min(const Mat& src1, double src2, Mat& dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.min">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">min</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMin(const CvArr* src1, const CvArr* src2, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMin</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvMin(const CvArr* src1, const CvArr* src2, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMinS(const CvArr* src, double value, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMinS</tt><big>(</big>const CvArr* <strong>src</strong>, double <strong>value</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvMinS(const CvArr* src, double value, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Min">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Min</tt><big>(</big>src1, src2, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MinS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MinS</tt><big>(</big>src, value, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.MinS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>value</strong> &#8211; real scalar value.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">min</span></tt> calculate the per-element minimum of two arrays:</p>
<div class="math">
<p><img src="../../../_images/math/5880cd77235f41f5d02e91e464d3d76f3d4d50bf.png" alt="\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))"/></p>
</div><p>or array and a scalar:</p>
<div class="math">
<p><img src="../../../_images/math/72b5c7181ec202cb5964f5e34c379674c778ab8f.png" alt="\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )"/></p>
</div><p>In the second variant, when the input array is multi-channel, each channel is compared with <tt class="docutils literal"><span class="pre">value</span></tt> independently.</p>
<p>The first three variants of the function listed above are actually a part of
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a> . They return the expression object that can be further either transformed/assigned to a matrix, or passed to a function, and so on.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#MatExpr max(const Mat&amp; a, const Mat&amp; b)" title="MatExpr max(const Mat&amp; a, const Mat&amp; b)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">max()</span></tt></a>,
<a class="reference internal" href="../../contrib/doc/openfabmap.html#void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)" title="void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">compare()</span></tt></a>,
<a class="reference internal" href="#void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)" title="void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">inRange()</span></tt></a>,
<a class="reference internal" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minMaxLoc()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="minmaxidx">
<h2>minMaxIdx<a class="headerlink" href="#minmaxidx" title="Permalink to this headline">¶</a></h2>
<p>Finds the global minimum and maximum in an array</p>
<dl class="function">
<dt id="void minMaxIdx(InputArray src, double* minVal, double* maxVal, int* minIdx, int* maxIdx, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">minMaxIdx</tt><big>(</big>InputArray <strong>src</strong>, double* <strong>minVal</strong>, double* <strong>maxVal</strong>, int* <strong>minIdx</strong>=0, int* <strong>maxIdx</strong>=0, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void minMaxIdx(InputArray src, double* minVal, double* maxVal, int* minIdx, int* maxIdx, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input single-channel array.</li>
<li><strong>minVal</strong> &#8211; pointer to the returned minimum value; <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
<li><strong>maxVal</strong> &#8211; pointer to the returned maximum value; <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
<li><strong>minIdx</strong> &#8211; <p>pointer to the returned minimum location (in nD case); <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required; Otherwise, it must point to an array of <tt class="docutils literal"><span class="pre">src.dims</span></tt> elements, the coordinates of the minimum element in each dimension are stored there sequentially.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When <tt class="docutils literal"><span class="pre">minIdx</span></tt> is not NULL, it must have at least 2 elements (as well as <tt class="docutils literal"><span class="pre">maxIdx</span></tt>), even if <tt class="docutils literal"><span class="pre">src</span></tt> is a single-row or single-column matrix. In OpenCV (following MATLAB) each array has at least 2 dimensions, i.e. single-column matrix is <tt class="docutils literal"><span class="pre">Mx1</span></tt> matrix (and therefore <tt class="docutils literal"><span class="pre">minIdx</span></tt>/<tt class="docutils literal"><span class="pre">maxIdx</span></tt> will be <tt class="docutils literal"><span class="pre">(i1,0)</span></tt>/<tt class="docutils literal"><span class="pre">(i2,0)</span></tt>) and single-row matrix is <tt class="docutils literal"><span class="pre">1xN</span></tt> matrix (and therefore <tt class="docutils literal"><span class="pre">minIdx</span></tt>/<tt class="docutils literal"><span class="pre">maxIdx</span></tt> will be <tt class="docutils literal"><span class="pre">(0,j1)</span></tt>/<tt class="docutils literal"><span class="pre">(0,j2)</span></tt>).</p>
</div>
</li>
<li><strong>maxIdx</strong> &#8211; pointer to the returned maximum location (in nD case). <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The function <tt class="docutils literal"><span class="pre">minMaxIdx</span></tt> finds the minimum and maximum element values and their positions. The extremums are searched across the whole array or, if <tt class="docutils literal"><span class="pre">mask</span></tt> is not an empty array, in the specified array region.</p>
<p>The function does not work with multi-channel arrays. If you need to find minimum or maximum elements across all the channels, use
<a class="reference internal" href="basic_structures.html#Mat Mat::reshape(int cn, int rows) const" title="Mat Mat::reshape(int cn, int rows) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::reshape()</span></tt></a> first to reinterpret the array as single-channel. Or you may extract the particular channel using either
<a class="reference internal" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">extractImageCOI()</span></tt></a> , or
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> , or
<a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> .</p>
<p>In case of a sparse matrix, the minimum is found among non-zero elements only.</p>
</dd></dl>

</div>
<div class="section" id="minmaxloc">
<h2>minMaxLoc<a class="headerlink" href="#minmaxloc" title="Permalink to this headline">¶</a></h2>
<p>Finds the global minimum and maximum in an array.</p>
<dl class="function">
<dt id="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">minMaxLoc</tt><big>(</big>InputArray <strong>src</strong>, double* <strong>minVal</strong>, double* <strong>maxVal</strong>=0, Point* <strong>minLoc</strong>=0, Point* <strong>maxLoc</strong>=0, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void minMaxLoc(const SparseMat&amp; a, double* minVal, double* maxVal, int* minIdx, int* maxIdx)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">minMaxLoc</tt><big>(</big>const SparseMat&amp; <strong>a</strong>, double* <strong>minVal</strong>, double* <strong>maxVal</strong>, int* <strong>minIdx</strong>=0, int* <strong>maxIdx</strong>=0 <big>)</big><a class="headerlink" href="#void minMaxLoc(const SparseMat& a, double* minVal, double* maxVal, int* minIdx, int* maxIdx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.minMaxLoc">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">minMaxLoc</tt><big>(</big>src<span class="optional">[</span>, mask<span class="optional">]</span><big>)</big> &rarr; minVal, maxVal, minLoc, maxLoc<a class="headerlink" href="#cv2.minMaxLoc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMinMaxLoc(const CvArr* arr, double* min_val, double* max_val, CvPoint* min_loc, CvPoint* max_loc, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMinMaxLoc</tt><big>(</big>const CvArr* <strong>arr</strong>, double* <strong>min_val</strong>, double* <strong>max_val</strong>, CvPoint* <strong>min_loc</strong>=NULL, CvPoint* <strong>max_loc</strong>=NULL, const CvArr* <strong>mask</strong>=NULL <big>)</big><a class="headerlink" href="#void cvMinMaxLoc(const CvArr* arr, double* min_val, double* max_val, CvPoint* min_loc, CvPoint* max_loc, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MinMaxLoc">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MinMaxLoc</tt><big>(</big>arr, mask=None)-&gt; (minVal, maxVal, minLoc, maxLoc<big>)</big><a class="headerlink" href="#cv.MinMaxLoc" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input single-channel array.</li>
<li><strong>minVal</strong> &#8211; pointer to the returned minimum value;  <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
<li><strong>maxVal</strong> &#8211; pointer to the returned maximum value;  <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
<li><strong>minLoc</strong> &#8211; pointer to the returned minimum location (in 2D case);  <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
<li><strong>maxLoc</strong> &#8211; pointer to the returned maximum location (in 2D case);  <tt class="docutils literal"><span class="pre">NULL</span></tt> is used if not required.</li>
<li><strong>mask</strong> &#8211; optional mask used to select a sub-array.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">minMaxLoc</span></tt> find the minimum and maximum element values and their positions. The extremums are searched across the whole array or,
if <tt class="docutils literal"><span class="pre">mask</span></tt> is not an empty array, in the specified array region.</p>
<p>The functions do not work with multi-channel arrays. If you need to find minimum or maximum elements across all the channels, use
<a class="reference internal" href="basic_structures.html#Mat Mat::reshape(int cn, int rows) const" title="Mat Mat::reshape(int cn, int rows) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::reshape()</span></tt></a> first to reinterpret the array as single-channel. Or you may extract the particular channel using either
<a class="reference internal" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">extractImageCOI()</span></tt></a> , or
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> , or
<a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#MatExpr max(const Mat&amp; a, const Mat&amp; b)" title="MatExpr max(const Mat&amp; a, const Mat&amp; b)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">max()</span></tt></a>,
<a class="reference internal" href="#MatExpr min(const Mat&amp; a, const Mat&amp; b)" title="MatExpr min(const Mat&amp; a, const Mat&amp; b)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">min()</span></tt></a>,
<a class="reference internal" href="../../contrib/doc/openfabmap.html#void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)" title="void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">compare()</span></tt></a>,
<a class="reference internal" href="#void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)" title="void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">inRange()</span></tt></a>,
<a class="reference internal" href="#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)" title="void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">extractImageCOI()</span></tt></a>,
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a>,
<a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#Mat Mat::reshape(int cn, int rows) const" title="Mat Mat::reshape(int cn, int rows) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::reshape()</span></tt></a></p>
</div>
</div>
<div class="section" id="mixchannels">
<h2>mixChannels<a class="headerlink" href="#mixchannels" title="Permalink to this headline">¶</a></h2>
<p>Copies specified channels from input arrays to the specified channels of output arrays.</p>
<dl class="function">
<dt id="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">mixChannels</tt><big>(</big>const Mat* <strong>src</strong>, size_t <strong>nsrcs</strong>, Mat* <strong>dst</strong>, size_t <strong>ndsts</strong>, const int* <strong>fromTo</strong>, size_t <strong>npairs</strong><big>)</big><a class="headerlink" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void mixChannels(const vector&lt;Mat&gt;&amp; src, vector&lt;Mat&gt;&amp; dst, const int* fromTo, size_t npairs)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">mixChannels</tt><big>(</big>const vector&lt;Mat&gt;&amp; <strong>src</strong>, vector&lt;Mat&gt;&amp; <strong>dst</strong>, const int* <strong>fromTo</strong>, size_t <strong>npairs</strong><big>)</big><a class="headerlink" href="#void mixChannels(const vector<Mat>& src, vector<Mat>& dst, const int* fromTo, size_t npairs)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.mixChannels">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">mixChannels</tt><big>(</big>src, dst, fromTo<big>)</big> &rarr; None<a class="headerlink" href="#cv2.mixChannels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMixChannels(const CvArr** src, int src_count, CvArr** dst, int dst_count, const int* from_to, int pair_count)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMixChannels</tt><big>(</big>const CvArr** <strong>src</strong>, int <strong>src_count</strong>, CvArr** <strong>dst</strong>, int <strong>dst_count</strong>, const int* <strong>from_to</strong>, int <strong>pair_count</strong><big>)</big><a class="headerlink" href="#void cvMixChannels(const CvArr** src, int src_count, CvArr** dst, int dst_count, const int* from_to, int pair_count)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MixChannels">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MixChannels</tt><big>(</big>src, dst, fromTo<big>)</big> &rarr; None<a class="headerlink" href="#cv.MixChannels" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array or vector of matricesl; all of the matrices must have the same size and the same depth.</li>
<li><strong>nsrcs</strong> &#8211; number of matrices in <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>dst</strong> &#8211; output array or vector of matrices; all the matrices <em>must be allocated</em>; their size and depth must be the same as in <tt class="docutils literal"><span class="pre">src[0]</span></tt>.</li>
<li><strong>ndsts</strong> &#8211; number of matrices in <tt class="docutils literal"><span class="pre">dst</span></tt>.</li>
<li><strong>fromTo</strong> &#8211; array of index pairs specifying which channels are copied and where; <tt class="docutils literal"><span class="pre">fromTo[k*2]</span></tt> is a 0-based index of the input channel in <tt class="docutils literal"><span class="pre">src</span></tt>, <tt class="docutils literal"><span class="pre">fromTo[k*2+1]</span></tt> is an index of the output channel in <tt class="docutils literal"><span class="pre">dst</span></tt>; the continuous channel numbering is used: the first input image channels are indexed from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">src[0].channels()-1</span></tt>, the second input image channels are indexed from <tt class="docutils literal"><span class="pre">src[0].channels()</span></tt> to <tt class="docutils literal"><span class="pre">src[0].channels()</span> <span class="pre">+</span> <span class="pre">src[1].channels()-1</span></tt>,  and so on, the same scheme is used for the output image channels; as a special case, when <tt class="docutils literal"><span class="pre">fromTo[k*2]</span></tt> is negative, the corresponding output channel is filled with zero .</li>
<li><strong>npairs</strong> &#8211; number of index pairs in <tt class="docutils literal"><span class="pre">fromTo</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">mixChannels</span></tt> provide an advanced mechanism for shuffling image channels.</p>
<p><a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a> and
<a class="reference internal" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="void merge(const Mat* mv, size_t count, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">merge()</span></tt></a> and some forms of
<a class="reference internal" href="../../imgproc/doc/miscellaneous_transformations.html#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)" title="void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cvtColor()</span></tt></a> are partial cases of <tt class="docutils literal"><span class="pre">mixChannels</span></tt> .</p>
<p>In the example below, the code splits a 4-channel RGBA image into a 3-channel BGR (with R and B channels swapped) and a separate alpha-channel image:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">rgba</span><span class="p">(</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_8UC4</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Mat</span> <span class="n">bgr</span><span class="p">(</span> <span class="n">rgba</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">rgba</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_8UC3</span> <span class="p">);</span>
<span class="n">Mat</span> <span class="n">alpha</span><span class="p">(</span> <span class="n">rgba</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">rgba</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_8UC1</span> <span class="p">);</span>

<span class="c1">// forming an array of matrices is a quite efficient operation,</span>
<span class="c1">// because the matrix data is not copied, only the headers</span>
<span class="n">Mat</span> <span class="n">out</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">bgr</span><span class="p">,</span> <span class="n">alpha</span> <span class="p">};</span>
<span class="c1">// rgba[0] -&gt; bgr[2], rgba[1] -&gt; bgr[1],</span>
<span class="c1">// rgba[2] -&gt; bgr[0], rgba[3] -&gt; alpha[0]</span>
<span class="kt">int</span> <span class="n">from_to</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span> <span class="p">};</span>
<span class="n">mixChannels</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rgba</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">from_to</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike many other new-style C++ functions in OpenCV (see the introduction section and <a class="reference internal" href="basic_structures.html#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></tt></a> ), <tt class="docutils literal"><span class="pre">mixChannels</span></tt> requires the output arrays to be pre-allocated before calling the function.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a>,
<a class="reference internal" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="void merge(const Mat* mv, size_t count, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">merge()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/miscellaneous_transformations.html#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)" title="void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cvtColor()</span></tt></a></p>
</div>
</div>
<div class="section" id="mulspectrums">
<h2>mulSpectrums<a class="headerlink" href="#mulspectrums" title="Permalink to this headline">¶</a></h2>
<p>Performs the per-element multiplication of two Fourier spectrums.</p>
<dl class="function">
<dt id="void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">mulSpectrums</tt><big>(</big>InputArray <strong>a</strong>, InputArray <strong>b</strong>, OutputArray <strong>c</strong>, int <strong>flags</strong>, bool <strong>conjB</strong>=false <big>)</big><a class="headerlink" href="#void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.mulSpectrums">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">mulSpectrums</tt><big>(</big>a, b, flags<span class="optional">[</span>, c<span class="optional">[</span>, conjB<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; c<a class="headerlink" href="#cv2.mulSpectrums" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMulSpectrums(const CvArr* src1, const CvArr* src2, CvArr* dst, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMulSpectrums</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void cvMulSpectrums(const CvArr* src1, const CvArr* src2, CvArr* dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MulSpectrums">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MulSpectrums</tt><big>(</big>src1, src2, dst, flags<big>)</big> &rarr; None<a class="headerlink" href="#cv.MulSpectrums" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt> .</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt> .</li>
<li><strong>flags</strong> &#8211; operation flags; currently, the only supported flag is <tt class="docutils literal"><span class="pre">DFT_ROWS</span></tt>, which indicates that each row of <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">src2</span></tt> is an independent 1D Fourier spectrum.</li>
<li><strong>conjB</strong> &#8211; optional flag that conjugates the second input array before the multiplication (true) or not (false).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">mulSpectrums</span></tt> performs the per-element multiplication of the two CCS-packed or complex matrices that are results of a real or complex Fourier transform.</p>
<p>The function, together with
<a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a> and
<a class="reference internal" href="#void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">idft()</span></tt></a> , may be used to calculate convolution (pass <tt class="docutils literal"><span class="pre">conjB=false</span></tt> ) or correlation (pass <tt class="docutils literal"><span class="pre">conjB=true</span></tt> ) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-array elements. When the arrays are real, they are assumed to be CCS-packed (see
<a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a> for details).</p>
</div>
<div class="section" id="multiply">
<h2>multiply<a class="headerlink" href="#multiply" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element scaled product of two arrays.</p>
<dl class="function">
<dt id="void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">multiply</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, double <strong>scale</strong>=1, int <strong>dtype</strong>=-1 <big>)</big><a class="headerlink" href="#void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.multiply">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">multiply</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, scale<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.multiply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMul(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMul</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, double <strong>scale</strong>=1<big>)</big><a class="headerlink" href="#void cvMul(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Mul">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Mul</tt><big>(</big>src1, src2, dst, scale=1<big>)</big> &rarr; None<a class="headerlink" href="#cv.Mul" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and the same type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>scale</strong> &#8211; optional scale factor.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">multiply</span></tt> calculates the per-element product of two arrays:</p>
<div class="math">
<p><img src="../../../_images/math/65d61798fcf34fc7c044806246a4fc58c391e456.png" alt="\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))"/></p>
</div><p>There is also a
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a> -friendly variant of the first function. See
<a class="reference internal" href="basic_structures.html#MatExpr Mat::mul(InputArray m, double scale) const" title="MatExpr Mat::mul(InputArray m, double scale) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::mul()</span></tt></a> .</p>
<p>For a not-per-element matrix product, see
<a class="reference internal" href="#void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)" title="void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">gemm()</span></tt></a> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saturation is not applied when the output array has the depth <tt class="docutils literal"><span class="pre">CV_32S</span></tt>. You may even get result of an incorrect sign in the case of overflow.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../contrib/doc/openfabmap.html#virtual void add(const Mat&amp; queryImgDescriptor)" title="virtual void add(const Mat&amp; queryImgDescriptor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">add()</span></tt></a>,
<a class="reference internal" href="#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">subtract()</span></tt></a>,
<a class="reference internal" href="#void divide(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)" title="void divide(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">divide()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a>,
<a class="reference internal" href="#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)" title="void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">scaleAdd()</span></tt></a>,
<a class="reference internal" href="#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)" title="void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">addWeighted()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/motion_analysis_and_object_tracking.html#void accumulate(InputArray src, InputOutputArray dst, InputArray mask)" title="void accumulate(InputArray src, InputOutputArray dst, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">accumulate()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateProduct(InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask)" title="void accumulateProduct(InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">accumulateProduct()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateSquare(InputArray src, InputOutputArray dst, InputArray mask)" title="void accumulateSquare(InputArray src, InputOutputArray dst, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">accumulateSquare()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a></p>
</div>
</div>
<div class="section" id="multransposed">
<h2>mulTransposed<a class="headerlink" href="#multransposed" title="Permalink to this headline">¶</a></h2>
<p>Calculates the product of a matrix and its transposition.</p>
<dl class="function">
<dt id="void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">mulTransposed</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, bool <strong>aTa</strong>, InputArray <strong>delta</strong>=noArray(), double <strong>scale</strong>=1, int <strong>dtype</strong>=-1 <big>)</big><a class="headerlink" href="#void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.mulTransposed">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">mulTransposed</tt><big>(</big>src, aTa<span class="optional">[</span>, dst<span class="optional">[</span>, delta<span class="optional">[</span>, scale<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.mulTransposed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMulTransposed(const CvArr* src, CvArr* dst, int order, const CvArr* delta, double scale)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMulTransposed</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>order</strong>, const CvArr* <strong>delta</strong>=NULL, double <strong>scale</strong>=1. <big>)</big><a class="headerlink" href="#void cvMulTransposed(const CvArr* src, CvArr* dst, int order, const CvArr* delta, double scale)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MulTransposed">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MulTransposed</tt><big>(</big>src, dst, order, delta=None, scale=1.0<big>)</big> &rarr; None<a class="headerlink" href="#cv.MulTransposed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input single-channel matrix. Note that unlike <a class="reference internal" href="#void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)" title="void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">gemm()</span></tt></a>, the function can multiply not only floating-point matrices.</li>
<li><strong>dst</strong> &#8211; output square matrix.</li>
<li><strong>aTa</strong> &#8211; Flag specifying the multiplication ordering. See the description below.</li>
<li><strong>delta</strong> &#8211; Optional delta matrix subtracted from  <tt class="docutils literal"><span class="pre">src</span></tt>  before the multiplication. When the matrix is empty ( <tt class="docutils literal"><span class="pre">delta=noArray()</span></tt> ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as  <tt class="docutils literal"><span class="pre">src</span></tt> , it is simply subtracted. Otherwise, it is &#8220;repeated&#8221; (see  <a class="reference internal" href="#void repeat(InputArray src, int ny, int nx, OutputArray dst)" title="void repeat(InputArray src, int ny, int nx, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">repeat()</span></tt></a> ) to cover the full  <tt class="docutils literal"><span class="pre">src</span></tt>  and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the  <tt class="docutils literal"><span class="pre">dtype</span></tt>  parameter description below.</li>
<li><strong>scale</strong> &#8211; Optional scale factor for the matrix product.</li>
<li><strong>dtype</strong> &#8211; Optional type of the output matrix. When it is negative, the output matrix will have the same type as  <tt class="docutils literal"><span class="pre">src</span></tt> . Otherwise, it will be <tt class="docutils literal"><span class="pre">type=CV_MAT_DEPTH(dtype)</span></tt> that should be either  <tt class="docutils literal"><span class="pre">CV_32F</span></tt>  or  <tt class="docutils literal"><span class="pre">CV_64F</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">mulTransposed</span></tt> calculates the product of <tt class="docutils literal"><span class="pre">src</span></tt> and its transposition:</p>
<div class="math">
<p><img src="../../../_images/math/5ef2d3de69c94c92f35fecc977b450f1aa053334.png" alt="\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )"/></p>
</div><p>if <tt class="docutils literal"><span class="pre">aTa=true</span></tt> , and</p>
<div class="math">
<p><img src="../../../_images/math/7e99fbc2b8f79cea25eed3459f3cf5f0b86ab02b.png" alt="\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T"/></p>
</div><p>otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product <tt class="docutils literal"><span class="pre">A*B</span></tt> when <tt class="docutils literal"><span class="pre">B=A'</span></tt></p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)" title="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcCovarMatrix()</span></tt></a>,
<a class="reference internal" href="#void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)" title="void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">gemm()</span></tt></a>,
<a class="reference internal" href="#void repeat(InputArray src, int ny, int nx, OutputArray dst)" title="void repeat(InputArray src, int ny, int nx, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">repeat()</span></tt></a>,
<a class="reference internal" href="#void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)" title="void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">reduce()</span></tt></a></p>
</div>
</div>
<div class="section" id="norm">
<h2>norm<a class="headerlink" href="#norm" title="Permalink to this headline">¶</a></h2>
<p>Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.</p>
<dl class="function">
<dt id="double norm(InputArray src1, int normType, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">norm</tt><big>(</big>InputArray <strong>src1</strong>, int <strong>normType</strong>=NORM_L2, InputArray <strong>mask</strong>=noArray()<big>)</big><a class="headerlink" href="#double norm(InputArray src1, int normType, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="double norm(InputArray src1, InputArray src2, int normType, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">norm</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, int <strong>normType</strong>=NORM_L2, InputArray <strong>mask</strong>=noArray() <big>)</big><a class="headerlink" href="#double norm(InputArray src1, InputArray src2, int normType, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="double norm(const SparseMat&amp; src, int normType)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">norm</tt><big>(</big>const SparseMat&amp; <strong>src</strong>, int <strong>normType</strong><big>)</big><a class="headerlink" href="#double norm(const SparseMat& src, int normType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.norm">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">norm</tt><big>(</big>src1<span class="optional">[</span>, normType<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval<a class="headerlink" href="#cv2.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt>
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">norm</tt><big>(</big>src1, src2<span class="optional">[</span>, normType<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval</dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvNorm(const CvArr* arr1, const CvArr* arr2, int norm_type, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>double <tt class="descname">cvNorm</tt><big>(</big>const CvArr* <strong>arr1</strong>, const CvArr* <strong>arr2</strong>=NULL, int <strong>norm_type</strong>=CV_L2, const CvArr* <strong>mask</strong>=NULL <big>)</big><a class="headerlink" href="#double cvNorm(const CvArr* arr1, const CvArr* arr2, int norm_type, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Norm">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Norm</tt><big>(</big>arr1, arr2, normType=CV_L2, mask=None<big>)</big> &rarr; float<a class="headerlink" href="#cv.Norm" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and the same type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>normType</strong> &#8211; type of the norm (see the details below).</li>
<li><strong>mask</strong> &#8211; optional operation mask; it must have the same size as <tt class="docutils literal"><span class="pre">src1</span></tt> and <tt class="docutils literal"><span class="pre">CV_8UC1</span></tt> type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">norm</span></tt> calculate an absolute norm of <tt class="docutils literal"><span class="pre">src1</span></tt> (when there is no <tt class="docutils literal"><span class="pre">src2</span></tt> ):</p>
<div class="math">
<p><img src="../../../_images/math/68ec6be72b6147b098cb994ffab375dd03251aab.png" alt="norm =  \forkthree{\|\texttt{src1}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I)|}{if  $\texttt{normType} = \texttt{NORM\_INF}$ }
{ \| \texttt{src1} \| _{L_1} =  \sum _I | \texttt{src1} (I)|}{if  $\texttt{normType} = \texttt{NORM\_L1}$ }
{ \| \texttt{src1} \| _{L_2} =  \sqrt{\sum_I \texttt{src1}(I)^2} }{if  $\texttt{normType} = \texttt{NORM\_L2}$ }"/></p>
</div><p>or an absolute or relative difference norm if <tt class="docutils literal"><span class="pre">src2</span></tt> is there:</p>
<div class="math">
<p><img src="../../../_images/math/5ea7be875bf46439f3f118a4c8656632aee3f562.png" alt="norm =  \forkthree{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I) -  \texttt{src2} (I)|}{if  $\texttt{normType} = \texttt{NORM\_INF}$ }
{ \| \texttt{src1} - \texttt{src2} \| _{L_1} =  \sum _I | \texttt{src1} (I) -  \texttt{src2} (I)|}{if  $\texttt{normType} = \texttt{NORM\_L1}$ }
{ \| \texttt{src1} - \texttt{src2} \| _{L_2} =  \sqrt{\sum_I (\texttt{src1}(I) - \texttt{src2}(I))^2} }{if  $\texttt{normType} = \texttt{NORM\_L2}$ }"/></p>
</div><p>or</p>
<div class="math">
<p><img src="../../../_images/math/419faea8be9afd139a1a256bb48e87575658be3d.png" alt="norm =  \forkthree{\frac{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}}    }{\|\texttt{src2}\|_{L_{\infty}} }}{if  $\texttt{normType} = \texttt{NORM\_RELATIVE\_INF}$ }
{ \frac{\|\texttt{src1}-\texttt{src2}\|_{L_1} }{\|\texttt{src2}\|_{L_1}} }{if  $\texttt{normType} = \texttt{NORM\_RELATIVE\_L1}$ }
{ \frac{\|\texttt{src1}-\texttt{src2}\|_{L_2} }{\|\texttt{src2}\|_{L_2}} }{if  $\texttt{normType} = \texttt{NORM\_RELATIVE\_L2}$ }"/></p>
</div><p>The functions <tt class="docutils literal"><span class="pre">norm</span></tt> return the calculated norm.</p>
<p>When the <tt class="docutils literal"><span class="pre">mask</span></tt> parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.</p>
<p>A multi-channel input arrays are treated as a single-channel, that is, the results for all channels are combined.</p>
</div>
<div class="section" id="normalize">
<h2>normalize<a class="headerlink" href="#normalize" title="Permalink to this headline">¶</a></h2>
<p>Normalizes the norm or value range of an array.</p>
<dl class="function">
<dt id="void normalize(InputArray src, OutputArray dst, double alpha, double beta, int norm_type, int dtype, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">normalize</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, double <strong>alpha</strong>=1, double <strong>beta</strong>=0, int <strong>norm_type</strong>=NORM_L2, int <strong>dtype</strong>=-1, InputArray <strong>mask</strong>=noArray() <big>)</big><a class="headerlink" href="#void normalize(InputArray src, OutputArray dst, double alpha, double beta, int norm_type, int dtype, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void normalize(const SparseMat&amp; src, SparseMat&amp; dst, double alpha, int normType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">normalize</tt><big>(</big>const SparseMat&amp; <strong>src</strong>, SparseMat&amp; <strong>dst</strong>, double <strong>alpha</strong>, int <strong>normType</strong><big>)</big><a class="headerlink" href="#void normalize(const SparseMat& src, SparseMat& dst, double alpha, int normType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.normalize">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">normalize</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, alpha<span class="optional">[</span>, beta<span class="optional">[</span>, norm_type<span class="optional">[</span>, dtype<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.normalize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array of the same size as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>alpha</strong> &#8211; norm value to normalize to or the lower range boundary in case of the range normalization.</li>
<li><strong>beta</strong> &#8211; upper range boundary in case of the range normalization; it is not used for the norm normalization.</li>
<li><strong>normType</strong> &#8211; normalization type (see the details below).</li>
<li><strong>dtype</strong> &#8211; when negative, the output array has the same type as <tt class="docutils literal"><span class="pre">src</span></tt>; otherwise, it has the same number of channels as  <tt class="docutils literal"><span class="pre">src</span></tt> and the depth <tt class="docutils literal"><span class="pre">=CV_MAT_DEPTH(dtype)</span></tt>.</li>
<li><strong>mask</strong> &#8211; optional operation mask.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">normalize</span></tt> scale and shift the input array elements so that</p>
<div class="math">
<p><img src="../../../_images/math/76a02dc3eac976633a7b7e394a268210e7bf0b3d.png" alt="\| \texttt{dst} \| _{L_p}= \texttt{alpha}"/></p>
</div><p>(where p=Inf, 1 or 2) when <tt class="docutils literal"><span class="pre">normType=NORM_INF</span></tt>, <tt class="docutils literal"><span class="pre">NORM_L1</span></tt>, or <tt class="docutils literal"><span class="pre">NORM_L2</span></tt>, respectively; or so that</p>
<div class="math">
<p><img src="../../../_images/math/31bceb122fccfc14279355379f91c7b269290386.png" alt="\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}"/></p>
</div><p>when <tt class="docutils literal"><span class="pre">normType=NORM_MINMAX</span></tt> (for dense arrays only).
The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use
<a class="reference internal" href="#double norm(InputArray src1, int normType, InputArray mask)" title="double norm(InputArray src1, int normType, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">norm()</span></tt></a> and
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#double norm(InputArray src1, int normType, InputArray mask)" title="double norm(InputArray src1, int normType, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">norm()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const" title="void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">SparseMat::convertTo()</span></tt></a></p>
</div>
</div>
<div class="section" id="pca">
<h2>PCA<a class="headerlink" href="#pca" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="PCA">
<em class="property">class </em><tt class="descname">PCA</tt><a class="headerlink" href="#PCA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Principal Component Analysis class.</p>
<p>The class is used to calculate a special basis for a set of vectors. The basis will consist of eigenvectors of the covariance matrix calculated from the input set of vectors. The class <tt class="docutils literal"><span class="pre">PCA</span></tt> can also transform vectors to/from the new coordinate space defined by the basis. Usually, in this new coordinate system, each vector from the original set (and any linear combination of such vectors) can be quite accurately approximated by taking its first few components, corresponding to the eigenvectors of the largest eigenvalues of the covariance matrix. Geometrically it means that you calculate a projection of the vector to a subspace formed by a few eigenvectors corresponding to the dominant eigenvalues of the covariance matrix. And usually such a projection is very close to the original vector. So, you can represent the original vector from a high-dimensional space with a much shorter vector consisting of the projected vector&#8217;s coordinates in the subspace. Such a transformation is also known as Karhunen-Loeve Transform, or KLT. See
<a class="reference external" href="http://en.wikipedia.org/wiki/Principal_component_analysis">http://en.wikipedia.org/wiki/Principal_component_analysis</a> .</p>
<p>The sample below is the function that takes two matrices. The first function stores a set of vectors (a row per vector) that is used to calculate PCA. The second function stores another &#8220;test&#8221; set of vectors (a row per vector). First, these vectors are compressed with PCA, then reconstructed back, and then the reconstruction error norm is computed and printed for each vector.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">PCA</span> <span class="n">compressPCA</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">pcaset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxComponents</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">testset</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">compressed</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PCA</span> <span class="n">pca</span><span class="p">(</span><span class="n">pcaset</span><span class="p">,</span> <span class="c1">// pass the data</span>
            <span class="n">Mat</span><span class="p">(),</span> <span class="c1">// there is no pre-computed mean vector,</span>
                   <span class="c1">// so let the PCA engine to compute it</span>
            <span class="n">CV_PCA_DATA_AS_ROW</span><span class="p">,</span> <span class="c1">// indicate that the vectors</span>
                                <span class="c1">// are stored as matrix rows</span>
                                <span class="c1">// (use CV_PCA_DATA_AS_COL if the vectors are</span>
                                <span class="c1">// the matrix columns)</span>
            <span class="n">maxComponents</span> <span class="c1">// specify how many principal components to retain</span>
            <span class="p">);</span>
    <span class="c1">// if there is no test data, just return the computed basis, ready-to-use</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">testset</span><span class="p">.</span><span class="n">data</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">pca</span><span class="p">;</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">testset</span><span class="p">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">pcaset</span><span class="p">.</span><span class="n">cols</span> <span class="p">);</span>

    <span class="n">compressed</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">testset</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">maxComponents</span><span class="p">,</span> <span class="n">testset</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="n">Mat</span> <span class="n">reconstructed</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testset</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Mat</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">testset</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">compressed</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="c1">// compress the vector, the result will be stored</span>
        <span class="c1">// in the i-th row of the output matrix</span>
        <span class="n">pca</span><span class="p">.</span><span class="n">project</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">);</span>
        <span class="c1">// and then reconstruct it</span>
        <span class="n">pca</span><span class="p">.</span><span class="n">backProject</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">reconstructed</span><span class="p">);</span>
        <span class="c1">// and measure the error</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d. diff = %g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">reconstructed</span><span class="p">,</span> <span class="n">NORM_L2</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pca</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)" title="void calcCovarMatrix(const Mat* samples, int nsamples, Mat&amp; covar, Mat&amp; mean, int flags, int ctype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcCovarMatrix()</span></tt></a>,
<a class="reference internal" href="#void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)" title="void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mulTransposed()</span></tt></a>,
<a class="reference internal" href="#SVD" title="class SVD"><tt class="xref ocv ocv-class docutils literal"><span class="pre">SVD</span></tt></a>,
<a class="reference internal" href="#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a>,
<a class="reference internal" href="#void dct(InputArray src, OutputArray dst, int flags)" title="void dct(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dct()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using PCA for dimensionality reduction while maintaining an amount of variance can be found at opencv_source_code/samples/cpp/pca.cpp</li>
</ul>
</div>
</div>
<div class="section" id="pca-pca">
<h2>PCA::PCA<a class="headerlink" href="#pca-pca" title="Permalink to this headline">¶</a></h2>
<p>PCA constructors</p>
<dl class="function">
<dt id="PCA::PCA()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">PCA::</tt><tt class="descname">PCA</tt><big>(</big><big>)</big><a class="headerlink" href="#PCA::PCA()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="PCA::PCA(InputArray data, InputArray mean, int flags, int maxComponents)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">PCA::</tt><tt class="descname">PCA</tt><big>(</big>InputArray <strong>data</strong>, InputArray <strong>mean</strong>, int <strong>flags</strong>, int <strong>maxComponents</strong>=0<big>)</big><a class="headerlink" href="#PCA::PCA(InputArray data, InputArray mean, int flags, int maxComponents)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="PCA::PCA(InputArray data, InputArray mean, int flags, double retainedVariance)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">PCA::</tt><tt class="descname">PCA</tt><big>(</big>InputArray <strong>data</strong>, InputArray <strong>mean</strong>, int <strong>flags</strong>, double <strong>retainedVariance</strong><big>)</big><a class="headerlink" href="#PCA::PCA(InputArray data, InputArray mean, int flags, double retainedVariance)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; input samples stored as matrix rows or matrix columns.</li>
<li><strong>mean</strong> &#8211; optional mean value; if the matrix is empty (<tt class="docutils literal"><span class="pre">noArray()</span></tt>), the mean is computed from the data.</li>
<li><strong>flags</strong> &#8211; <p>operation flags; currently the parameter is only used to specify the data layout:</p>
<ul>
<li><strong>CV_PCA_DATA_AS_ROW</strong> indicates that the input samples are stored as matrix rows.</li>
<li><strong>CV_PCA_DATA_AS_COL</strong> indicates that the input samples are stored as matrix columns.</li>
</ul>
</li>
<li><strong>maxComponents</strong> &#8211; maximum number of components that PCA should retain; by default, all the components are retained.</li>
<li><strong>retainedVariance</strong> &#8211; Percentage of variance that PCA should retain. Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The default constructor initializes an empty PCA structure. The other constructors initialize the structure and call
<a class="reference internal" href="#PCA&amp; PCA::operator()(InputArray data, InputArray mean, int flags, int maxComponents)" title="PCA&amp; PCA::operator()(InputArray data, InputArray mean, int flags, int maxComponents)"><tt class="xref ocv ocv-funcx docutils literal"><span class="pre">PCA::operator()</span></tt></a> .</p>
</div>
<div class="section" id="pca-operator">
<h2>PCA::operator ()<a class="headerlink" href="#pca-operator" title="Permalink to this headline">¶</a></h2>
<p>Performs Principal Component Analysis of the supplied dataset.</p>
<dl class="function">
<dt id="PCA&amp; PCA::operator()(InputArray data, InputArray mean, int flags, int maxComponents)">
<strong>C++:</strong><tt class="descname"> </tt>PCA&amp; <tt class="descclassname">PCA::</tt><tt class="descname">operator()</tt><big>(</big>InputArray <strong>data</strong>, InputArray <strong>mean</strong>, int <strong>flags</strong>, int <strong>maxComponents</strong>=0<big>)</big><a class="headerlink" href="#PCA& PCA::operator()(InputArray data, InputArray mean, int flags, int maxComponents)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="PCA&amp; PCA::computeVar(InputArray data, InputArray mean, int flags, double retainedVariance)">
<strong>C++:</strong><tt class="descname"> </tt>PCA&amp; <tt class="descclassname">PCA::</tt><tt class="descname">computeVar</tt><big>(</big>InputArray <strong>data</strong>, InputArray <strong>mean</strong>, int <strong>flags</strong>, double <strong>retainedVariance</strong><big>)</big><a class="headerlink" href="#PCA& PCA::computeVar(InputArray data, InputArray mean, int flags, double retainedVariance)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.PCACompute">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">PCACompute</tt><big>(</big>data<span class="optional">[</span>, mean<span class="optional">[</span>, eigenvectors<span class="optional">[</span>, maxComponents<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; mean, eigenvectors<a class="headerlink" href="#cv2.PCACompute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.PCAComputeVar">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">PCAComputeVar</tt><big>(</big>data, retainedVariance<span class="optional">[</span>, mean<span class="optional">[</span>, eigenvectors<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; mean, eigenvectors<a class="headerlink" href="#cv2.PCAComputeVar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; input samples stored as the matrix rows or as the matrix columns.</li>
<li><strong>mean</strong> &#8211; optional mean value; if the matrix is empty (<tt class="docutils literal"><span class="pre">noArray()</span></tt>), the mean is computed from the data.</li>
<li><strong>flags</strong> &#8211; <p>operation flags; currently the parameter is only used to specify the data layout.</p>
<ul>
<li><strong>CV_PCA_DATA_AS_ROW</strong> indicates that the input samples are stored as matrix rows.</li>
<li><strong>CV_PCA_DATA_AS_COL</strong> indicates that the input samples are stored as matrix columns.</li>
</ul>
</li>
<li><strong>maxComponents</strong> &#8211; maximum number of components that PCA should retain; by default, all the components are retained.</li>
<li><strong>retainedVariance</strong> &#8211; Percentage of variance that PCA should retain. Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The operator performs PCA of the supplied dataset. It is safe to reuse the same PCA structure for multiple datasets. That is, if the  structure has been previously used with another dataset, the existing internal data is reclaimed and the new <tt class="docutils literal"><span class="pre">eigenvalues</span></tt>, <tt class="docutils literal"><span class="pre">eigenvectors</span></tt> , and <tt class="docutils literal"><span class="pre">mean</span></tt> are allocated and computed.</p>
<p>The computed eigenvalues are sorted from the largest to the smallest and the corresponding eigenvectors are stored as <tt class="docutils literal"><span class="pre">PCA::eigenvectors</span></tt> rows.</p>
</div>
<div class="section" id="pca-project">
<h2>PCA::project<a class="headerlink" href="#pca-project" title="Permalink to this headline">¶</a></h2>
<p>Projects vector(s) to the principal component subspace.</p>
<dl class="function">
<dt id="Mat PCA::project(InputArray vec) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">PCA::</tt><tt class="descname">project</tt><big>(</big>InputArray <strong>vec</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat PCA::project(InputArray vec) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void PCA::project(InputArray vec, OutputArray result) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">PCA::</tt><tt class="descname">project</tt><big>(</big>InputArray <strong>vec</strong>, OutputArray <strong>result</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void PCA::project(InputArray vec, OutputArray result) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.PCAProject">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">PCAProject</tt><big>(</big>data, mean, eigenvectors<span class="optional">[</span>, result<span class="optional">]</span><big>)</big> &rarr; result<a class="headerlink" href="#cv2.PCAProject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vec</strong> &#8211; input vector(s); must have the same dimensionality and the same layout as the input data used at PCA phase, that is, if <tt class="docutils literal"><span class="pre">CV_PCA_DATA_AS_ROW</span></tt> are specified, then <tt class="docutils literal"><span class="pre">vec.cols==data.cols</span></tt> (vector dimensionality) and <tt class="docutils literal"><span class="pre">vec.rows</span></tt> is the number of vectors to project, and the same is true for the <tt class="docutils literal"><span class="pre">CV_PCA_DATA_AS_COL</span></tt> case.</li>
<li><strong>result</strong> &#8211; output vectors; in case of <tt class="docutils literal"><span class="pre">CV_PCA_DATA_AS_COL</span></tt>, the output matrix has as many columns as the number of input vectors, this means that <tt class="docutils literal"><span class="pre">result.cols==vec.cols</span></tt> and the number of rows match the number of principal components (for example, <tt class="docutils literal"><span class="pre">maxComponents</span></tt> parameter passed to the constructor).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods project one or more vectors to the principal component subspace, where each vector projection is represented by coefficients in the principal component basis. The first form of the method returns the matrix that the second form writes to the result. So the first form can be used as a part of expression while the second form can be more efficient in a processing loop.</p>
</div>
<div class="section" id="pca-backproject">
<h2>PCA::backProject<a class="headerlink" href="#pca-backproject" title="Permalink to this headline">¶</a></h2>
<p>Reconstructs vectors from their PC projections.</p>
<dl class="function">
<dt id="Mat PCA::backProject(InputArray vec) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">PCA::</tt><tt class="descname">backProject</tt><big>(</big>InputArray <strong>vec</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat PCA::backProject(InputArray vec) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void PCA::backProject(InputArray vec, OutputArray result) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">PCA::</tt><tt class="descname">backProject</tt><big>(</big>InputArray <strong>vec</strong>, OutputArray <strong>result</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void PCA::backProject(InputArray vec, OutputArray result) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.PCABackProject">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">PCABackProject</tt><big>(</big>data, mean, eigenvectors<span class="optional">[</span>, result<span class="optional">]</span><big>)</big> &rarr; result<a class="headerlink" href="#cv2.PCABackProject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vec</strong> &#8211; coordinates of the vectors in the principal component subspace, the layout and size are the same as of <tt class="docutils literal"><span class="pre">PCA::project</span></tt> output vectors.</li>
<li><strong>result</strong> &#8211; reconstructed vectors; the layout and size are the same as of <tt class="docutils literal"><span class="pre">PCA::project</span></tt> input vectors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods are inverse operations to
<a class="reference internal" href="#Mat PCA::project(InputArray vec) const" title="Mat PCA::project(InputArray vec) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">PCA::project()</span></tt></a>. They take PC coordinates of projected vectors and reconstruct the original vectors. Unless all the principal components have been retained, the reconstructed vectors are different from the originals. But typically, the difference is small if the number of components is large enough (but still much smaller than the original vector dimensionality). As a result, PCA is used.</p>
</div>
<div class="section" id="perspectivetransform">
<h2>perspectiveTransform<a class="headerlink" href="#perspectivetransform" title="Permalink to this headline">¶</a></h2>
<p>Performs the perspective matrix transformation of vectors.</p>
<dl class="function">
<dt id="void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">perspectiveTransform</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>m</strong><big>)</big><a class="headerlink" href="#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.perspectiveTransform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">perspectiveTransform</tt><big>(</big>src, m<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.perspectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPerspectiveTransform(const CvArr* src, CvArr* dst, const CvMat* mat)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPerspectiveTransform</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>mat</strong><big>)</big><a class="headerlink" href="#void cvPerspectiveTransform(const CvArr* src, CvArr* dst, const CvMat* mat)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PerspectiveTransform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">PerspectiveTransform</tt><big>(</big>src, dst, mat<big>)</big> &rarr; None<a class="headerlink" href="#cv.PerspectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input two-channel or three-channel floating-point array; each element is a 2D/3D vector to be transformed.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>m</strong> &#8211; <tt class="docutils literal"><span class="pre">3x3</span></tt> or <tt class="docutils literal"><span class="pre">4x4</span></tt> floating-point transformation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">perspectiveTransform</span></tt> transforms every element of <tt class="docutils literal"><span class="pre">src</span></tt> by treating it as a 2D or 3D vector, in the following way:</p>
<div class="math">
<p><img src="../../../_images/math/1ed45f9ec6a3459474456fb822eca07cc0ebab44.png" alt="(x, y, z)  \rightarrow (x'/w, y'/w, z'/w)"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/99ea8b71d4a237dac086e55351fc931331484fb4.png" alt="(x', y', z', w') =  \texttt{mat} \cdot \begin{bmatrix} x &amp; y &amp; z &amp; 1  \end{bmatrix}"/></p>
</div><p>and</p>
<div class="math">
<p><img src="../../../_images/math/ec51867b9cd6442312e5ef70a42e721131cbaa7b.png" alt="w =  \fork{w'}{if $w' \ne 0$}{\infty}{otherwise}"/></p>
</div><p>Here a 3D vector transformation is shown. In case of a 2D vector transformation, the <tt class="docutils literal"><span class="pre">z</span></tt> component is omitted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function transforms a sparse set of 2D or 3D vectors. If you want to transform an image using perspective transformation, use <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a> . If you have an inverse problem, that is, you want to compute the most probable perspective transformation out of several pairs of corresponding points, you can use <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(InputArray src, InputArray dst)" title="Mat getPerspectiveTransform(InputArray src, InputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getPerspectiveTransform()</span></tt></a> or <a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)" title="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findHomography()</span></tt></a> .</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void transform(InputArray src, OutputArray dst, InputArray m)" title="void transform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transform()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(InputArray src, InputArray dst)" title="Mat getPerspectiveTransform(InputArray src, InputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getPerspectiveTransform()</span></tt></a>,
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)" title="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findHomography()</span></tt></a></p>
</div>
</div>
<div class="section" id="phase">
<h2>phase<a class="headerlink" href="#phase" title="Permalink to this headline">¶</a></h2>
<p>Calculates the rotation angle of 2D vectors.</p>
<dl class="function">
<dt id="void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">phase</tt><big>(</big>InputArray <strong>x</strong>, InputArray <strong>y</strong>, OutputArray <strong>angle</strong>, bool <strong>angleInDegrees</strong>=false<big>)</big><a class="headerlink" href="#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.phase">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">phase</tt><big>(</big>x, y<span class="optional">[</span>, angle<span class="optional">[</span>, angleInDegrees<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; angle<a class="headerlink" href="#cv2.phase" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; input floating-point array of x-coordinates of 2D vectors.</li>
<li><strong>y</strong> &#8211; input array of y-coordinates of 2D vectors; it must have the same size and the same type as <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
<li><strong>angle</strong> &#8211; output array of vector angles; it has the same size and same type as  <tt class="docutils literal"><span class="pre">x</span></tt> .</li>
<li><strong>angleInDegrees</strong> &#8211; when true, the function calculates the angle in degrees, otherwise, they are measured in radians.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">phase</span></tt> calculates the rotation angle of each 2D vector that is formed from the corresponding elements of <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/c3ed7481ed18b5df361239ebf45c863e5aaed098.png" alt="\texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))"/></p>
</div><p>The angle estimation accuracy is about 0.3 degrees. When <tt class="docutils literal"><span class="pre">x(I)=y(I)=0</span></tt> , the corresponding <tt class="docutils literal"><span class="pre">angle(I)</span></tt> is set to 0.</p>
</div>
<div class="section" id="polartocart">
<h2>polarToCart<a class="headerlink" href="#polartocart" title="Permalink to this headline">¶</a></h2>
<p>Calculates x and y coordinates of 2D vectors from their magnitude and angle.</p>
<dl class="function">
<dt id="void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">polarToCart</tt><big>(</big>InputArray <strong>magnitude</strong>, InputArray <strong>angle</strong>, OutputArray <strong>x</strong>, OutputArray <strong>y</strong>, bool <strong>angleInDegrees</strong>=false<big>)</big><a class="headerlink" href="#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.polarToCart">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">polarToCart</tt><big>(</big>magnitude, angle<span class="optional">[</span>, x<span class="optional">[</span>, y<span class="optional">[</span>, angleInDegrees<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; x, y<a class="headerlink" href="#cv2.polarToCart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPolarToCart(const CvArr* magnitude, const CvArr* angle, CvArr* x, CvArr* y, int angle_in_degrees)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPolarToCart</tt><big>(</big>const CvArr* <strong>magnitude</strong>, const CvArr* <strong>angle</strong>, CvArr* <strong>x</strong>, CvArr* <strong>y</strong>, int <strong>angle_in_degrees</strong>=0 <big>)</big><a class="headerlink" href="#void cvPolarToCart(const CvArr* magnitude, const CvArr* angle, CvArr* x, CvArr* y, int angle_in_degrees)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PolarToCart">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">PolarToCart</tt><big>(</big>magnitude, angle, x, y, angleInDegrees=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.PolarToCart" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>magnitude</strong> &#8211; input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (<tt class="docutils literal"><span class="pre">=Mat()</span></tt>), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as <tt class="docutils literal"><span class="pre">angle</span></tt>.</li>
<li><strong>angle</strong> &#8211; input floating-point array of angles of 2D vectors.</li>
<li><strong>x</strong> &#8211; output array of x-coordinates of 2D vectors; it has the same size and type as <tt class="docutils literal"><span class="pre">angle</span></tt>.</li>
<li><strong>y</strong> &#8211; output array of y-coordinates of 2D vectors; it has the same size and type as <tt class="docutils literal"><span class="pre">angle</span></tt>.</li>
<li><strong>angleInDegrees</strong> &#8211; when true, the input angles are measured in degrees, otherwise, they are measured in radians.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">polarToCart</span></tt> calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of <tt class="docutils literal"><span class="pre">magnitude</span></tt> and <tt class="docutils literal"><span class="pre">angle</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/b1180a6e75534abbf1cc6673bdb2817aeaf2f5de.png" alt="\begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array}"/></p>
</div><p>The relative accuracy of the estimated coordinates is about <tt class="docutils literal"><span class="pre">1e-6</span></tt>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a>,
<a class="reference internal" href="#void magnitude(InputArray x, InputArray y, OutputArray magnitude)" title="void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">magnitude()</span></tt></a>,
<a class="reference internal" href="#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)" title="void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">phase()</span></tt></a>,
<a class="reference internal" href="#void exp(InputArray src, OutputArray dst)" title="void exp(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">exp()</span></tt></a>,
<a class="reference internal" href="#void log(InputArray src, OutputArray dst)" title="void log(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">log()</span></tt></a>,
<a class="reference internal" href="#void pow(InputArray src, double power, OutputArray dst)" title="void pow(InputArray src, double power, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pow()</span></tt></a>,
<a class="reference internal" href="#void sqrt(InputArray src, OutputArray dst)" title="void sqrt(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sqrt()</span></tt></a></p>
</div>
</div>
<div class="section" id="pow">
<h2>pow<a class="headerlink" href="#pow" title="Permalink to this headline">¶</a></h2>
<p>Raises every array element to a power.</p>
<dl class="function">
<dt id="void pow(InputArray src, double power, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">pow</tt><big>(</big>InputArray <strong>src</strong>, double <strong>power</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void pow(InputArray src, double power, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pow">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">pow</tt><big>(</big>src, power<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.pow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPow(const CvArr* src, CvArr* dst, double power)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPow</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>power</strong><big>)</big><a class="headerlink" href="#void cvPow(const CvArr* src, CvArr* dst, double power)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Pow">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Pow</tt><big>(</big>src, dst, power<big>)</big> &rarr; None<a class="headerlink" href="#cv.Pow" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>power</strong> &#8211; exponent of power.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">pow</span></tt> raises every element of the input array to <tt class="docutils literal"><span class="pre">power</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/cd4d883626e30cda7e986a3033f99ffdbc039454.png" alt="\texttt{dst} (I) =  \fork{\texttt{src}(I)^power}{if \texttt{power} is integer}{|\texttt{src}(I)|^power}{otherwise}"/></p>
</div><p>So, for a non-integer power exponent, the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations. In the example below, computing the 5th root of array <tt class="docutils literal"><span class="pre">src</span></tt>  shows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pow</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
<span class="n">subtract</span><span class="p">(</span><span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p>For some values of <tt class="docutils literal"><span class="pre">power</span></tt> , such as integer values, 0.5 and -0.5, specialized faster algorithms are used.</p>
<p>Special values (NaN, Inf) are not handled.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sqrt(InputArray src, OutputArray dst)" title="void sqrt(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sqrt()</span></tt></a>,
<a class="reference internal" href="#void exp(InputArray src, OutputArray dst)" title="void exp(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">exp()</span></tt></a>,
<a class="reference internal" href="#void log(InputArray src, OutputArray dst)" title="void log(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">log()</span></tt></a>,
<a class="reference internal" href="#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a>,
<a class="reference internal" href="#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)" title="void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">polarToCart()</span></tt></a></p>
</div>
</div>
<div class="section" id="rng">
<h2>RNG<a class="headerlink" href="#rng" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="RNG">
<em class="property">class </em><tt class="descname">RNG</tt><a class="headerlink" href="#RNG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Random number generator. It encapsulates the state (currently, a 64-bit integer) and has methods to return scalar random values and to fill arrays with random values. Currently it supports uniform and Gaussian (normal) distributions. The generator uses Multiply-With-Carry algorithm, introduced by G. Marsaglia (
<a class="reference external" href="http://en.wikipedia.org/wiki/Multiply-with-carry">http://en.wikipedia.org/wiki/Multiply-with-carry</a>
). Gaussian-distribution random numbers are generated using the Ziggurat algorithm (
<a class="reference external" href="http://en.wikipedia.org/wiki/Ziggurat_algorithm">http://en.wikipedia.org/wiki/Ziggurat_algorithm</a>
), introduced by G. Marsaglia and W. W. Tsang.</p>
</div>
<div class="section" id="rng-rng">
<h2>RNG::RNG<a class="headerlink" href="#rng-rng" title="Permalink to this headline">¶</a></h2>
<p>The constructors</p>
<dl class="function">
<dt id="RNG::RNG()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">RNG</tt><big>(</big><big>)</big><a class="headerlink" href="#RNG::RNG()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::RNG(uint64 state)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">RNG</tt><big>(</big>uint64 <strong>state</strong><big>)</big><a class="headerlink" href="#RNG::RNG(uint64 state)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; 64-bit value used to initialize the RNG.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These are the RNG constructors. The first form sets the state to some pre-defined value, equal to <tt class="docutils literal"><span class="pre">2**32-1</span></tt> in the current implementation. The second form sets the state to the specified value. If you passed <tt class="docutils literal"><span class="pre">state=0</span></tt> , the constructor uses the above default value instead to avoid the singular random number sequence, consisting of all zeros.</p>
</div>
<div class="section" id="rng-next">
<h2>RNG::next<a class="headerlink" href="#rng-next" title="Permalink to this headline">¶</a></h2>
<p>Returns the next random number.</p>
<dl class="function">
<dt id="unsigned RNG::next()">
<strong>C++:</strong><tt class="descname"> </tt>unsigned int <tt class="descclassname">RNG::</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#unsigned RNG::next()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method updates the state using the MWC algorithm and returns the next 32-bit random number.</p>
</div>
<div class="section" id="rng-operator-t">
<h2>RNG::operator T<a class="headerlink" href="#rng-operator-t" title="Permalink to this headline">¶</a></h2>
<p>Returns the next random number of the specified type.</p>
<dl class="function">
<dt id="RNG::operator uchar()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> uchar<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator uchar()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator schar()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> schar<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator schar()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator ushort()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> ushort<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator ushort()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator short()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> short int<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator short()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator int()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> int<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator int()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator unsigned()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> unsigned int<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator unsigned()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator float()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> float<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator float()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RNG::operator double()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RNG::</tt><tt class="descname">operator</tt> double<big>(</big><big>)</big><a class="headerlink" href="#RNG::operator double()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Each of the methods updates the state using the MWC algorithm and returns the next random number of the specified type. In case of integer types, the returned number is from the available value range for the specified type. In case of floating-point types, the returned value is from <tt class="docutils literal"><span class="pre">[0,1)</span></tt> range.</p>
</div>
<div class="section" id="rng-operator">
<h2>RNG::operator ()<a class="headerlink" href="#rng-operator" title="Permalink to this headline">¶</a></h2>
<p>Returns the next random number.</p>
<dl class="function">
<dt id="unsigned RNG::operator ()()">
<strong>C++:</strong><tt class="descname"> </tt>unsigned int <tt class="descclassname">RNG::</tt><tt class="descname">operator()</tt><big>(</big><big>)</big><a class="headerlink" href="#unsigned RNG::operator ()()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="unsigned RNG::operator ()(unsigned N)">
<strong>C++:</strong><tt class="descname"> </tt>unsigned int <tt class="descclassname">RNG::</tt><tt class="descname">operator()</tt><big>(</big>unsigned int <strong>N</strong><big>)</big><a class="headerlink" href="#unsigned RNG::operator ()(unsigned N)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>N</strong> &#8211; upper non-inclusive boundary of the returned random number.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods transform the state using the MWC algorithm and return the next random number. The first form is equivalent to
<a class="reference internal" href="#unsigned RNG::next()" title="unsigned RNG::next()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">RNG::next()</span></tt></a> . The second form returns the random number modulo <tt class="docutils literal"><span class="pre">N</span></tt> , which means that the result is in the range <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">N)</span></tt> .</p>
</div>
<div class="section" id="rng-uniform">
<h2>RNG::uniform<a class="headerlink" href="#rng-uniform" title="Permalink to this headline">¶</a></h2>
<p>Returns the next random number sampled from the uniform distribution.</p>
<dl class="function">
<dt id="int RNG::uniform(int a, int b)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">RNG::</tt><tt class="descname">uniform</tt><big>(</big>int <strong>a</strong>, int <strong>b</strong><big>)</big><a class="headerlink" href="#int RNG::uniform(int a, int b)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="float RNG::uniform(float a, float b)">
<strong>C++:</strong><tt class="descname"> </tt>float <tt class="descclassname">RNG::</tt><tt class="descname">uniform</tt><big>(</big>float <strong>a</strong>, float <strong>b</strong><big>)</big><a class="headerlink" href="#float RNG::uniform(float a, float b)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="double RNG::uniform(double a, double b)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">RNG::</tt><tt class="descname">uniform</tt><big>(</big>double <strong>a</strong>, double <strong>b</strong><big>)</big><a class="headerlink" href="#double RNG::uniform(double a, double b)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; lower inclusive boundary of the returned random numbers.</li>
<li><strong>b</strong> &#8211; upper non-inclusive boundary of the returned random numbers.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods transform the state using the MWC algorithm and return the next uniformly-distributed random number of the specified type, deduced from the input parameter type, from the range <tt class="docutils literal"><span class="pre">[a,</span> <span class="pre">b)</span></tt> . There is a nuance illustrated by the following sample:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">RNG</span> <span class="n">rng</span><span class="p">;</span>

<span class="c1">// always produces 0</span>
<span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">// produces double from [0, 1)</span>
<span class="kt">double</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// produces float from [0, 1)</span>
<span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">1.f</span><span class="p">);</span>

<span class="c1">// produces double from [0, 1)</span>
<span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">);</span>

<span class="c1">// may cause compiler error because of ambiguity:</span>
<span class="c1">//  RNG::uniform(0, (int)0.999999)? or RNG::uniform((double)0, 0.99999)?</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.999999</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler does not take into account the type of the variable to which you assign the result of <tt class="docutils literal"><span class="pre">RNG::uniform</span></tt> . The only thing that matters to the compiler is the type of <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> parameters. So, if you want a floating-point random number, but the range boundaries are integer numbers, either put dots in the end, if they are constants, or use explicit type cast operators, as in the <tt class="docutils literal"><span class="pre">a1</span></tt> initialization above.</p>
</div>
<div class="section" id="rng-gaussian">
<h2>RNG::gaussian<a class="headerlink" href="#rng-gaussian" title="Permalink to this headline">¶</a></h2>
<p>Returns the next random number sampled from the Gaussian distribution.</p>
<dl class="function">
<dt id="double RNG::gaussian(double sigma)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">RNG::</tt><tt class="descname">gaussian</tt><big>(</big>double <strong>sigma</strong><big>)</big><a class="headerlink" href="#double RNG::gaussian(double sigma)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> &#8211; standard deviation of the distribution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method transforms the state using the MWC algorithm and returns the next random number from the Gaussian distribution <tt class="docutils literal"><span class="pre">N(0,sigma)</span></tt> . That is, the mean value of the returned random numbers is zero and the standard deviation is the specified <tt class="docutils literal"><span class="pre">sigma</span></tt> .</p>
</div>
<div class="section" id="rng-fill">
<h2>RNG::fill<a class="headerlink" href="#rng-fill" title="Permalink to this headline">¶</a></h2>
<p>Fills arrays with random numbers.</p>
<dl class="function">
<dt id="void RNG::fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">RNG::</tt><tt class="descname">fill</tt><big>(</big>InputOutputArray <strong>mat</strong>, int <strong>distType</strong>, InputArray <strong>a</strong>, InputArray <strong>b</strong>, bool <strong>saturateRange</strong>=false <big>)</big><a class="headerlink" href="#void RNG::fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; 2D or N-dimensional matrix; currently matrices with more than 4 channels are not supported by the methods, use  <a class="reference internal" href="basic_structures.html#Mat Mat::reshape(int cn, int rows) const" title="Mat Mat::reshape(int cn, int rows) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::reshape()</span></tt></a> as a possible workaround.</li>
<li><strong>distType</strong> &#8211; distribution type, <tt class="docutils literal"><span class="pre">RNG::UNIFORM</span></tt> or <tt class="docutils literal"><span class="pre">RNG::NORMAL</span></tt>.</li>
<li><strong>a</strong> &#8211; first distribution parameter; in case of the uniform distribution, this is an inclusive lower boundary, in case of the normal distribution, this is a mean value.</li>
<li><strong>b</strong> &#8211; second distribution parameter; in case of the uniform distribution, this is a non-inclusive upper boundary, in case of the normal distribution, this is a standard deviation (diagonal of the standard deviation matrix or the full standard deviation matrix).</li>
<li><strong>saturateRange</strong> &#8211; pre-saturation flag; for uniform distribution only; if true, the method will first convert a and b to the acceptable value range (according to the mat datatype) and then will generate uniformly distributed random numbers within the range <tt class="docutils literal"><span class="pre">[saturate(a),</span> <span class="pre">saturate(b))</span></tt>, if <tt class="docutils literal"><span class="pre">saturateRange=false</span></tt>, the method will generate uniformly distributed random numbers in the original range <tt class="docutils literal"><span class="pre">[a,</span> <span class="pre">b)</span></tt> and then will saturate them, it means, for example, that <tt class="docutils literal"><span class="pre">theRNG().fill(mat_8u,</span> <span class="pre">RNG::UNIFORM,</span> <span class="pre">-DBL_MAX,</span> <span class="pre">DBL_MAX)</span></tt> will likely produce array mostly filled with 0&#8217;s and 255&#8217;s, since the range <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">255)</span></tt> is significantly smaller than <tt class="docutils literal"><span class="pre">[-DBL_MAX,</span> <span class="pre">DBL_MAX)</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Each of the methods fills the matrix with the random values from the specified distribution. As the new numbers are generated, the RNG state is updated accordingly. In case of multiple-channel images, every channel is filled independently, which means that RNG cannot generate samples from the multi-dimensional Gaussian distribution with non-diagonal covariance matrix directly. To do that, the method generates samples from multi-dimensional standard Gaussian distribution with zero mean and identity covariation matrix, and then transforms them using <a class="reference internal" href="#void transform(InputArray src, OutputArray dst, InputArray m)" title="void transform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transform()</span></tt></a> to get samples from the specified Gaussian distribution.</p>
</div>
<div class="section" id="randu">
<h2>randu<a class="headerlink" href="#randu" title="Permalink to this headline">¶</a></h2>
<p>Generates a single uniformly-distributed random number or an array of random numbers.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; _Tp randu()">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; _Tp <tt class="descname">randu</tt><big>(</big><big>)</big><a class="headerlink" href="#template<typename _Tp> _Tp randu()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void randu(InputOutputArray dst, InputArray low, InputArray high)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">randu</tt><big>(</big>InputOutputArray <strong>dst</strong>, InputArray <strong>low</strong>, InputArray <strong>high</strong><big>)</big><a class="headerlink" href="#void randu(InputOutputArray dst, InputArray low, InputArray high)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.randu">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">randu</tt><big>(</big>dst, low, high<big>)</big> &rarr; None<a class="headerlink" href="#cv2.randu" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dst</strong> &#8211; output array of random numbers; the array must be pre-allocated.</li>
<li><strong>low</strong> &#8211; inclusive lower boundary of the generated random numbers.</li>
<li><strong>high</strong> &#8211; exclusive upper boundary of the generated random numbers.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The template functions <tt class="docutils literal"><span class="pre">randu</span></tt> generate and return the next uniformly-distributed random value of the specified type. <tt class="docutils literal"><span class="pre">randu&lt;int&gt;()</span></tt> is an equivalent to <tt class="docutils literal"><span class="pre">(int)theRNG();</span></tt> , and so on. See
<a class="reference internal" href="#RNG" title="class RNG"><tt class="xref ocv ocv-class docutils literal"><span class="pre">RNG</span></tt></a> description.</p>
<p>The second non-template variant of the function fills the matrix <tt class="docutils literal"><span class="pre">dst</span></tt> with uniformly-distributed random numbers from the specified range:</p>
<div class="math">
<p><img src="../../../_images/math/5eae4e79ba9e6db20ba9be0d3e8db3fafd2045ab.png" alt="\texttt{low} _c  \leq \texttt{dst} (I)_c &lt;  \texttt{high} _c"/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#RNG" title="class RNG"><tt class="xref ocv ocv-class docutils literal"><span class="pre">RNG</span></tt></a>,
<a class="reference internal" href="#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)" title="void randn(InputOutputArray dst, InputArray mean, InputArray stddev)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randn()</span></tt></a>,
<a class="reference internal" href="#RNG&amp; theRNG()" title="RNG&amp; theRNG()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">theRNG()</span></tt></a></p>
</div>
</div>
<div class="section" id="randn">
<h2>randn<a class="headerlink" href="#randn" title="Permalink to this headline">¶</a></h2>
<p>Fills the array with normally distributed random numbers.</p>
<dl class="function">
<dt id="void randn(InputOutputArray dst, InputArray mean, InputArray stddev)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">randn</tt><big>(</big>InputOutputArray <strong>dst</strong>, InputArray <strong>mean</strong>, InputArray <strong>stddev</strong><big>)</big><a class="headerlink" href="#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.randn">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">randn</tt><big>(</big>dst, mean, stddev<big>)</big> &rarr; None<a class="headerlink" href="#cv2.randn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dst</strong> &#8211; output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</li>
<li><strong>mean</strong> &#8211; mean value (expectation) of the generated random numbers.</li>
<li><strong>stddev</strong> &#8211; standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">randn</span></tt> fills the matrix <tt class="docutils literal"><span class="pre">dst</span></tt> with normally distributed random numbers with the specified mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the value range of the output array data type.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#RNG" title="class RNG"><tt class="xref ocv ocv-class docutils literal"><span class="pre">RNG</span></tt></a>,
<a class="reference internal" href="#template&lt;typename _Tp&gt; _Tp randu()" title="template&lt;typename _Tp&gt; _Tp randu()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randu()</span></tt></a></p>
</div>
</div>
<div class="section" id="randshuffle">
<h2>randShuffle<a class="headerlink" href="#randshuffle" title="Permalink to this headline">¶</a></h2>
<p>Shuffles the array elements randomly.</p>
<dl class="function">
<dt id="void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">randShuffle</tt><big>(</big>InputOutputArray <strong>dst</strong>, double <strong>iterFactor</strong>=1., RNG* <strong>rng</strong>=0 <big>)</big><a class="headerlink" href="#void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.randShuffle">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">randShuffle</tt><big>(</big>dst<span class="optional">[</span>, iterFactor<span class="optional">]</span><big>)</big> &rarr; None<a class="headerlink" href="#cv2.randShuffle" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dst</strong> &#8211; input/output numerical 1D array.</li>
<li><strong>iterFactor</strong> &#8211; scale factor that determines the number of random swap operations (see the details below).</li>
<li><strong>rng</strong> &#8211; optional random number generator used for shuffling; if it is zero, <a class="reference internal" href="#RNG&amp; theRNG()" title="RNG&amp; theRNG()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">theRNG()</span></tt></a> () is used instead.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">randShuffle</span></tt> shuffles the specified 1D array by randomly choosing pairs of elements and swapping them. The number of such swap operations will be <tt class="docutils literal"><span class="pre">dst.rows*dst.cols*iterFactor</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#RNG" title="class RNG"><tt class="xref ocv ocv-class docutils literal"><span class="pre">RNG</span></tt></a>,
<a class="reference internal" href="#void sort(InputArray src, OutputArray dst, int flags)" title="void sort(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sort()</span></tt></a></p>
</div>
</div>
<div class="section" id="reduce">
<h2>reduce<a class="headerlink" href="#reduce" title="Permalink to this headline">¶</a></h2>
<p>Reduces a matrix to a vector.</p>
<dl class="function">
<dt id="void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">reduce</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>dim</strong>, int <strong>rtype</strong>, int <strong>dtype</strong>=-1 <big>)</big><a class="headerlink" href="#void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.reduce">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">reduce</tt><big>(</big>src, dim, rtype<span class="optional">[</span>, dst<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.reduce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvReduce(const CvArr* src, CvArr* dst, int dim, int op)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvReduce</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>dim</strong>=-1, int <strong>op</strong>=CV_REDUCE_SUM<big>)</big><a class="headerlink" href="#void cvReduce(const CvArr* src, CvArr* dst, int dim, int op)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Reduce">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Reduce</tt><big>(</big>src, dst, dim=-1, op=CV_REDUCE_SUM<big>)</big> &rarr; None<a class="headerlink" href="#cv.Reduce" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input 2D matrix.</li>
<li><strong>dst</strong> &#8211; output vector. Its size and type is defined by  <tt class="docutils literal"><span class="pre">dim</span></tt>  and  <tt class="docutils literal"><span class="pre">dtype</span></tt>  parameters.</li>
<li><strong>dim</strong> &#8211; dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column.</li>
<li><strong>rtype</strong> &#8211; <p>reduction operation that could be one of the following:</p>
<ul>
<li><strong>CV_REDUCE_SUM</strong>: the output is the sum of all rows/columns of the matrix.</li>
<li><strong>CV_REDUCE_AVG</strong>: the output is the mean vector of all rows/columns of the matrix.</li>
<li><strong>CV_REDUCE_MAX</strong>: the output is the maximum (column/row-wise) of all rows/columns of the matrix.</li>
<li><strong>CV_REDUCE_MIN</strong>: the output is the minimum (column/row-wise) of all rows/columns of the matrix.</li>
</ul>
</li>
<li><strong>dtype</strong> &#8211; when negative, the output vector will have the same type as the input matrix, otherwise, its type will be <tt class="docutils literal"><span class="pre">CV_MAKE_TYPE(CV_MAT_DEPTH(dtype),</span> <span class="pre">src.channels())</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">reduce</span></tt> reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of <tt class="docutils literal"><span class="pre">CV_REDUCE_SUM</span></tt> and <tt class="docutils literal"><span class="pre">CV_REDUCE_AVG</span></tt> , the output may have a larger element bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction modes.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void repeat(InputArray src, int ny, int nx, OutputArray dst)" title="void repeat(InputArray src, int ny, int nx, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">repeat()</span></tt></a></p>
</div>
</div>
<div class="section" id="repeat">
<h2>repeat<a class="headerlink" href="#repeat" title="Permalink to this headline">¶</a></h2>
<p>Fills the output array with repeated copies of the input array.</p>
<dl class="function">
<dt id="void repeat(InputArray src, int ny, int nx, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">repeat</tt><big>(</big>InputArray <strong>src</strong>, int <strong>ny</strong>, int <strong>nx</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void repeat(InputArray src, int ny, int nx, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat repeat(const Mat&amp; src, int ny, int nx)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">repeat</tt><big>(</big>const Mat&amp; <strong>src</strong>, int <strong>ny</strong>, int <strong>nx</strong><big>)</big><a class="headerlink" href="#Mat repeat(const Mat& src, int ny, int nx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.repeat">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">repeat</tt><big>(</big>src, ny, nx<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.repeat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvRepeat(const CvArr* src, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvRepeat</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvRepeat(const CvArr* src, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Repeat">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Repeat</tt><big>(</big>src, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Repeat" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array to replicate.</li>
<li><strong>dst</strong> &#8211; output array of the same type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ny</strong> &#8211; Flag to specify how many times the <tt class="docutils literal"><span class="pre">src</span></tt> is repeated along the vertical axis.</li>
<li><strong>nx</strong> &#8211; Flag to specify how many times the <tt class="docutils literal"><span class="pre">src</span></tt> is repeated along the horizontal axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions
<a class="reference internal" href="#void repeat(InputArray src, int ny, int nx, OutputArray dst)" title="void repeat(InputArray src, int ny, int nx, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">repeat()</span></tt></a> duplicate the input array one or more times along each of the two axes:</p>
<div class="math">
<p><img src="../../../_images/math/8eabf49654250fe67873315f9f47b2c5f89e18d0.png" alt="\texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols }"/></p>
</div><p>The second variant of the function is more convenient to use with
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)" title="void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">reduce()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="scaleadd">
<h2>scaleAdd<a class="headerlink" href="#scaleadd" title="Permalink to this headline">¶</a></h2>
<p>Calculates the sum of a scaled array and another array.</p>
<dl class="function">
<dt id="void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">scaleAdd</tt><big>(</big>InputArray <strong>src1</strong>, double <strong>alpha</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.scaleAdd">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">scaleAdd</tt><big>(</big>src1, alpha, src2<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.scaleAdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvScaleAdd(const CvArr* src1, CvScalar scale, const CvArr* src2, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvScaleAdd</tt><big>(</big>const CvArr* <strong>src1</strong>, CvScalar <strong>scale</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvScaleAdd(const CvArr* src1, CvScalar scale, const CvArr* src2, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ScaleAdd">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">ScaleAdd</tt><big>(</big>src1, scale, src2, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.ScaleAdd" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array.</li>
<li><strong>scale</strong> &#8211; scale factor for the first array.</li>
<li><strong>src2</strong> &#8211; second input array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src1</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">scaleAdd</span></tt> is one of the classical primitive linear algebra operations, known as <tt class="docutils literal"><span class="pre">DAXPY</span></tt> or <tt class="docutils literal"><span class="pre">SAXPY</span></tt> in <a class="reference external" href="http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a>. It calculates the sum of a scaled array and another array:</p>
<div class="math">
<p><img src="../../../_images/math/781c2eec8b03d6d6d11dc21a831d3ecff4445b7d.png" alt="\texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I)"/></p>
</div><p>The function can also be emulated with a matrix expression, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../contrib/doc/openfabmap.html#virtual void add(const Mat&amp; queryImgDescriptor)" title="virtual void add(const Mat&amp; queryImgDescriptor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">add()</span></tt></a>,
<a class="reference internal" href="#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)" title="void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">addWeighted()</span></tt></a>,
<a class="reference internal" href="#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">subtract()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#double Mat::dot(InputArray m) const" title="double Mat::dot(InputArray m) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::dot()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="setidentity">
<h2>setIdentity<a class="headerlink" href="#setidentity" title="Permalink to this headline">¶</a></h2>
<p>Initializes a scaled identity matrix.</p>
<dl class="function">
<dt id="void setIdentity(InputOutputArray mtx, const Scalar&amp; s)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">setIdentity</tt><big>(</big>InputOutputArray <strong>mtx</strong>, const Scalar&amp; <strong>s</strong>=Scalar(1) <big>)</big><a class="headerlink" href="#void setIdentity(InputOutputArray mtx, const Scalar& s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.setIdentity">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">setIdentity</tt><big>(</big>mtx<span class="optional">[</span>, s<span class="optional">]</span><big>)</big> &rarr; None<a class="headerlink" href="#cv2.setIdentity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSetIdentity(CvArr* mat, CvScalar value)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSetIdentity</tt><big>(</big>CvArr* <strong>mat</strong>, CvScalar <strong>value</strong>=cvRealScalar(1)<big>)</big><a class="headerlink" href="#void cvSetIdentity(CvArr* mat, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetIdentity">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">SetIdentity</tt><big>(</big>mat, value=1<big>)</big> &rarr; None<a class="headerlink" href="#cv.SetIdentity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mtx</strong> &#8211; matrix to initialize (not necessarily square).</li>
<li><strong>value</strong> &#8211; value to assign to diagonal elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function
<a class="reference internal" href="#void setIdentity(InputOutputArray mtx, const Scalar&amp; s)" title="void setIdentity(InputOutputArray mtx, const Scalar&amp; s)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">setIdentity()</span></tt></a> initializes a scaled identity matrix:</p>
<div class="math">
<p><img src="../../../_images/math/af69dbca6dacb8932efafceef3b7f24e36f56f89.png" alt="\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if $i=j$}{0}{otherwise}"/></p>
</div><p>The function can also be emulated using the matrix initializers and the matrix expressions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="p">;</span>
<span class="c1">// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#static MatExpr Mat::zeros(int rows, int cols, int type)" title="static MatExpr Mat::zeros(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::zeros()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#static MatExpr Mat::ones(int rows, int cols, int type)" title="static MatExpr Mat::ones(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::ones()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a>,
<a class="reference internal" href="basic_structures.html#Mat&amp; Mat::setTo(InputArray value, InputArray mask)" title="Mat&amp; Mat::setTo(InputArray value, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::setTo()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#Mat&amp; Mat::operator = (const Mat&amp; m)" title="Mat&amp; Mat::operator = (const Mat&amp; m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::operator=()</span></tt></a></p>
</div>
</div>
<div class="section" id="solve">
<h2>solve<a class="headerlink" href="#solve" title="Permalink to this headline">¶</a></h2>
<p>Solves one or more linear systems or least-squares problems.</p>
<dl class="function">
<dt id="bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descname">solve</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong>=DECOMP_LU<big>)</big><a class="headerlink" href="#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.solve">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">solve</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval, dst<a class="headerlink" href="#cv2.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvSolve(const CvArr* src1, const CvArr* src2, CvArr* dst, int method)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvSolve</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, int <strong>method</strong>=CV_LU<big>)</big><a class="headerlink" href="#int cvSolve(const CvArr* src1, const CvArr* src2, CvArr* dst, int method)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Solve">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Solve</tt><big>(</big>A, B, X, method=CV_LU<big>)</big> &rarr; None<a class="headerlink" href="#cv.Solve" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; input matrix on the left-hand side of the system.</li>
<li><strong>src2</strong> &#8211; input matrix on the right-hand side of the system.</li>
<li><strong>dst</strong> &#8211; output solution.</li>
<li><strong>flags</strong> &#8211; <p>solution (matrix inversion) method.</p>
<ul>
<li><strong>DECOMP_LU</strong> Gaussian elimination with optimal pivot element chosen.</li>
<li><strong>DECOMP_CHOLESKY</strong> Cholesky  <img class="math" src="../../../_images/math/c61e6a88063a03d6d07f462f7d73abcb49207dad.png" alt="LL^T"/>  factorization; the matrix <tt class="docutils literal"><span class="pre">src1</span></tt> must be symmetrical and positively defined.</li>
<li><strong>DECOMP_EIG</strong> eigenvalue decomposition; the matrix <tt class="docutils literal"><span class="pre">src1</span></tt> must be symmetrical.</li>
<li><strong>DECOMP_SVD</strong> singular value decomposition (SVD) method; the system can be over-defined and/or the matrix <tt class="docutils literal"><span class="pre">src1</span></tt> can be singular.</li>
<li><strong>DECOMP_QR</strong> QR factorization; the system can be over-defined and/or the matrix <tt class="docutils literal"><span class="pre">src1</span></tt> can be singular.</li>
<li><strong>DECOMP_NORMAL</strong> while all the previous flags are mutually exclusive, this flag can be used together with any of the previous; it means that the normal equations  <img class="math" src="../../../_images/math/5b33935d61ed8328773a0682d6552491f28f3ecf.png" alt="\texttt{src1}^T\cdot\texttt{src1}\cdot\texttt{dst}=\texttt{src1}^T\texttt{src2}"/>  are solved instead of the original system  <img class="math" src="../../../_images/math/bc7ef425d9e73f4b4a522bf2a493140185e309fe.png" alt="\texttt{src1}\cdot\texttt{dst}=\texttt{src2}"/> .</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">solve</span></tt> solves a linear system or least-squares problem (the latter is possible with SVD or QR methods, or by specifying the flag <tt class="docutils literal"><span class="pre">DECOMP_NORMAL</span></tt> ):</p>
<div class="math">
<p><img src="../../../_images/math/9beda9771ef91677bbe80af6dfe3b3abe8752c4e.png" alt="\texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \|"/></p>
</div><p>If <tt class="docutils literal"><span class="pre">DECOMP_LU</span></tt> or <tt class="docutils literal"><span class="pre">DECOMP_CHOLESKY</span></tt> method is used, the function returns 1 if <tt class="docutils literal"><span class="pre">src1</span></tt> (or
<img class="math" src="../../../_images/math/85aec13285f669baf56f12c10f6a4cdcdf5e79fe.png" alt="\texttt{src1}^T\texttt{src1}"/> ) is non-singular. Otherwise, it returns 0. In the latter case, <tt class="docutils literal"><span class="pre">dst</span></tt> is not valid. Other methods find a pseudo-solution in case of a singular left-hand side part.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want to find a unity-norm solution of an under-defined singular system <img class="math" src="../../../_images/math/2743ac4626c7c7326fe7200b0739189d5e8e4ea5.png" alt="\texttt{src1}\cdot\texttt{dst}=0"/> , the function <tt class="docutils literal"><span class="pre">solve</span></tt> will not do the work. Use <a class="reference internal" href="#static void SVD::solveZ(InputArray src, OutputArray dst)" title="static void SVD::solveZ(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">SVD::solveZ()</span></tt></a> instead.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#double invert(InputArray src, OutputArray dst, int flags)" title="double invert(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">invert()</span></tt></a>,
<a class="reference internal" href="#SVD" title="class SVD"><tt class="xref ocv ocv-class docutils literal"><span class="pre">SVD</span></tt></a>,
<a class="reference internal" href="#bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)" title="bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">eigen()</span></tt></a></p>
</div>
</div>
<div class="section" id="solvecubic">
<h2>solveCubic<a class="headerlink" href="#solvecubic" title="Permalink to this headline">¶</a></h2>
<p>Finds the real roots of a cubic equation.</p>
<dl class="function">
<dt id="int solveCubic(InputArray coeffs, OutputArray roots)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">solveCubic</tt><big>(</big>InputArray <strong>coeffs</strong>, OutputArray <strong>roots</strong><big>)</big><a class="headerlink" href="#int solveCubic(InputArray coeffs, OutputArray roots)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.solveCubic">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">solveCubic</tt><big>(</big>coeffs<span class="optional">[</span>, roots<span class="optional">]</span><big>)</big> &rarr; retval, roots<a class="headerlink" href="#cv2.solveCubic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvSolveCubic(const CvMat* coeffs, CvMat* roots)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvSolveCubic</tt><big>(</big>const CvMat* <strong>coeffs</strong>, CvMat* <strong>roots</strong><big>)</big><a class="headerlink" href="#int cvSolveCubic(const CvMat* coeffs, CvMat* roots)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SolveCubic">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">SolveCubic</tt><big>(</big>coeffs, roots<big>)</big> &rarr; None<a class="headerlink" href="#cv.SolveCubic" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coeffs</strong> &#8211; equation coefficients, an array of 3 or 4 elements.</li>
<li><strong>roots</strong> &#8211; output array of real roots that has 1 or 3 elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">solveCubic</span></tt> finds the real roots of a cubic equation:</p>
<ul class="simple">
<li>if <tt class="docutils literal"><span class="pre">coeffs</span></tt> is a 4-element vector:</li>
</ul>
<div class="math">
<p><img src="../../../_images/math/fe7795e1b29e8f68c0ede218705289b0674bba6b.png" alt="\texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0"/></p>
</div><ul class="simple">
<li>if <tt class="docutils literal"><span class="pre">coeffs</span></tt> is a 3-element vector:</li>
</ul>
<div class="math">
<p><img src="../../../_images/math/ba956f7c22249ea7674f92cbab534fde659bd964.png" alt="x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0"/></p>
</div><p>The roots are stored in the <tt class="docutils literal"><span class="pre">roots</span></tt> array.</p>
</div>
<div class="section" id="solvepoly">
<h2>solvePoly<a class="headerlink" href="#solvepoly" title="Permalink to this headline">¶</a></h2>
<p>Finds the real or complex roots of a polynomial equation.</p>
<dl class="function">
<dt id="double solvePoly(InputArray coeffs, OutputArray roots, int maxIters)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">solvePoly</tt><big>(</big>InputArray <strong>coeffs</strong>, OutputArray <strong>roots</strong>, int <strong>maxIters</strong>=300 <big>)</big><a class="headerlink" href="#double solvePoly(InputArray coeffs, OutputArray roots, int maxIters)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.solvePoly">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">solvePoly</tt><big>(</big>coeffs<span class="optional">[</span>, roots<span class="optional">[</span>, maxIters<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; retval, roots<a class="headerlink" href="#cv2.solvePoly" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coeffs</strong> &#8211; array of polynomial coefficients.</li>
<li><strong>roots</strong> &#8211; output (complex) array of roots.</li>
<li><strong>maxIters</strong> &#8211; maximum number of iterations the algorithm does.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">solvePoly</span></tt> finds real and complex roots of a polynomial equation:</p>
<div class="math">
<p><img src="../../../_images/math/5d02f7d1de4a1f03b663cb678504ef80de18f62d.png" alt="\texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0"/></p>
</div></div>
<div class="section" id="sort">
<h2>sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h2>
<p>Sorts each row or each column of a matrix.</p>
<dl class="function">
<dt id="void sort(InputArray src, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">sort</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void sort(InputArray src, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.sort">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">sort</tt><big>(</big>src, flags<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.sort" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input single-channel array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>flags</strong> &#8211; <p>operation flags, a combination of the following values:</p>
<ul>
<li><strong>CV_SORT_EVERY_ROW</strong> each matrix row is sorted independently.</li>
<li><strong>CV_SORT_EVERY_COLUMN</strong> each matrix column is sorted independently; this flag and the previous one are mutually exclusive.</li>
<li><strong>CV_SORT_ASCENDING</strong> each matrix row is sorted in the ascending order.</li>
<li><strong>CV_SORT_DESCENDING</strong> each matrix row is sorted in the descending order; this flag and the previous one are also mutually exclusive.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">sort</span></tt> sorts each matrix row or each matrix column in ascending or descending order. So you should pass two operation flags to get desired behaviour. If you want to sort matrix rows or columns lexicographically, you can use STL <tt class="docutils literal"><span class="pre">std::sort</span></tt> generic function with the proper comparison predicate.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sortIdx(InputArray src, OutputArray dst, int flags)" title="void sortIdx(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sortIdx()</span></tt></a>,
<a class="reference internal" href="#void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)" title="void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randShuffle()</span></tt></a></p>
</div>
</div>
<div class="section" id="sortidx">
<h2>sortIdx<a class="headerlink" href="#sortidx" title="Permalink to this headline">¶</a></h2>
<p>Sorts each row or each column of a matrix.</p>
<dl class="function">
<dt id="void sortIdx(InputArray src, OutputArray dst, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">sortIdx</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void sortIdx(InputArray src, OutputArray dst, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.sortIdx">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">sortIdx</tt><big>(</big>src, flags<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.sortIdx" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input single-channel array.</li>
<li><strong>dst</strong> &#8211; output integer array of the same size as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>flags</strong> &#8211; <p>operation flags that could be a combination of the following values:</p>
<ul>
<li><strong>CV_SORT_EVERY_ROW</strong> each matrix row is sorted independently.</li>
<li><strong>CV_SORT_EVERY_COLUMN</strong> each matrix column is sorted independently; this flag and the previous one are mutually exclusive.</li>
<li><strong>CV_SORT_ASCENDING</strong> each matrix row is sorted in the ascending order.</li>
<li><strong>CV_SORT_DESCENDING</strong> each matrix row is sorted in the descending order; his flag and the previous one are also mutually exclusive.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">sortIdx</span></tt> sorts each matrix row or each matrix column in the ascending or descending order. So you should pass two operation flags to get desired behaviour. Instead of reordering the elements themselves, it stores the indices of sorted elements in the output array. For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">),</span> <span class="n">B</span><span class="p">;</span>
<span class="n">sortIdx</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">CV_SORT_EVERY_ROW</span> <span class="o">+</span> <span class="n">CV_SORT_ASCENDING</span><span class="p">);</span>
<span class="c1">// B will probably contain</span>
<span class="c1">// (because of equal elements in A some permutations are possible):</span>
<span class="c1">// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sort(InputArray src, OutputArray dst, int flags)" title="void sort(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sort()</span></tt></a>,
<a class="reference internal" href="#void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)" title="void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randShuffle()</span></tt></a></p>
</div>
</div>
<div class="section" id="split">
<h2>split<a class="headerlink" href="#split" title="Permalink to this headline">¶</a></h2>
<p>Divides a multi-channel array into several single-channel arrays.</p>
<dl class="function">
<dt id="void split(const Mat&amp; src, Mat* mvbegin)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">split</tt><big>(</big>const Mat&amp; <strong>src</strong>, Mat* <strong>mvbegin</strong><big>)</big><a class="headerlink" href="#void split(const Mat& src, Mat* mvbegin)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void split(InputArray m, OutputArrayOfArrays mv)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">split</tt><big>(</big>InputArray <strong>m</strong>, OutputArrayOfArrays <strong>mv</strong><big>)</big><a class="headerlink" href="#void split(InputArray m, OutputArrayOfArrays mv)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.split">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">split</tt><big>(</big>m<span class="optional">[</span>, mv<span class="optional">]</span><big>)</big> &rarr; mv<a class="headerlink" href="#cv2.split" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSplit</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst0</strong>, CvArr* <strong>dst1</strong>, CvArr* <strong>dst2</strong>, CvArr* <strong>dst3</strong><big>)</big><a class="headerlink" href="#void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Split">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Split</tt><big>(</big>src, dst0, dst1, dst2, dst3<big>)</big> &rarr; None<a class="headerlink" href="#cv.Split" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input multi-channel array.</li>
<li><strong>mv</strong> &#8211; output array or vector of arrays; in the first variant of the function the number of arrays must match <tt class="docutils literal"><span class="pre">src.channels()</span></tt>; the arrays themselves are reallocated, if needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">split</span></tt> split a multi-channel array into separate single-channel arrays:</p>
<div class="math">
<p><img src="../../../_images/math/364c991f8df83d303240d757f0827ae68cc9394d.png" alt="\texttt{mv} [c](I) =  \texttt{src} (I)_c"/></p>
</div><p>If you need to extract a single channel or do some other sophisticated channel permutation, use
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void merge(const Mat* mv, size_t count, OutputArray dst)" title="void merge(const Mat* mv, size_t count, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">merge()</span></tt></a>,
<a class="reference internal" href="#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/miscellaneous_transformations.html#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)" title="void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cvtColor()</span></tt></a></p>
</div>
</div>
<div class="section" id="sqrt">
<h2>sqrt<a class="headerlink" href="#sqrt" title="Permalink to this headline">¶</a></h2>
<p>Calculates a square root of array elements.</p>
<dl class="function">
<dt id="void sqrt(InputArray src, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">sqrt</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void sqrt(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.sqrt">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">sqrt</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.sqrt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="float cvSqrt(float value)">
<strong>C:</strong><tt class="descname"> </tt>float <tt class="descname">cvSqrt</tt><big>(</big>float <strong>value</strong><big>)</big><a class="headerlink" href="#float cvSqrt(float value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Sqrt">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Sqrt</tt><big>(</big>value<big>)</big> &rarr; float<a class="headerlink" href="#cv.Sqrt" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input floating-point array.</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">sqrt</span></tt> calculate a square root of each input array element. In case of multi-channel arrays, each channel is processed independently. The accuracy is approximately the same as of the built-in <tt class="docutils literal"><span class="pre">std::sqrt</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void pow(InputArray src, double power, OutputArray dst)" title="void pow(InputArray src, double power, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pow()</span></tt></a>,
<a class="reference internal" href="#void magnitude(InputArray x, InputArray y, OutputArray magnitude)" title="void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">magnitude()</span></tt></a></p>
</div>
</div>
<div class="section" id="subtract">
<h2>subtract<a class="headerlink" href="#subtract" title="Permalink to this headline">¶</a></h2>
<p>Calculates the per-element difference between two arrays or array and a scalar.</p>
<dl class="function">
<dt id="void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">subtract</tt><big>(</big>InputArray <strong>src1</strong>, InputArray <strong>src2</strong>, OutputArray <strong>dst</strong>, InputArray <strong>mask</strong>=noArray(), int <strong>dtype</strong>=-1<big>)</big><a class="headerlink" href="#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.subtract">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">subtract</tt><big>(</big>src1, src2<span class="optional">[</span>, dst<span class="optional">[</span>, mask<span class="optional">[</span>, dtype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.subtract" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSub(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSub</tt><big>(</big>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<big>)</big><a class="headerlink" href="#void cvSub(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSubRS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSubRS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>value</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL <big>)</big><a class="headerlink" href="#void cvSubRS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSubS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSubS</tt><big>(</big>const CvArr* <strong>src</strong>, CvScalar <strong>value</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL <big>)</big><a class="headerlink" href="#void cvSubS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Sub">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Sub</tt><big>(</big>src1, src2, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.Sub" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SubRS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">SubRS</tt><big>(</big>src, value, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.SubRS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SubS">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">SubS</tt><big>(</big>src, value, dst, mask=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.SubS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; first input array or a scalar.</li>
<li><strong>src2</strong> &#8211; second input array or a scalar.</li>
<li><strong>dst</strong> &#8211; output array of the same size and the same number of channels as the input array.</li>
<li><strong>mask</strong> &#8211; optional operation mask; this is an 8-bit single channel array that specifies elements of the output array to be changed.</li>
<li><strong>dtype</strong> &#8211; optional depth of the output array (see the details below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">subtract</span></tt> calculates:</p>
<blockquote>
<div><ul>
<li><p class="first">Difference between two arrays, when both input arrays have the same size and the same number of channels:</p>
<div class="math">
<p><img src="../../../_images/math/b3e699a07882eee938e512e061d2022a4519c84f.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0"/></p>
</div></li>
<li><p class="first">Difference between an array and a scalar, when <tt class="docutils literal"><span class="pre">src2</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src1.channels()</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/d311640a88f263be7997331a782bcde74c0b34d7.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0"/></p>
</div></li>
<li><p class="first">Difference between a scalar and an array, when <tt class="docutils literal"><span class="pre">src1</span></tt> is constructed from <tt class="docutils literal"><span class="pre">Scalar</span></tt> or has the same number of elements as <tt class="docutils literal"><span class="pre">src2.channels()</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/ed57a918454a133b1d9fe5a6db34de4d0f7e9d0b.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0"/></p>
</div></li>
<li><p class="first">The reverse difference between a scalar and an array in the case of <tt class="docutils literal"><span class="pre">SubRS</span></tt>:</p>
<div class="math">
<p><img src="../../../_images/math/9c5d7e69ad330ce31c2c9fe02d93c8a6e252a547.png" alt="\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0"/></p>
</div></li>
</ul>
</div></blockquote>
<p>where <tt class="docutils literal"><span class="pre">I</span></tt> is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.</p>
<p>The first function in the list above can be replaced with matrix expressions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">dst</span> <span class="o">=</span> <span class="n">src1</span> <span class="o">-</span> <span class="n">src2</span><span class="p">;</span>
<span class="n">dst</span> <span class="o">-=</span> <span class="n">src1</span><span class="p">;</span> <span class="c1">// equivalent to subtract(dst, src1, dst);</span>
</pre></div>
</div>
<p>The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by <tt class="docutils literal"><span class="pre">dtype</span></tt> parameter. In the second and third cases above, as well as in the first case, when <tt class="docutils literal"><span class="pre">src1.depth()</span> <span class="pre">==</span> <span class="pre">src2.depth()</span></tt>, <tt class="docutils literal"><span class="pre">dtype</span></tt> can be set to the default <tt class="docutils literal"><span class="pre">-1</span></tt>. In this case the output array will have the same depth as the input array, be it <tt class="docutils literal"><span class="pre">src1</span></tt>, <tt class="docutils literal"><span class="pre">src2</span></tt> or both.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saturation is not applied when the output array has the depth <tt class="docutils literal"><span class="pre">CV_32S</span></tt>. You may even get result of an incorrect sign in the case of overflow.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../contrib/doc/openfabmap.html#virtual void add(const Mat&amp; queryImgDescriptor)" title="virtual void add(const Mat&amp; queryImgDescriptor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">add()</span></tt></a>,
<a class="reference internal" href="#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)" title="void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">addWeighted()</span></tt></a>,
<a class="reference internal" href="#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)" title="void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">scaleAdd()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::convertTo()</span></tt></a>,
<a class="reference internal" href="basic_structures.html#matrixexpressions"><em>Matrix Expressions</em></a></p>
</div>
</div>
<div class="section" id="svd">
<h2>SVD<a class="headerlink" href="#svd" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SVD">
<em class="property">class </em><tt class="descname">SVD</tt><a class="headerlink" href="#SVD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class for computing Singular Value Decomposition of a floating-point matrix. The Singular Value Decomposition is used to solve least-square problems, under-determined linear systems, invert matrices, compute condition numbers, and so on.</p>
<p>For a faster operation, you can pass <tt class="docutils literal"><span class="pre">flags=SVD::MODIFY_A|...</span></tt> to modify the decomposed matrix when it is not necessary to preserve it. If you want to compute a condition number of a matrix or an absolute value of its determinant, you do not need <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> . You can pass <tt class="docutils literal"><span class="pre">flags=SVD::NO_UV|...</span></tt> . Another flag <tt class="docutils literal"><span class="pre">FULL_UV</span></tt> indicates that full-size <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> must be computed, which is not necessary most of the time.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#double invert(InputArray src, OutputArray dst, int flags)" title="double invert(InputArray src, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">invert()</span></tt></a>,
<a class="reference internal" href="#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)" title="bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">solve()</span></tt></a>,
<a class="reference internal" href="#bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)" title="bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">eigen()</span></tt></a>,
<a class="reference internal" href="#double determinant(InputArray mtx)" title="double determinant(InputArray mtx)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">determinant()</span></tt></a></p>
</div>
</div>
<div class="section" id="svd-svd">
<h2>SVD::SVD<a class="headerlink" href="#svd-svd" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="SVD::SVD()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SVD::</tt><tt class="descname">SVD</tt><big>(</big><big>)</big><a class="headerlink" href="#SVD::SVD()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SVD::SVD(InputArray src, int flags)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SVD::</tt><tt class="descname">SVD</tt><big>(</big>InputArray <strong>src</strong>, int <strong>flags</strong>=0 <big>)</big><a class="headerlink" href="#SVD::SVD(InputArray src, int flags)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; decomposed matrix.</li>
<li><strong>flags</strong> &#8211; <p>operation flags.</p>
<ul>
<li><strong>SVD::MODIFY_A</strong> use the algorithm to modify the decomposed matrix; it can save space and speed up processing.</li>
<li><strong>SVD::NO_UV</strong> indicates that only a vector of singular values <tt class="docutils literal"><span class="pre">w</span></tt> is to be processed, while <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> will be set to empty matrices.</li>
<li><strong>SVD::FULL_UV</strong> when the matrix is not square, by default the algorithm produces <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> matrices of sufficiently large size for the further <tt class="docutils literal"><span class="pre">A</span></tt> reconstruction; if, however,   <tt class="docutils literal"><span class="pre">FULL_UV</span></tt> flag is specified, <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> will be full-size square orthogonal matrices.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The first constructor initializes an empty <tt class="docutils literal"><span class="pre">SVD</span></tt> structure. The second constructor initializes an empty <tt class="docutils literal"><span class="pre">SVD</span></tt> structure and then calls
<a class="reference internal" href="#SVD&amp; SVD::operator()(InputArray src, int flags)" title="SVD&amp; SVD::operator()(InputArray src, int flags)"><tt class="xref ocv ocv-funcx docutils literal"><span class="pre">SVD::operator()</span></tt></a> .</p>
</div>
<div class="section" id="svd-operator">
<h2>SVD::operator ()<a class="headerlink" href="#svd-operator" title="Permalink to this headline">¶</a></h2>
<p>Performs SVD of a matrix.</p>
<dl class="function">
<dt id="SVD&amp; SVD::operator()(InputArray src, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>SVD&amp; <tt class="descclassname">SVD::</tt><tt class="descname">operator()</tt><big>(</big>InputArray <strong>src</strong>, int <strong>flags</strong>=0 <big>)</big><a class="headerlink" href="#SVD& SVD::operator()(InputArray src, int flags)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; decomposed matrix.</li>
<li><strong>flags</strong> &#8211; <p>operation flags.</p>
<ul>
<li><strong>SVD::MODIFY_A</strong> use the algorithm to modify the decomposed matrix; it can save space and speed up processing.</li>
<li><strong>SVD::NO_UV</strong> use only singular values; the algorithm does not compute <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> matrices.</li>
<li><strong>SVD::FULL_UV</strong> when the matrix is not square, by default the algorithm produces <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">vt</span></tt> matrices of sufficiently large size for the further <tt class="docutils literal"><span class="pre">A</span></tt> reconstruction; if, however, the <tt class="docutils literal"><span class="pre">FULL_UV</span></tt>  flag is specified, <tt class="docutils literal"><span class="pre">u</span></tt>  and  <tt class="docutils literal"><span class="pre">vt</span></tt>  are full-size square orthogonal matrices.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The operator performs the singular value decomposition of the supplied matrix. The <tt class="docutils literal"><span class="pre">u</span></tt>,``vt`` , and the vector of singular values <tt class="docutils literal"><span class="pre">w</span></tt> are stored in the structure. The same <tt class="docutils literal"><span class="pre">SVD</span></tt> structure can be reused many times with different matrices. Each time, if needed, the previous <tt class="docutils literal"><span class="pre">u</span></tt>,``vt`` , and <tt class="docutils literal"><span class="pre">w</span></tt> are reclaimed and the new matrices are created, which is all handled by
<a class="reference internal" href="basic_structures.html#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></tt></a> .</p>
</div>
<div class="section" id="svd-compute">
<h2>SVD::compute<a class="headerlink" href="#svd-compute" title="Permalink to this headline">¶</a></h2>
<p>Performs SVD of a matrix</p>
<dl class="function">
<dt id="static void SVD::compute(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> void <tt class="descclassname">SVD::</tt><tt class="descname">compute</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>w</strong>, OutputArray <strong>u</strong>, OutputArray <strong>vt</strong>, int <strong>flags</strong>=0 <big>)</big><a class="headerlink" href="#static void SVD::compute(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static void SVD::compute(InputArray src, OutputArray w, int flags)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> void <tt class="descclassname">SVD::</tt><tt class="descname">compute</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>w</strong>, int <strong>flags</strong>=0 <big>)</big><a class="headerlink" href="#static void SVD::compute(InputArray src, OutputArray w, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.SVDecomp">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">SVDecomp</tt><big>(</big>src<span class="optional">[</span>, w<span class="optional">[</span>, u<span class="optional">[</span>, vt<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; w, u, vt<a class="headerlink" href="#cv2.SVDecomp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSVD(CvArr* A, CvArr* W, CvArr* U, CvArr* V, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSVD</tt><big>(</big>CvArr* <strong>A</strong>, CvArr* <strong>W</strong>, CvArr* <strong>U</strong>=NULL, CvArr* <strong>V</strong>=NULL, int <strong>flags</strong>=0 <big>)</big><a class="headerlink" href="#void cvSVD(CvArr* A, CvArr* W, CvArr* U, CvArr* V, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SVD">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">SVD</tt><big>(</big>A, W, U=None, V=None, flags=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.SVD" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; decomposed matrix</li>
<li><strong>w</strong> &#8211; calculated singular values</li>
<li><strong>u</strong> &#8211; calculated left singular vectors</li>
<li><strong>V</strong> &#8211; calculated right singular vectors</li>
<li><strong>vt</strong> &#8211; transposed matrix of right singular values</li>
<li><strong>flags</strong> &#8211; operation flags - see <a class="reference internal" href="#SVD::SVD()" title="SVD::SVD()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">SVD::SVD()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods/functions perform SVD of matrix. Unlike <tt class="docutils literal"><span class="pre">SVD::SVD</span></tt> constructor and <tt class="docutils literal"><span class="pre">SVD::operator()</span></tt>, they store the results to the user-provided matrices.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">vt</span><span class="p">;</span>
<span class="n">SVD</span><span class="o">::</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">vt</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="svd-solvez">
<h2>SVD::solveZ<a class="headerlink" href="#svd-solvez" title="Permalink to this headline">¶</a></h2>
<p>Solves an under-determined singular linear system.</p>
<dl class="function">
<dt id="static void SVD::solveZ(InputArray src, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> void <tt class="descclassname">SVD::</tt><tt class="descname">solveZ</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#static void SVD::solveZ(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; left-hand-side matrix.</li>
<li><strong>dst</strong> &#8211; found solution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method finds a unit-length solution <tt class="docutils literal"><span class="pre">x</span></tt> of a singular linear system
<tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">0</span></tt>. Depending on the rank of <tt class="docutils literal"><span class="pre">A</span></tt>, there can be no solutions, a single solution or an infinite number of solutions. In general, the algorithm solves the following problem:</p>
<div class="math">
<p><img src="../../../_images/math/3731361bf2f2e817143287c09dfd3cea2f54e5bb.png" alt="dst =  \arg \min _{x:  \| x \| =1}  \| src  \cdot x  \|"/></p>
</div></div>
<div class="section" id="svd-backsubst">
<h2>SVD::backSubst<a class="headerlink" href="#svd-backsubst" title="Permalink to this headline">¶</a></h2>
<p>Performs a singular value back substitution.</p>
<dl class="function">
<dt id="void SVD::backSubst(InputArray rhs, OutputArray dst) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SVD::</tt><tt class="descname">backSubst</tt><big>(</big>InputArray <strong>rhs</strong>, OutputArray <strong>dst</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void SVD::backSubst(InputArray rhs, OutputArray dst) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static void SVD::backSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> void <tt class="descclassname">SVD::</tt><tt class="descname">backSubst</tt><big>(</big>InputArray <strong>w</strong>, InputArray <strong>u</strong>, InputArray <strong>vt</strong>, InputArray <strong>rhs</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#static void SVD::backSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.SVBackSubst">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">SVBackSubst</tt><big>(</big>w, u, vt, rhs<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.SVBackSubst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSVBkSb(const CvArr* W, const CvArr* U, const CvArr* V, const CvArr* B, CvArr* X, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSVBkSb</tt><big>(</big>const CvArr* <strong>W</strong>, const CvArr* <strong>U</strong>, const CvArr* <strong>V</strong>, const CvArr* <strong>B</strong>, CvArr* <strong>X</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void cvSVBkSb(const CvArr* W, const CvArr* U, const CvArr* V, const CvArr* B, CvArr* X, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SVBkSb">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">SVBkSb</tt><big>(</big>W, U, V, B, X, flags<big>)</big> &rarr; None<a class="headerlink" href="#cv.SVBkSb" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> &#8211; singular values</li>
<li><strong>u</strong> &#8211; left singular vectors</li>
<li><strong>V</strong> &#8211; right singular vectors</li>
<li><strong>vt</strong> &#8211; transposed matrix of right singular vectors.</li>
<li><strong>rhs</strong> &#8211; right-hand side of a linear system <tt class="docutils literal"><span class="pre">(u*w*v')*dst</span> <span class="pre">=</span> <span class="pre">rhs</span></tt> to be solved, where <tt class="docutils literal"><span class="pre">A</span></tt> has been previously decomposed.</li>
<li><strong>dst</strong> &#8211; found solution of the system.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method calculates a back substitution for the specified right-hand side:</p>
<div class="math">
<p><img src="../../../_images/math/87b45339c250c52e5d7679d61da83ea183b75b22.png" alt="\texttt{x} =  \texttt{vt} ^T  \cdot diag( \texttt{w} )^{-1}  \cdot \texttt{u} ^T  \cdot \texttt{rhs} \sim \texttt{A} ^{-1}  \cdot \texttt{rhs}"/></p>
</div><p>Using this technique you can either get a very accurate solution of the convenient linear system, or the best (in the least-squares terms) pseudo-solution of an overdetermined linear system.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Explicit SVD with the further back substitution only makes sense if you need to solve many linear systems with the same left-hand side (for example, <tt class="docutils literal"><span class="pre">src</span></tt> ). If all you need is to solve a single system (possibly with multiple <tt class="docutils literal"><span class="pre">rhs</span></tt> immediately available), simply call <a class="reference internal" href="#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)" title="bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">solve()</span></tt></a> add pass <tt class="docutils literal"><span class="pre">DECOMP_SVD</span></tt> there. It does absolutely the same thing.</p>
</div>
</div>
<div class="section" id="sum">
<h2>sum<a class="headerlink" href="#sum" title="Permalink to this headline">¶</a></h2>
<p>Calculates the sum of array elements.</p>
<dl class="function">
<dt id="Scalar sum(InputArray src)">
<strong>C++:</strong><tt class="descname"> </tt>Scalar <tt class="descname">sum</tt><big>(</big>InputArray <strong>src</strong><big>)</big><a class="headerlink" href="#Scalar sum(InputArray src)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.sumElems">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">sumElems</tt><big>(</big>src<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.sumElems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvScalar cvSum(const CvArr* arr)">
<strong>C:</strong><tt class="descname"> </tt>CvScalar <tt class="descname">cvSum</tt><big>(</big>const CvArr* <strong>arr</strong><big>)</big><a class="headerlink" href="#CvScalar cvSum(const CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Sum">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Sum</tt><big>(</big>arr<big>)</big> &rarr; scalar<a class="headerlink" href="#cv.Sum" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr</strong> &#8211; input array that must have from 1 to 4 channels.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">sum</span></tt> calculate and return the sum of array elements, independently for each channel.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#int countNonZero(InputArray src)" title="int countNonZero(InputArray src)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">countNonZero()</span></tt></a>,
<a class="reference internal" href="#Scalar mean(InputArray src, InputArray mask)" title="Scalar mean(InputArray src, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">mean()</span></tt></a>,
<a class="reference internal" href="#void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)" title="void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">meanStdDev()</span></tt></a>,
<a class="reference internal" href="#double norm(InputArray src1, int normType, InputArray mask)" title="double norm(InputArray src1, int normType, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">norm()</span></tt></a>,
<a class="reference internal" href="#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)" title="void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minMaxLoc()</span></tt></a>,
<a class="reference internal" href="#void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)" title="void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">reduce()</span></tt></a></p>
</div>
</div>
<div class="section" id="therng">
<h2>theRNG<a class="headerlink" href="#therng" title="Permalink to this headline">¶</a></h2>
<p>Returns the default random number generator.</p>
<dl class="function">
<dt id="RNG&amp; theRNG()">
<strong>C++:</strong><tt class="descname"> </tt>RNG&amp; <tt class="descname">theRNG</tt><big>(</big><big>)</big><a class="headerlink" href="#RNG& theRNG()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">theRNG</span></tt> returns the default random number generator. For each thread, there is a separate random number generator, so you can use the function safely in multi-thread environments. If you just need to get a single random number using this generator or initialize an array, you can use
<a class="reference internal" href="#template&lt;typename _Tp&gt; _Tp randu()" title="template&lt;typename _Tp&gt; _Tp randu()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randu()</span></tt></a> or
<a class="reference internal" href="#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)" title="void randn(InputOutputArray dst, InputArray mean, InputArray stddev)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randn()</span></tt></a> instead. But if you are going to generate many random numbers inside a loop, it is much faster to use this function to retrieve the generator and then use <tt class="docutils literal"><span class="pre">RNG::operator</span> <span class="pre">_Tp()</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#RNG" title="class RNG"><tt class="xref ocv ocv-class docutils literal"><span class="pre">RNG</span></tt></a>,
<a class="reference internal" href="#template&lt;typename _Tp&gt; _Tp randu()" title="template&lt;typename _Tp&gt; _Tp randu()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randu()</span></tt></a>,
<a class="reference internal" href="#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)" title="void randn(InputOutputArray dst, InputArray mean, InputArray stddev)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">randn()</span></tt></a></p>
</div>
</div>
<div class="section" id="trace">
<h2>trace<a class="headerlink" href="#trace" title="Permalink to this headline">¶</a></h2>
<p>Returns the trace of a matrix.</p>
<dl class="function">
<dt id="Scalar trace(InputArray mtx)">
<strong>C++:</strong><tt class="descname"> </tt>Scalar <tt class="descname">trace</tt><big>(</big>InputArray <strong>mtx</strong><big>)</big><a class="headerlink" href="#Scalar trace(InputArray mtx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.trace">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">trace</tt><big>(</big>mtx<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.trace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvScalar cvTrace(const CvArr* mat)">
<strong>C:</strong><tt class="descname"> </tt>CvScalar <tt class="descname">cvTrace</tt><big>(</big>const CvArr* <strong>mat</strong><big>)</big><a class="headerlink" href="#CvScalar cvTrace(const CvArr* mat)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Trace">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Trace</tt><big>(</big>mat<big>)</big> &rarr; scalar<a class="headerlink" href="#cv.Trace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mat</strong> &#8211; input matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">trace</span></tt> returns the sum of the diagonal elements of the matrix <tt class="docutils literal"><span class="pre">mtx</span></tt> .</p>
<div class="math">
<p><img src="../../../_images/math/aa380325c583d320e3a13d9ffa1841051598503e.png" alt="\mathrm{tr} ( \texttt{mtx} ) =  \sum _i  \texttt{mtx} (i,i)"/></p>
</div></div>
<div class="section" id="transform">
<h2>transform<a class="headerlink" href="#transform" title="Permalink to this headline">¶</a></h2>
<p>Performs the matrix transformation of every array element.</p>
<dl class="function">
<dt id="void transform(InputArray src, OutputArray dst, InputArray m)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">transform</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>m</strong><big>)</big><a class="headerlink" href="#void transform(InputArray src, OutputArray dst, InputArray m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.transform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">transform</tt><big>(</big>src, m<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvTransform(const CvArr* src, CvArr* dst, const CvMat* transmat, const CvMat* shiftvec)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvTransform</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>transmat</strong>, const CvMat* <strong>shiftvec</strong>=NULL <big>)</big><a class="headerlink" href="#void cvTransform(const CvArr* src, CvArr* dst, const CvMat* transmat, const CvMat* shiftvec)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Transform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Transform</tt><big>(</big>src, dst, transmat, shiftvec=None<big>)</big> &rarr; None<a class="headerlink" href="#cv.Transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array that must have as many channels (1 to 4) as <tt class="docutils literal"><span class="pre">m.cols</span></tt> or <tt class="docutils literal"><span class="pre">m.cols-1</span></tt>.</li>
<li><strong>dst</strong> &#8211; output array of the same size and depth as <tt class="docutils literal"><span class="pre">src</span></tt>; it has as many channels as <tt class="docutils literal"><span class="pre">m.rows</span></tt>.</li>
<li><strong>m</strong> &#8211; transformation <tt class="docutils literal"><span class="pre">2x2</span></tt> or <tt class="docutils literal"><span class="pre">2x3</span></tt> floating-point matrix.</li>
<li><strong>shiftvec</strong> &#8211; optional translation vector (when <tt class="docutils literal"><span class="pre">m</span></tt> is <tt class="docutils literal"><span class="pre">2x2</span></tt>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">transform</span></tt> performs the matrix transformation of every element of the array <tt class="docutils literal"><span class="pre">src</span></tt> and stores the results in <tt class="docutils literal"><span class="pre">dst</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/ac149f4bf68c92b168bf832afc1e844e4b185a59.png" alt="\texttt{dst} (I) =  \texttt{m} \cdot \texttt{src} (I)"/></p>
</div><p>(when <tt class="docutils literal"><span class="pre">m.cols=src.channels()</span></tt> ), or</p>
<div class="math">
<p><img src="../../../_images/math/699c9fb9fc2f1ec963cd8e3611e377bb0890213a.png" alt="\texttt{dst} (I) =  \texttt{m} \cdot [ \texttt{src} (I); 1]"/></p>
</div><p>(when <tt class="docutils literal"><span class="pre">m.cols=src.channels()+1</span></tt> )</p>
<p>Every element of the <tt class="docutils literal"><span class="pre">N</span></tt> -channel array <tt class="docutils literal"><span class="pre">src</span></tt> is interpreted as <tt class="docutils literal"><span class="pre">N</span></tt> -element vector that is transformed using
the <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">N</span></tt> or <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">(N+1)</span></tt> matrix <tt class="docutils literal"><span class="pre">m</span></tt>
to <tt class="docutils literal"><span class="pre">M</span></tt>-element vector - the corresponding element of the output array <tt class="docutils literal"><span class="pre">dst</span></tt> .</p>
<p>The function may be used for geometrical transformation of
<tt class="docutils literal"><span class="pre">N</span></tt> -dimensional
points, arbitrary linear color space transformation (such as various kinds of RGB to YUV transforms), shuffling the image channels, and so forth.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)" title="void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">perspectiveTransform()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getAffineTransform(InputArray src, InputArray dst)" title="Mat getAffineTransform(InputArray src, InputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getAffineTransform()</span></tt></a>,
<a class="reference internal" href="../../video/doc/motion_analysis_and_object_tracking.html#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)" title="Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">estimateRigidTransform()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a></p>
</div>
</div>
<div class="section" id="transpose">
<h2>transpose<a class="headerlink" href="#transpose" title="Permalink to this headline">¶</a></h2>
<p>Transposes a matrix.</p>
<dl class="function">
<dt id="void transpose(InputArray src, OutputArray dst)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">transpose</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><big>)</big><a class="headerlink" href="#void transpose(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.transpose">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">transpose</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvTranspose(const CvArr* src, CvArr* dst)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvTranspose</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong><big>)</big><a class="headerlink" href="#void cvTranspose(const CvArr* src, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Transpose">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Transpose</tt><big>(</big>src, dst<big>)</big> &rarr; None<a class="headerlink" href="#cv.Transpose" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array.</li>
<li><strong>dst</strong> &#8211; output array of the same type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <a class="reference internal" href="#void transpose(InputArray src, OutputArray dst)" title="void transpose(InputArray src, OutputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">transpose()</span></tt></a> transposes the matrix <tt class="docutils literal"><span class="pre">src</span></tt> :</p>
<div class="math">
<p><img src="../../../_images/math/b8ef2ca9909e612b7c6d5b424a7f3bb44813ca4e.png" alt="\texttt{dst} (i,j) =  \texttt{src} (j,i)"/></p>
</div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No complex conjugation is done in case of a complex matrix. It it should be done separately if needed.</p>
</div>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Operations on Arrays</a><ul>
<li><a class="reference internal" href="#abs">abs</a></li>
<li><a class="reference internal" href="#absdiff">absdiff</a></li>
<li><a class="reference internal" href="#add">add</a></li>
<li><a class="reference internal" href="#addweighted">addWeighted</a></li>
<li><a class="reference internal" href="#bitwise-and">bitwise_and</a></li>
<li><a class="reference internal" href="#bitwise-not">bitwise_not</a></li>
<li><a class="reference internal" href="#bitwise-or">bitwise_or</a></li>
<li><a class="reference internal" href="#bitwise-xor">bitwise_xor</a></li>
<li><a class="reference internal" href="#calccovarmatrix">calcCovarMatrix</a></li>
<li><a class="reference internal" href="#carttopolar">cartToPolar</a></li>
<li><a class="reference internal" href="#checkrange">checkRange</a></li>
<li><a class="reference internal" href="#compare">compare</a></li>
<li><a class="reference internal" href="#completesymm">completeSymm</a></li>
<li><a class="reference internal" href="#convertscaleabs">convertScaleAbs</a></li>
<li><a class="reference internal" href="#countnonzero">countNonZero</a></li>
<li><a class="reference internal" href="#cvarrtomat">cvarrToMat</a></li>
<li><a class="reference internal" href="#dct">dct</a></li>
<li><a class="reference internal" href="#dft">dft</a></li>
<li><a class="reference internal" href="#divide">divide</a></li>
<li><a class="reference internal" href="#determinant">determinant</a></li>
<li><a class="reference internal" href="#eigen">eigen</a></li>
<li><a class="reference internal" href="#exp">exp</a></li>
<li><a class="reference internal" href="#extractimagecoi">extractImageCOI</a></li>
<li><a class="reference internal" href="#insertimagecoi">insertImageCOI</a></li>
<li><a class="reference internal" href="#flip">flip</a></li>
<li><a class="reference internal" href="#gemm">gemm</a></li>
<li><a class="reference internal" href="#getconvertelem">getConvertElem</a></li>
<li><a class="reference internal" href="#getoptimaldftsize">getOptimalDFTSize</a></li>
<li><a class="reference internal" href="#idct">idct</a></li>
<li><a class="reference internal" href="#idft">idft</a></li>
<li><a class="reference internal" href="#inrange">inRange</a></li>
<li><a class="reference internal" href="#invert">invert</a></li>
<li><a class="reference internal" href="#log">log</a></li>
<li><a class="reference internal" href="#lut">LUT</a></li>
<li><a class="reference internal" href="#magnitude">magnitude</a></li>
<li><a class="reference internal" href="#mahalanobis">Mahalanobis</a></li>
<li><a class="reference internal" href="#max">max</a></li>
<li><a class="reference internal" href="#mean">mean</a></li>
<li><a class="reference internal" href="#meanstddev">meanStdDev</a></li>
<li><a class="reference internal" href="#merge">merge</a></li>
<li><a class="reference internal" href="#min">min</a></li>
<li><a class="reference internal" href="#minmaxidx">minMaxIdx</a></li>
<li><a class="reference internal" href="#minmaxloc">minMaxLoc</a></li>
<li><a class="reference internal" href="#mixchannels">mixChannels</a></li>
<li><a class="reference internal" href="#mulspectrums">mulSpectrums</a></li>
<li><a class="reference internal" href="#multiply">multiply</a></li>
<li><a class="reference internal" href="#multransposed">mulTransposed</a></li>
<li><a class="reference internal" href="#norm">norm</a></li>
<li><a class="reference internal" href="#normalize">normalize</a></li>
<li><a class="reference internal" href="#pca">PCA</a></li>
<li><a class="reference internal" href="#pca-pca">PCA::PCA</a></li>
<li><a class="reference internal" href="#pca-operator">PCA::operator ()</a></li>
<li><a class="reference internal" href="#pca-project">PCA::project</a></li>
<li><a class="reference internal" href="#pca-backproject">PCA::backProject</a></li>
<li><a class="reference internal" href="#perspectivetransform">perspectiveTransform</a></li>
<li><a class="reference internal" href="#phase">phase</a></li>
<li><a class="reference internal" href="#polartocart">polarToCart</a></li>
<li><a class="reference internal" href="#pow">pow</a></li>
<li><a class="reference internal" href="#rng">RNG</a></li>
<li><a class="reference internal" href="#rng-rng">RNG::RNG</a></li>
<li><a class="reference internal" href="#rng-next">RNG::next</a></li>
<li><a class="reference internal" href="#rng-operator-t">RNG::operator T</a></li>
<li><a class="reference internal" href="#rng-operator">RNG::operator ()</a></li>
<li><a class="reference internal" href="#rng-uniform">RNG::uniform</a></li>
<li><a class="reference internal" href="#rng-gaussian">RNG::gaussian</a></li>
<li><a class="reference internal" href="#rng-fill">RNG::fill</a></li>
<li><a class="reference internal" href="#randu">randu</a></li>
<li><a class="reference internal" href="#randn">randn</a></li>
<li><a class="reference internal" href="#randshuffle">randShuffle</a></li>
<li><a class="reference internal" href="#reduce">reduce</a></li>
<li><a class="reference internal" href="#repeat">repeat</a></li>
<li><a class="reference internal" href="#scaleadd">scaleAdd</a></li>
<li><a class="reference internal" href="#setidentity">setIdentity</a></li>
<li><a class="reference internal" href="#solve">solve</a></li>
<li><a class="reference internal" href="#solvecubic">solveCubic</a></li>
<li><a class="reference internal" href="#solvepoly">solvePoly</a></li>
<li><a class="reference internal" href="#sort">sort</a></li>
<li><a class="reference internal" href="#sortidx">sortIdx</a></li>
<li><a class="reference internal" href="#split">split</a></li>
<li><a class="reference internal" href="#sqrt">sqrt</a></li>
<li><a class="reference internal" href="#subtract">subtract</a></li>
<li><a class="reference internal" href="#svd">SVD</a></li>
<li><a class="reference internal" href="#svd-svd">SVD::SVD</a></li>
<li><a class="reference internal" href="#svd-operator">SVD::operator ()</a></li>
<li><a class="reference internal" href="#svd-compute">SVD::compute</a></li>
<li><a class="reference internal" href="#svd-solvez">SVD::solveZ</a></li>
<li><a class="reference internal" href="#svd-backsubst">SVD::backSubst</a></li>
<li><a class="reference internal" href="#sum">sum</a></li>
<li><a class="reference internal" href="#therng">theRNG</a></li>
<li><a class="reference internal" href="#trace">trace</a></li>
<li><a class="reference internal" href="#transform">transform</a></li>
<li><a class="reference internal" href="#transpose">transpose</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dynamic_structures.html"
                        title="previous chapter">Dynamic Structures</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="drawing_functions.html"
                        title="next chapter">Drawing Functions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/modules/core/doc/operations_on_arrays.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="drawing_functions.html" title="Drawing Functions"
             >next</a> |</li>
        <li class="right" >
          <a href="dynamic_structures.html" title="Dynamic Structures"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.9.0 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" >core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Apr 21, 2014.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>