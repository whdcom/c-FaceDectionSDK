
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Image Filtering &mdash; OpenCV 2.4.9.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 2.4.9.0 documentation" href="../../../index.html" />
    <link rel="up" title="imgproc. Image Processing" href="imgproc.html" />
    <link rel="next" title="Geometric Image Transformations" href="geometric_transformations.html" />
    <link rel="prev" title="imgproc. Image Processing" href="imgproc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="geometric_transformations.html" title="Geometric Image Transformations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="imgproc.html" title="imgproc. Image Processing"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.9.0 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" accesskey="U">imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="image-filtering">
<h1>Image Filtering<a class="headerlink" href="#image-filtering" title="Permalink to this headline">¶</a></h1>
<p>Functions and classes described in this section are used to perform various linear or non-linear filtering operations on 2D images (represented as
<tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat()</span></tt>&#8216;s). It means that for each pixel location
<img class="math" src="../../../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> in the source image (normally, rectangular), its neighborhood is considered and used to compute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of morphological operations, it is the minimum or maximum values, and so on. The computed response is stored in the destination image at the same location
<img class="math" src="../../../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> . It means that the output image will be of the same size as the input image. Normally, the functions support multi-channel arrays, in which case every channel is processed independently. Therefore, the output image will also have the same number of channels as the input one.</p>
<p>Another common feature of the functions and classes described in this section is that, unlike simple arithmetic functions, they need to extrapolate values of some non-existing pixels. For example, if you want to smooth an image using a Gaussian
<img class="math" src="../../../_images/math/d278803d72fcc493afb1559174a483aa7f41d143.png" alt="3 \times 3"/> filter, then, when processing the left-most pixels in each row, you need pixels to the left of them, that is, outside of the image. You can let these pixels be the same as the left-most image pixels (&#8220;replicated border&#8221; extrapolation method), or assume that all the non-existing pixels are zeros (&#8220;constant border&#8221; extrapolation method), and so on.
OpenCV enables you to specify the extrapolation method. For details, see the function  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a>  and discussion of the  <tt class="docutils literal"><span class="pre">borderType</span></tt>  parameter in the section and various functions below.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> Various border types, image boundaries are denoted with &#39;|&#39;</span>

<span class="cm"> * BORDER_REPLICATE:     aaaaaa|abcdefgh|hhhhhhh</span>
<span class="cm"> * BORDER_REFLECT:       fedcba|abcdefgh|hgfedcb</span>
<span class="cm"> * BORDER_REFLECT_101:   gfedcb|abcdefgh|gfedcba</span>
<span class="cm"> * BORDER_WRAP:          cdefgh|abcdefgh|abcdefg</span>
<span class="cm"> * BORDER_CONSTANT:      iiiiii|abcdefgh|iiiiiii  with some specified &#39;i&#39;</span>
<span class="cm"> */</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>(Python) A complete example illustrating different morphological operations like erode/dilate, open/close, blackhat/tophat ... can be found at opencv_source_code/samples/python2/morphology.py</li>
</ul>
</div>
<div class="section" id="basecolumnfilter">
<h2>BaseColumnFilter<a class="headerlink" href="#basecolumnfilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BaseColumnFilter">
<em class="property">class </em><tt class="descname">BaseColumnFilter</tt><a class="headerlink" href="#BaseColumnFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for filters with single-column kernels.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseColumnFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseColumnFilter</span><span class="p">();</span>

    <span class="c1">// To be overriden by the user.</span>
    <span class="c1">//</span>
    <span class="c1">// runs a filtering operation on the set of rows,</span>
    <span class="c1">// &quot;dstcount + ksize - 1&quot; rows on input,</span>
    <span class="c1">// &quot;dstcount&quot; rows on output,</span>
    <span class="c1">// each input and output row has &quot;width&quot; elements</span>
    <span class="c1">// the filtered rows are written into &quot;dst&quot; buffer.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">**</span> <span class="n">src</span><span class="p">,</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dststep</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">dstcount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// resets the filter state (may be needed for IIR filters)</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">reset</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">ksize</span><span class="p">;</span> <span class="c1">// the aperture size</span>
    <span class="kt">int</span> <span class="n">anchor</span><span class="p">;</span> <span class="c1">// position of the anchor point,</span>
                <span class="c1">// normally not used during the processing</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">BaseColumnFilter</span></tt> is a base class for filtering data using single-column kernels. Filtering does not have to be a linear operation. In general, it could be written as follows:</p>
<div class="math">
<p><img src="../../../_images/math/283057407b1837ae0c58ce608ff39ba6dfabab9c.png" alt="\texttt{dst} (x,y) = F( \texttt{src} [y](x), \; \texttt{src} [y+1](x), \; ..., \; \texttt{src} [y+ \texttt{ksize} -1](x)"/></p>
</div><p>where
<img class="math" src="../../../_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/> is a filtering function but, as it is represented as a class, it can produce any side effects, memorize previously processed data, and so on. The class only defines an interface and is not used directly. Instead, there are several functions in OpenCV (and you can add more) that return pointers to the derived classes that implement specific filtering operations. Those pointers are then passed to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> constructor. While the filtering operation interface uses the <tt class="docutils literal"><span class="pre">uchar</span></tt> type, a particular implementation is not limited to 8-bit data.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseRowFilter" title="class BaseRowFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseRowFilter</span></tt></a>,
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></tt></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)" title="Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getColumnSumFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)" title="Ptr&lt;BaseColumnFilter&gt; getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getLinearColumnFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getMorphologyColumnFilter(int op, int type, int ksize, int anchor)" title="Ptr&lt;BaseColumnFilter&gt; getMorphologyColumnFilter(int op, int type, int ksize, int anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getMorphologyColumnFilter()</span></tt></a></p>
</div>
</div>
<div class="section" id="basefilter">
<h2>BaseFilter<a class="headerlink" href="#basefilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BaseFilter">
<em class="property">class </em><tt class="descname">BaseFilter</tt><a class="headerlink" href="#BaseFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for 2D image filters.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseFilter</span><span class="p">();</span>

    <span class="c1">// To be overriden by the user.</span>
    <span class="c1">//</span>
    <span class="c1">// runs a filtering operation on the set of rows,</span>
    <span class="c1">// &quot;dstcount + ksize.height - 1&quot; rows on input,</span>
    <span class="c1">// &quot;dstcount&quot; rows on output,</span>
    <span class="c1">// each input row has &quot;(width + ksize.width-1)*cn&quot; elements</span>
    <span class="c1">// each output row has &quot;width*cn&quot; elements.</span>
    <span class="c1">// the filtered rows are written into &quot;dst&quot; buffer.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">**</span> <span class="n">src</span><span class="p">,</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dststep</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">dstcount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// resets the filter state (may be needed for IIR filters)</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">reset</span><span class="p">();</span>
    <span class="n">Size</span> <span class="n">ksize</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">anchor</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">BaseFilter</span></tt> is a base class for filtering data using 2D kernels. Filtering does not have to be a linear operation. In general, it could be written as follows:</p>
<div class="math">
<p><img src="../../../_images/math/7154f919653e0e8e27c44e70dd0f9bd384d15346.png" alt="\begin{array}{l} \texttt{dst} (x,y) = F(  \texttt{src} [y](x), \; \texttt{src} [y](x+1), \; ..., \; \texttt{src} [y](x+ \texttt{ksize.width} -1),  \\ \texttt{src} [y+1](x), \; \texttt{src} [y+1](x+1), \; ..., \; \texttt{src} [y+1](x+ \texttt{ksize.width} -1),  \\ .........................................................................................  \\ \texttt{src} [y+ \texttt{ksize.height-1} ](x), \\ \texttt{src} [y+ \texttt{ksize.height-1} ](x+1), \\ ...
   \texttt{src} [y+ \texttt{ksize.height-1} ](x+ \texttt{ksize.width} -1))
   \end{array}"/></p>
</div><p>where
<img class="math" src="../../../_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/> is a filtering function. The class only defines an interface and is not used directly. Instead, there are several functions in OpenCV (and you can add more) that return pointers to the derived classes that implement specific filtering operations. Those pointers are then passed to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> constructor. While the filtering operation interface uses the <tt class="docutils literal"><span class="pre">uchar</span></tt> type, a particular implementation is not limited to 8-bit data.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseColumnFilter" title="class BaseColumnFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseColumnFilter</span></tt></a>,
<a class="reference internal" href="#BaseRowFilter" title="class BaseRowFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseRowFilter</span></tt></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseFilter&gt; getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)" title="Ptr&lt;BaseFilter&gt; getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getLinearFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseFilter&gt; getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)" title="Ptr&lt;BaseFilter&gt; getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getMorphologyFilter()</span></tt></a></p>
</div>
</div>
<div class="section" id="baserowfilter">
<h2>BaseRowFilter<a class="headerlink" href="#baserowfilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BaseRowFilter">
<em class="property">class </em><tt class="descname">BaseRowFilter</tt><a class="headerlink" href="#BaseRowFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for filters with single-row kernels.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseRowFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseRowFilter</span><span class="p">();</span>

    <span class="c1">// To be overriden by the user.</span>
    <span class="c1">//</span>
    <span class="c1">// runs filtering operation on the single input row</span>
    <span class="c1">// of &quot;width&quot; element, each element is has &quot;cn&quot; channels.</span>
    <span class="c1">// the filtered row is written into &quot;dst&quot; buffer.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">anchor</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">BaseRowFilter</span></tt> is a base class for filtering data using single-row kernels. Filtering does not have to be a linear operation. In general, it could be written as follows:</p>
<div class="math">
<p><img src="../../../_images/math/7fff1eee21140adda2558a63fb40d93e598cef91.png" alt="\texttt{dst} (x,y) = F( \texttt{src} [y](x), \; \texttt{src} [y](x+1), \; ..., \; \texttt{src} [y](x+ \texttt{ksize.width} -1))"/></p>
</div><p>where
<img class="math" src="../../../_images/math/a055f405829e64a3b70253ab67cb45ed6ed5bb29.png" alt="F"/> is a filtering function. The class only defines an interface and is not used directly. Instead, there are several functions in OpenCV (and you can add more) that return pointers to the derived classes that implement specific filtering operations. Those pointers are then passed to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> constructor. While the filtering operation interface uses the <tt class="docutils literal"><span class="pre">uchar</span></tt> type, a particular implementation is not limited to 8-bit data.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseColumnFilter" title="class BaseColumnFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseColumnFilter</span></tt></a>,
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></tt></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)" title="Ptr&lt;BaseRowFilter&gt; getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getLinearRowFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getMorphologyRowFilter(int op, int type, int ksize, int anchor)" title="Ptr&lt;BaseRowFilter&gt; getMorphologyRowFilter(int op, int type, int ksize, int anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getMorphologyRowFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)" title="Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getRowSumFilter()</span></tt></a></p>
</div>
</div>
<div class="section" id="filterengine">
<h2>FilterEngine<a class="headerlink" href="#filterengine" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="FilterEngine">
<em class="property">class </em><tt class="descname">FilterEngine</tt><a class="headerlink" href="#FilterEngine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Generic image filtering class.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FilterEngine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// empty constructor</span>
    <span class="n">FilterEngine</span><span class="p">();</span>
    <span class="c1">// builds a 2D non-separable filter (!_filter2D.empty()) or</span>
    <span class="c1">// a separable filter (!_rowFilter.empty() &amp;&amp; !_columnFilter.empty())</span>
    <span class="c1">// the input data type will be &quot;srcType&quot;, the output data type will be &quot;dstType&quot;,</span>
    <span class="c1">// the intermediate data type is &quot;bufType&quot;.</span>
    <span class="c1">// _rowBorderType and _columnBorderType determine how the image</span>
    <span class="c1">// will be extrapolated beyond the image boundaries.</span>
    <span class="c1">// _borderValue is only used when _rowBorderType and/or _columnBorderType</span>
    <span class="c1">// == BORDER_CONSTANT</span>
    <span class="n">FilterEngine</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseFilter</span><span class="o">&gt;&amp;</span> <span class="n">_filter2D</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseRowFilter</span><span class="o">&gt;&amp;</span> <span class="n">_rowFilter</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseColumnFilter</span><span class="o">&gt;&amp;</span> <span class="n">_columnFilter</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">srcType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufType</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">_rowBorderType</span><span class="o">=</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">_columnBorderType</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// use _rowBorderType by default</span>
                 <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">_borderValue</span><span class="o">=</span><span class="n">Scalar</span><span class="p">());</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FilterEngine</span><span class="p">();</span>
    <span class="c1">// separate function for the engine initialization</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseFilter</span><span class="o">&gt;&amp;</span> <span class="n">_filter2D</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseRowFilter</span><span class="o">&gt;&amp;</span> <span class="n">_rowFilter</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseColumnFilter</span><span class="o">&gt;&amp;</span> <span class="n">_columnFilter</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">srcType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufType</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">_rowBorderType</span><span class="o">=</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_columnBorderType</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">_borderValue</span><span class="o">=</span><span class="n">Scalar</span><span class="p">());</span>
    <span class="c1">// starts filtering of the ROI in an image of size &quot;wholeSize&quot;.</span>
    <span class="c1">// returns the starting y-position in the source image.</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">start</span><span class="p">(</span><span class="n">Size</span> <span class="n">wholeSize</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">roi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxBufRows</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// alternative form of start that takes the image</span>
    <span class="c1">// itself instead of &quot;wholeSize&quot;. Set isolated to true to pretend that</span>
    <span class="c1">// there are no real pixels outside of the ROI</span>
    <span class="c1">// (so that the pixels are extrapolated using the specified border modes)</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">start</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">srcRoi</span><span class="o">=</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                      <span class="kt">bool</span> <span class="n">isolated</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxBufRows</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// processes the next portion of the source image,</span>
    <span class="c1">// &quot;srcCount&quot; rows starting from &quot;src&quot; and</span>
    <span class="c1">// stores the results in &quot;dst&quot;.</span>
    <span class="c1">// returns the number of produced rows</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">proceed</span><span class="p">(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srcStep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srcCount</span><span class="p">,</span>
                        <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstStep</span><span class="p">);</span>
    <span class="c1">// higher-level function that processes the whole</span>
    <span class="c1">// ROI or the whole image with a single call</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">srcRoi</span><span class="o">=</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">Point</span> <span class="n">dstOfs</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                        <span class="kt">bool</span> <span class="n">isolated</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">isSeparable</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">filter2D</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// how many rows from the input image are not yet processed</span>
    <span class="kt">int</span> <span class="n">remainingInputRows</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// how many output rows are not yet produced</span>
    <span class="kt">int</span> <span class="n">remainingOutputRows</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">// the starting and the ending rows in the source image</span>
    <span class="kt">int</span> <span class="n">startY</span><span class="p">,</span> <span class="n">endY</span><span class="p">;</span>

    <span class="c1">// pointers to the filters</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseFilter</span><span class="o">&gt;</span> <span class="n">filter2D</span><span class="p">;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseRowFilter</span><span class="o">&gt;</span> <span class="n">rowFilter</span><span class="p">;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseColumnFilter</span><span class="o">&gt;</span> <span class="n">columnFilter</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">FilterEngine</span></tt> can be used to apply an arbitrary filtering operation to an image.
It contains all the necessary intermediate buffers, computes extrapolated values
of the &#8220;virtual&#8221; pixels outside of the image, and so on. Pointers to the initialized <tt class="docutils literal"><span class="pre">FilterEngine</span></tt> instances
are returned by various <tt class="docutils literal"><span class="pre">create*Filter</span></tt> functions (see below) and they are used inside high-level functions such as
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a>,
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></tt></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></tt></a>, and others. Thus, the class plays a key role in many of OpenCV filtering functions.</p>
<p>This class makes it easier to combine filtering operations with other operations, such as color space conversions, thresholding, arithmetic operations, and others. By combining several operations together you can get much better performance because your data will stay in cache. For example, see below the implementation of the Laplace operator for floating-point images, which is a simplified implementation of
<a class="reference internal" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Laplacian()</span></tt></a> :</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="n">laplace_f</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_32F</span> <span class="p">);</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="c1">// get the derivative and smooth kernels for d2I/dx2.</span>
    <span class="c1">// for d2I/dy2 consider using the same kernels, just swapped</span>
    <span class="n">Mat</span> <span class="n">kd</span><span class="p">,</span> <span class="n">ks</span><span class="p">;</span>
    <span class="n">getSobelKernels</span><span class="p">(</span> <span class="n">kd</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ksize</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="n">ktype</span> <span class="p">);</span>

    <span class="c1">// process 10 source rows at once</span>
    <span class="kt">int</span> <span class="n">DELTA</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FilterEngine</span><span class="o">&gt;</span> <span class="n">Fxx</span> <span class="o">=</span> <span class="n">createSeparableLinearFilter</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span>
        <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">kd</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FilterEngine</span><span class="o">&gt;</span> <span class="n">Fyy</span> <span class="o">=</span> <span class="n">createSeparableLinearFilter</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span>
        <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">ks</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">()</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Fxx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">dsty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Fyy</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">sptr</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">;</span>

    <span class="c1">// allocate the buffers for the spatial image derivatives;</span>
    <span class="c1">// the buffers need to have more than DELTA rows, because at the</span>
    <span class="c1">// last iteration the output may take max(kd.rows-1,ks.rows-1)</span>
    <span class="c1">// rows more than the input.</span>
    <span class="n">Mat</span> <span class="n">Ixx</span><span class="p">(</span> <span class="n">DELTA</span> <span class="o">+</span> <span class="n">kd</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">Mat</span> <span class="n">Iyy</span><span class="p">(</span> <span class="n">DELTA</span> <span class="o">+</span> <span class="n">kd</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="p">);</span>

    <span class="c1">// inside the loop always pass DELTA rows to the filter</span>
    <span class="c1">// (note that the &quot;proceed&quot; method takes care of possibe overflow, since</span>
    <span class="c1">// it was given the actual image height in the &quot;start&quot; method)</span>
    <span class="c1">// on output you can get:</span>
    <span class="c1">//  * &lt; DELTA rows (initial buffer accumulation stage)</span>
    <span class="c1">//  * = DELTA rows (settled state in the middle)</span>
    <span class="c1">//  * &gt; DELTA rows (when the input image is over, generate</span>
    <span class="c1">//                  &quot;virtual&quot; rows using the border mode and filter them)</span>
    <span class="c1">// this variable number of output rows is dy.</span>
    <span class="c1">// dsty is the current output row.</span>
    <span class="c1">// sptr is the pointer to the first input row in the portion to process</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">dsty</span> <span class="o">&lt;</span> <span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">sptr</span> <span class="o">+=</span> <span class="n">DELTA</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">dsty</span> <span class="o">+=</span> <span class="n">dy</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Fxx</span><span class="o">-&gt;</span><span class="n">proceed</span><span class="p">(</span> <span class="n">sptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">Ixx</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Ixx</span><span class="p">.</span><span class="n">step</span> <span class="p">);</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">Fyy</span><span class="o">-&gt;</span><span class="n">proceed</span><span class="p">(</span> <span class="n">sptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">d2y</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Iyy</span><span class="p">.</span><span class="n">step</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Mat</span> <span class="n">dstripe</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="n">dsty</span><span class="p">,</span> <span class="n">dsty</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
            <span class="n">add</span><span class="p">(</span><span class="n">Ixx</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="p">),</span> <span class="n">Iyy</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="p">),</span> <span class="n">dstripe</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you do not need that much control of the filtering process, you can simply use the <tt class="docutils literal"><span class="pre">FilterEngine::apply</span></tt> method. The method is implemented as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="n">FilterEngine</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">srcRoi</span><span class="p">,</span> <span class="n">Point</span> <span class="n">dstOfs</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isolated</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// check matrix types</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">srcType</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">dstType</span> <span class="p">);</span>

    <span class="c1">// handle the &quot;whole image&quot; case</span>
    <span class="n">Rect</span> <span class="n">_srcRoi</span> <span class="o">=</span> <span class="n">srcRoi</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">_srcRoi</span> <span class="o">==</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">_srcRoi</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>

    <span class="c1">// check if the destination ROI is inside dst.</span>
    <span class="c1">// and FilterEngine::start will check if the source ROI is inside src.</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">dstOfs</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dstOfs</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">dstOfs</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">_srcRoi</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;=</span> <span class="n">dst</span><span class="p">.</span><span class="n">cols</span> <span class="o">&amp;&amp;</span>
        <span class="n">dstOfs</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">_srcRoi</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;=</span> <span class="n">dst</span><span class="p">.</span><span class="n">rows</span> <span class="p">);</span>

    <span class="c1">// start filtering</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">start</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_srcRoi</span><span class="p">,</span> <span class="n">isolated</span><span class="p">);</span>

    <span class="c1">// process the whole ROI. Note that &quot;endY - startY&quot; is the total number</span>
    <span class="c1">// of the source rows to process</span>
    <span class="c1">// (including the possible rows outside of srcRoi but inside the source image)</span>
    <span class="n">proceed</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span>
             <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">endY</span> <span class="o">-</span> <span class="n">startY</span><span class="p">,</span>
             <span class="n">dst</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">dstOfs</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">dst</span><span class="p">.</span><span class="n">step</span> <span class="o">+</span>
             <span class="n">dstOfs</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">dst</span><span class="p">.</span><span class="n">elemSize</span><span class="p">(),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dst</span><span class="p">.</span><span class="n">step</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unlike the earlier versions of OpenCV, now the filtering operations fully support the notion of image ROI, that is, pixels outside of the ROI but inside the image can be used in the filtering operations. For example, you can take a ROI of a single pixel and filter it. This will be a filter response at that particular pixel. However, it is possible to emulate the old behavior by passing <tt class="docutils literal"><span class="pre">isolated=false</span></tt> to <tt class="docutils literal"><span class="pre">FilterEngine::start</span></tt> or <tt class="docutils literal"><span class="pre">FilterEngine::apply</span></tt> . You can pass the ROI explicitly to <tt class="docutils literal"><span class="pre">FilterEngine::apply</span></tt>  or construct new matrix headers:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute dI/dx derivative at src(x,y)</span>

<span class="c1">// method 1:</span>
<span class="c1">// form a matrix header for a single value</span>
<span class="kt">float</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">dst1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">,</span><span class="o">&amp;</span><span class="n">val1</span><span class="p">);</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FilterEngine</span><span class="o">&gt;</span> <span class="n">Fx</span> <span class="o">=</span> <span class="n">createDerivFilter</span><span class="p">(</span><span class="n">CV_32F</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">BORDER_REFLECT_101</span><span class="p">);</span>
<span class="n">Fx</span><span class="o">-&gt;</span><span class="n">apply</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Point</span><span class="p">(),</span> <span class="n">dst1</span><span class="p">);</span>

<span class="c1">// method 2:</span>
<span class="c1">// form a matrix header for a single value</span>
<span class="kt">float</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">dst2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">,</span><span class="o">&amp;</span><span class="n">val2</span><span class="p">);</span>

<span class="n">Mat</span> <span class="n">pix_roi</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="n">Sobel</span><span class="p">(</span><span class="n">pix_roi</span><span class="p">,</span> <span class="n">dst2</span><span class="p">,</span> <span class="n">dst2</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BORDER_REFLECT_101</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;method1 =</span>
</pre></div>
</div>
<p>Explore the data types. As it was mentioned in the
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></tt></a> description, the specific filters can process data of any type, despite that <tt class="docutils literal"><span class="pre">Base*Filter::operator()</span></tt> only takes <tt class="docutils literal"><span class="pre">uchar</span></tt> pointers and no information about the actual types. To make it all work, the following rules are used:</p>
<ul class="simple">
<li>In case of separable filtering, <tt class="docutils literal"><span class="pre">FilterEngine::rowFilter</span></tt>   is  applied first. It transforms the input image data (of type <tt class="docutils literal"><span class="pre">srcType</span></tt>  ) to the intermediate results stored in the internal buffers (of type <tt class="docutils literal"><span class="pre">bufType</span></tt>   ). Then, these intermediate results are processed as
<em>single-channel data</em>
with <tt class="docutils literal"><span class="pre">FilterEngine::columnFilter</span></tt>     and stored in the output image (of type <tt class="docutils literal"><span class="pre">dstType</span></tt>     ). Thus, the input type for <tt class="docutils literal"><span class="pre">rowFilter</span></tt>     is <tt class="docutils literal"><span class="pre">srcType</span></tt>     and the output type is <tt class="docutils literal"><span class="pre">bufType</span></tt>  . The input type for <tt class="docutils literal"><span class="pre">columnFilter</span></tt>     is <tt class="docutils literal"><span class="pre">CV_MAT_DEPTH(bufType)</span></tt>     and the output type is <tt class="docutils literal"><span class="pre">CV_MAT_DEPTH(dstType)</span></tt>     .</li>
<li>In case of non-separable filtering, <tt class="docutils literal"><span class="pre">bufType</span></tt>     must be the same as <tt class="docutils literal"><span class="pre">srcType</span></tt>     . The source data is copied to the temporary buffer, if needed, and then just passed to <tt class="docutils literal"><span class="pre">FilterEngine::filter2D</span></tt>     . That is, the input type for <tt class="docutils literal"><span class="pre">filter2D</span></tt>     is <tt class="docutils literal"><span class="pre">srcType</span></tt>     (= <tt class="docutils literal"><span class="pre">bufType</span></tt>     ) and the output type is <tt class="docutils literal"><span class="pre">dstType</span></tt>     .</li>
</ul>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseColumnFilter" title="class BaseColumnFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseColumnFilter</span></tt></a>,
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></tt></a>,
<a class="reference internal" href="#BaseRowFilter" title="class BaseRowFilter"><tt class="xref ocv ocv-class docutils literal"><span class="pre">BaseRowFilter</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)" title="Ptr&lt;FilterEngine&gt; createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createBoxFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)" title="Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createDerivFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)" title="Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createGaussianFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a></p>
</div>
</div>
<div class="section" id="bilateralfilter">
<h2>bilateralFilter<a class="headerlink" href="#bilateralfilter" title="Permalink to this headline">¶</a></h2>
<p>Applies the bilateral filter to an image.</p>
<dl class="function">
<dt id="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">bilateralFilter</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>d</strong>, double <strong>sigmaColor</strong>, double <strong>sigmaSpace</strong>, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.bilateralFilter">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">bilateralFilter</tt><big>(</big>src, d, sigmaColor, sigmaSpace<span class="optional">[</span>, dst<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.bilateralFilter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source 8-bit or floating-point, 1-channel or 3-channel image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>d</strong> &#8211; Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from  <tt class="docutils literal"><span class="pre">sigmaSpace</span></tt> .</li>
<li><strong>sigmaColor</strong> &#8211; Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see  <tt class="docutils literal"><span class="pre">sigmaSpace</span></tt> ) will be mixed together, resulting in larger areas of semi-equal color.</li>
<li><strong>sigmaSpace</strong> &#8211; Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see  <tt class="docutils literal"><span class="pre">sigmaColor</span></tt> ). When  <tt class="docutils literal"><span class="pre">d&gt;0</span></tt> , it specifies the neighborhood size regardless of  <tt class="docutils literal"><span class="pre">sigmaSpace</span></tt> . Otherwise,  <tt class="docutils literal"><span class="pre">d</span></tt>  is proportional to  <tt class="docutils literal"><span class="pre">sigmaSpace</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies bilateral filtering to the input image, as described in
<a class="reference external" href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a>
<tt class="docutils literal"><span class="pre">bilateralFilter</span></tt> can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.</p>
<p><em>Sigma values</em>: For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look &#8220;cartoonish&#8221;.</p>
<p><em>Filter size</em>: Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.</p>
<p>This filter does not work inplace.</p>
</div>
<div class="section" id="adaptivebilateralfilter">
<h2>adaptiveBilateralFilter<a class="headerlink" href="#adaptivebilateralfilter" title="Permalink to this headline">¶</a></h2>
<p>Applies the adaptive bilateral filter to an image.</p>
<dl class="function">
<dt id="void adaptiveBilateralFilter(InputArray src, OutputArray dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">adaptiveBilateralFilter</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>ksize</strong>, double <strong>sigmaSpace</strong>, double <strong>maxSigmaColor</strong>=20.0, Point <strong>anchor</strong>=Point(-1, -1), int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void adaptiveBilateralFilter(InputArray src, OutputArray dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.adaptiveBilateralFilter">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">adaptiveBilateralFilter</tt><big>(</big>src, ksize, sigmaSpace<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.adaptiveBilateralFilter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source image</li>
<li><strong>dst</strong> &#8211; The destination image; will have the same size and the same type as src</li>
<li><strong>ksize</strong> &#8211; The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner).</li>
<li><strong>sigmaSpace</strong> &#8211; Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.</li>
<li><strong>maxSigmaColor</strong> &#8211; Maximum allowed sigma color (will clamp the value calculated in the ksize neighborhood. Larger value of the parameter means that more dissimilar pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>A main part of our strategy will be to load each raw pixel once, and reuse it to calculate all pixels in the output (filtered) image that need this pixel value. The math of the filter is that of the usual bilateral filter, except that the sigma color is calculated in the neighborhood, and clamped by the optional input value.</p>
</div>
<div class="section" id="blur">
<h2>blur<a class="headerlink" href="#blur" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using the normalized box filter.</p>
<dl class="function">
<dt id="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">blur</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.blur">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">blur</tt><big>(</big>src, ksize<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.blur" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; it can have any number of channels, which are processed independently, but the depth should be <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16S</span></tt>, <tt class="docutils literal"><span class="pre">CV_32F</span></tt> or <tt class="docutils literal"><span class="pre">CV_64F</span></tt>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ksize</strong> &#8211; blurring kernel size.</li>
<li><strong>anchor</strong> &#8211; anchor point; default value <tt class="docutils literal"><span class="pre">Point(-1,-1)</span></tt> means that the anchor is at the kernel center.</li>
<li><strong>borderType</strong> &#8211; border mode used to extrapolate pixels outside of the image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smoothes an image using the kernel:</p>
<div class="math">
<p><img src="../../../_images/math/3c749f957e01b48690e2958b59fb53cb0f1aea2a.png" alt="\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix}"/></p>
</div><p>The call <tt class="docutils literal"><span class="pre">blur(src,</span> <span class="pre">dst,</span> <span class="pre">ksize,</span> <span class="pre">anchor,</span> <span class="pre">borderType)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">boxFilter(src,</span> <span class="pre">dst,</span> <span class="pre">src.type(),</span> <span class="pre">anchor,</span> <span class="pre">true,</span> <span class="pre">borderType)</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a>,
<a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a>,
<a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></tt></a></p>
</div>
</div>
<div class="section" id="borderinterpolate">
<h2>borderInterpolate<a class="headerlink" href="#borderinterpolate" title="Permalink to this headline">¶</a></h2>
<p>Computes the source location of an extrapolated pixel.</p>
<dl class="function">
<dt id="int borderInterpolate(int p, int len, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">borderInterpolate</tt><big>(</big>int <strong>p</strong>, int <strong>len</strong>, int <strong>borderType</strong><big>)</big><a class="headerlink" href="#int borderInterpolate(int p, int len, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.borderInterpolate">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">borderInterpolate</tt><big>(</big>p, len, borderType<big>)</big> &rarr; retval<a class="headerlink" href="#cv2.borderInterpolate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; 0-based coordinate of the extrapolated pixel along one of the axes, likely &lt;0 or &gt;= <tt class="docutils literal"><span class="pre">len</span></tt> .</li>
<li><strong>len</strong> &#8211; Length of the array along the corresponding axis.</li>
<li><strong>borderType</strong> &#8211; Border type, one of the  <tt class="docutils literal"><span class="pre">BORDER_*</span></tt> , except for  <tt class="docutils literal"><span class="pre">BORDER_TRANSPARENT</span></tt>  and  <tt class="docutils literal"><span class="pre">BORDER_ISOLATED</span></tt> . When  <tt class="docutils literal"><span class="pre">borderType==BORDER_CONSTANT</span></tt> , the function always returns -1, regardless of  <tt class="docutils literal"><span class="pre">p</span></tt>  and  <tt class="docutils literal"><span class="pre">len</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns the coordinate of a donor pixel corresponding to the specified extrapolated pixel when using the specified extrapolation border mode. For example, if you use <tt class="docutils literal"><span class="pre">BORDER_WRAP</span></tt> mode in the horizontal direction, <tt class="docutils literal"><span class="pre">BORDER_REFLECT_101</span></tt> in the vertical direction and want to compute value of the &#8220;virtual&#8221; pixel <tt class="docutils literal"><span class="pre">Point(-5,</span> <span class="pre">100)</span></tt> in a floating-point image <tt class="docutils literal"><span class="pre">img</span></tt> , it looks like:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">borderInterpolate</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">BORDER_REFLECT_101</span><span class="p">),</span>
                          <span class="n">borderInterpolate</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">BORDER_WRAP</span><span class="p">));</span>
</pre></div>
</div>
<p>Normally, the function is not called directly. It is used inside
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> and
<a class="reference internal" href="#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)" title="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">copyMakeBorder()</span></tt></a> to compute tables for quick extrapolation.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)" title="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">copyMakeBorder()</span></tt></a></p>
</div>
</div>
<div class="section" id="boxfilter">
<h2>boxFilter<a class="headerlink" href="#boxfilter" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using the box filter.</p>
<dl class="function">
<dt id="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">boxFilter</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1), bool <strong>normalize</strong>=true, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.boxFilter">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">boxFilter</tt><big>(</big>src, ddepth, ksize<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, normalize<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.boxFilter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ddepth</strong> &#8211; the output image depth (-1 to use <tt class="docutils literal"><span class="pre">src.depth()</span></tt>).</li>
<li><strong>ksize</strong> &#8211; blurring kernel size.</li>
<li><strong>anchor</strong> &#8211; anchor point; default value <tt class="docutils literal"><span class="pre">Point(-1,-1)</span></tt> means that the anchor is at the kernel center.</li>
<li><strong>normalize</strong> &#8211; flag, specifying whether the kernel is normalized by its area or not.</li>
<li><strong>borderType</strong> &#8211; border mode used to extrapolate pixels outside of the image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smoothes an image using the kernel:</p>
<div class="math">
<p><img src="../../../_images/math/835745aded9c1babd470569e4897f7402a00703c.png" alt="\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/bd453ad9ccad187d9f0eab937b0b343a77136590.png" alt="\alpha = \fork{\frac{1}{\texttt{ksize.width*ksize.height}}}{when \texttt{normalize=true}}{1}{otherwise}"/></p>
</div><p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use <a class="reference internal" href="miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)" title="void integral(InputArray src, OutputArray sum, int sdepth)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">integral()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a>,
<a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a>,
<a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></tt></a>,
<a class="reference internal" href="miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)" title="void integral(InputArray src, OutputArray sum, int sdepth)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">integral()</span></tt></a></p>
</div>
</div>
<div class="section" id="buildpyramid">
<h2>buildPyramid<a class="headerlink" href="#buildpyramid" title="Permalink to this headline">¶</a></h2>
<p>Constructs the Gaussian pyramid for an image.</p>
<dl class="function">
<dt id="void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">buildPyramid</tt><big>(</big>InputArray <strong>src</strong>, OutputArrayOfArrays <strong>dst</strong>, int <strong>maxlevel</strong>, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image. Check  <a class="reference internal" href="#void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)" title="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pyrDown()</span></tt></a>  for the list of supported types.</li>
<li><strong>dst</strong> &#8211; Destination vector of  <tt class="docutils literal"><span class="pre">maxlevel+1</span></tt>  images of the same type as  <tt class="docutils literal"><span class="pre">src</span></tt> . <tt class="docutils literal"><span class="pre">dst[0]</span></tt>  will be the same as  <tt class="docutils literal"><span class="pre">src</span></tt> .  <tt class="docutils literal"><span class="pre">dst[1]</span></tt>  is the next pyramid layer, a smoothed and down-sized  <tt class="docutils literal"><span class="pre">src</span></tt>  , and so on.</li>
<li><strong>maxlevel</strong> &#8211; 0-based index of the last (the smallest) pyramid layer. It must be non-negative.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function constructs a vector of images and builds the Gaussian pyramid by recursively applying
<a class="reference internal" href="#void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)" title="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pyrDown()</span></tt></a> to the previously built pyramid layers, starting from <tt class="docutils literal"><span class="pre">dst[0]==src</span></tt> .</p>
</div>
<div class="section" id="copymakeborder">
<h2>copyMakeBorder<a class="headerlink" href="#copymakeborder" title="Permalink to this headline">¶</a></h2>
<p>Forms a border around an image.</p>
<dl class="function">
<dt id="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">copyMakeBorder</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>top</strong>, int <strong>bottom</strong>, int <strong>left</strong>, int <strong>right</strong>, int <strong>borderType</strong>, const Scalar&amp; <strong>value</strong>=Scalar() <big>)</big><a class="headerlink" href="#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.copyMakeBorder">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">copyMakeBorder</tt><big>(</big>src, top, bottom, left, right, borderType<span class="optional">[</span>, dst<span class="optional">[</span>, value<span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.copyMakeBorder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCopyMakeBorder(const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCopyMakeBorder</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvPoint <strong>offset</strong>, int <strong>bordertype</strong>, CvScalar <strong>value</strong>=cvScalarAll(0) <big>)</big><a class="headerlink" href="#void cvCopyMakeBorder(const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CopyMakeBorder">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">CopyMakeBorder</tt><big>(</big>src, dst, offset, bordertype, value=(0, 0, 0, 0)<big>)</big> &rarr; None<a class="headerlink" href="#cv.CopyMakeBorder" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same type as  <tt class="docutils literal"><span class="pre">src</span></tt>  and the size  <tt class="docutils literal"><span class="pre">Size(src.cols+left+right,</span> <span class="pre">src.rows+top+bottom)</span></tt> .</li>
<li><strong>top</strong> &#8211; </li>
<li><strong>bottom</strong> &#8211; </li>
<li><strong>left</strong> &#8211; </li>
<li><strong>right</strong> &#8211; Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example,  <tt class="docutils literal"><span class="pre">top=1,</span> <span class="pre">bottom=1,</span> <span class="pre">left=1,</span> <span class="pre">right=1</span></tt>  mean that 1 pixel-wide border needs to be built.</li>
<li><strong>borderType</strong> &#8211; Border type. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details.</li>
<li><strong>value</strong> &#8211; Border value if  <tt class="docutils literal"><span class="pre">borderType==BORDER_CONSTANT</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> or filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling.</p>
<p>The function supports the mode when <tt class="docutils literal"><span class="pre">src</span></tt> is already in the middle of <tt class="docutils literal"><span class="pre">dst</span></tt> . In this case, the function does not copy <tt class="docutils literal"><span class="pre">src</span></tt> itself but simply constructs the border, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// let border be the same in all directions</span>
<span class="kt">int</span> <span class="n">border</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="c1">// constructs a larger image to fit both the image and the border</span>
<span class="n">Mat</span> <span class="n">gray_buf</span><span class="p">(</span><span class="n">rgb</span><span class="p">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">border</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">border</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">depth</span><span class="p">());</span>
<span class="c1">// select the middle part of it w/o copying data</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">(</span><span class="n">gray_canvas</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">rows</span><span class="p">));</span>
<span class="c1">// convert image from RGB to grayscale</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">CV_RGB2GRAY</span><span class="p">);</span>
<span class="c1">// form a border in-place</span>
<span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">gray_buf</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span>
               <span class="n">border</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="n">BORDER_REPLICATE</span><span class="p">);</span>
<span class="c1">// now do some custom filtering ...</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if <tt class="docutils literal"><span class="pre">src</span></tt> was not a ROI, use <tt class="docutils literal"><span class="pre">borderType</span> <span class="pre">|</span> <span class="pre">BORDER_ISOLATED</span></tt>.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a></p>
</div>
</div>
<div class="section" id="createboxfilter">
<h2>createBoxFilter<a class="headerlink" href="#createboxfilter" title="Permalink to this headline">¶</a></h2>
<p>Returns a box filter engine.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;FilterEngine&gt; <tt class="descname">createBoxFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>dstType</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1), bool <strong>normalize</strong>=true, int <strong>borderType</strong>=BORDER_DEFAULT<big>)</big><a class="headerlink" href="#Ptr<FilterEngine> createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseRowFilter&gt; <tt class="descname">getRowSumFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>sumType</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1<big>)</big><a class="headerlink" href="#Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType, int ksize, int anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseColumnFilter&gt; <tt class="descname">getColumnSumFilter</tt><big>(</big>int <strong>sumType</strong>, int <strong>dstType</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1, double <strong>scale</strong>=1<big>)</big><a class="headerlink" href="#Ptr<BaseColumnFilter> getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source image type.</li>
<li><strong>sumType</strong> &#8211; Intermediate horizontal sum type that must have as many channels as  <tt class="docutils literal"><span class="pre">srcType</span></tt> .</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <tt class="docutils literal"><span class="pre">srcType</span></tt> .</li>
<li><strong>ksize</strong> &#8211; Aperture size.</li>
<li><strong>anchor</strong> &#8211; Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</li>
<li><strong>normalize</strong> &#8211; Flag specifying whether the sums are normalized or not. See  <a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a> for details.</li>
<li><strong>scale</strong> &#8211; Another way to specify normalization in lower-level  <tt class="docutils literal"><span class="pre">getColumnSumFilter</span></tt> .</li>
<li><strong>borderType</strong> &#8211; Border type to use. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is a convenience function that retrieves the horizontal sum primitive filter with
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)" title="Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getRowSumFilter()</span></tt></a> , vertical sum filter with
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)" title="Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getColumnSumFilter()</span></tt></a> , constructs new
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> , and passes both of the primitive filters there. The constructed filter engine can be used for image filtering with normalized or unnormalized box filter.</p>
<p>The function itself is used by
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a> and
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a></p>
</div>
</div>
<div class="section" id="createderivfilter">
<h2>createDerivFilter<a class="headerlink" href="#createderivfilter" title="Permalink to this headline">¶</a></h2>
<p>Returns an engine for computing image derivatives.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;FilterEngine&gt; <tt class="descname">createDerivFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>dstType</strong>, int <strong>dx</strong>, int <strong>dy</strong>, int <strong>ksize</strong>, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#Ptr<FilterEngine> createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source image type.</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <tt class="docutils literal"><span class="pre">srcType</span></tt> .</li>
<li><strong>dx</strong> &#8211; Derivative order in respect of x.</li>
<li><strong>dy</strong> &#8211; Derivative order in respect of y.</li>
<li><strong>ksize</strong> &#8211; Aperture size See  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a> .</li>
<li><strong>borderType</strong> &#8211; Border type to use. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)" title="Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createDerivFilter()</span></tt></a> is a small convenience function that retrieves linear filter coefficients for computing image derivatives using
<a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a> and then creates a separable linear filter with
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a> . The function is used by
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a> and
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a>,
<a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a>,
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></tt></a>,
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a></p>
</div>
</div>
<div class="section" id="creategaussianfilter">
<h2>createGaussianFilter<a class="headerlink" href="#creategaussianfilter" title="Permalink to this headline">¶</a></h2>
<p>Returns an engine for smoothing images with the Gaussian filter.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;FilterEngine&gt; <tt class="descname">createGaussianFilter</tt><big>(</big>int <strong>type</strong>, Size <strong>ksize</strong>, double <strong>sigma1</strong>, double <strong>sigma2</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#Ptr<FilterEngine> createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> &#8211; Source and destination image type.</li>
<li><strong>ksize</strong> &#8211; Aperture size. See  <a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></tt></a> .</li>
<li><strong>sigma1</strong> &#8211; Gaussian sigma in the horizontal direction. See  <a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></tt></a> .</li>
<li><strong>sigma2</strong> &#8211; Gaussian sigma in the vertical direction. If 0, then  <img class="math" src="../../../_images/math/dd1c9db63c3e4e55f39a1f19a6dd77179cdbe104.png" alt="\texttt{sigma2}\leftarrow\texttt{sigma1}"/> .</li>
<li><strong>borderType</strong> &#8211; Border type to use. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)" title="Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createGaussianFilter()</span></tt></a> computes Gaussian kernel coefficients and then returns a separable linear filter for that kernel. The function is used by
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a> . Note that while the function takes just one data type, both for input and output, you can pass this limitation by calling
<a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></tt></a> and then
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a> directly.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a>,
<a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a></p>
</div>
</div>
<div class="section" id="createlinearfilter">
<h2>createLinearFilter<a class="headerlink" href="#createlinearfilter" title="Permalink to this headline">¶</a></h2>
<p>Creates a non-separable linear filter engine.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;FilterEngine&gt; <tt class="descname">createLinearFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>dstType</strong>, InputArray <strong>kernel</strong>, Point <strong>_anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>rowBorderType</strong>=BORDER_DEFAULT, int <strong>columnBorderType</strong>=-1, const Scalar&amp; <strong>borderValue</strong>=Scalar() <big>)</big><a class="headerlink" href="#Ptr<FilterEngine> createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseFilter&gt; getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseFilter&gt; <tt class="descname">getLinearFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>dstType</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>bits</strong>=0<big>)</big><a class="headerlink" href="#Ptr<BaseFilter> getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source image type.</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <tt class="docutils literal"><span class="pre">srcType</span></tt> .</li>
<li><strong>kernel</strong> &#8211; 2D array of filter coefficients.</li>
<li><strong>anchor</strong> &#8211; Anchor point within the kernel. Special value  <tt class="docutils literal"><span class="pre">Point(-1,-1)</span></tt>  means that the anchor is at the kernel center.</li>
<li><strong>delta</strong> &#8211; Value added to the filtered results before storing them.</li>
<li><strong>bits</strong> &#8211; Number of the fractional bits. The parameter is used when the kernel is an integer matrix representing fixed-point filter coefficients.</li>
<li><strong>rowBorderType</strong> &#8211; Pixel extrapolation method in the vertical direction. For details, see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a>.</li>
<li><strong>columnBorderType</strong> &#8211; Pixel extrapolation method in the horizontal direction.</li>
<li><strong>borderValue</strong> &#8211; Border value used in case of a constant border.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns a pointer to a 2D linear filter for the specified kernel, the source array type, and the destination array type. The function is a higher-level function that calls <tt class="docutils literal"><span class="pre">getLinearFilter</span></tt> and passes the retrieved 2D filter to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> constructor.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a></p>
</div>
</div>
<div class="section" id="createmorphologyfilter">
<h2>createMorphologyFilter<a class="headerlink" href="#createmorphologyfilter" title="Permalink to this headline">¶</a></h2>
<p>Creates an engine for non-separable morphological operations.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;FilterEngine&gt; <tt class="descname">createMorphologyFilter</tt><big>(</big>int <strong>op</strong>, int <strong>type</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>rowBorderType</strong>=BORDER_CONSTANT, int <strong>columnBorderType</strong>=-1, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <big>)</big><a class="headerlink" href="#Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseFilter&gt; getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseFilter&gt; <tt class="descname">getMorphologyFilter</tt><big>(</big>int <strong>op</strong>, int <strong>type</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1) <big>)</big><a class="headerlink" href="#Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseRowFilter&gt; getMorphologyRowFilter(int op, int type, int ksize, int anchor)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseRowFilter&gt; <tt class="descname">getMorphologyRowFilter</tt><big>(</big>int <strong>op</strong>, int <strong>type</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1 <big>)</big><a class="headerlink" href="#Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseColumnFilter&gt; getMorphologyColumnFilter(int op, int type, int ksize, int anchor)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseColumnFilter&gt; <tt class="descname">getMorphologyColumnFilter</tt><big>(</big>int <strong>op</strong>, int <strong>type</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1 <big>)</big><a class="headerlink" href="#Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Scalar morphologyDefaultBorderValue()">
<strong>C++:</strong><tt class="descname"> </tt>Scalar <tt class="descname">morphologyDefaultBorderValue</tt><big>(</big><big>)</big><a class="headerlink" href="#Scalar morphologyDefaultBorderValue()" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>op</strong> &#8211; Morphology operation ID,  <tt class="docutils literal"><span class="pre">MORPH_ERODE</span></tt>  or  <tt class="docutils literal"><span class="pre">MORPH_DILATE</span></tt> .</li>
<li><strong>type</strong> &#8211; Input/output image type. The number of channels can be arbitrary. The depth should be one of <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16S</span></tt>,  <tt class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></tt>.</li>
<li><strong>kernel</strong> &#8211; 2D 8-bit structuring element for a morphological operation. Non-zero elements indicate the pixels that belong to the element.</li>
<li><strong>ksize</strong> &#8211; Horizontal or vertical structuring element size for separable morphological operations.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the structuring element. Negative values mean that the anchor is at the kernel center.</li>
<li><strong>rowBorderType</strong> &#8211; Pixel extrapolation method in the vertical direction. For details, see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a>.</li>
<li><strong>columnBorderType</strong> &#8211; Pixel extrapolation method in the horizontal direction.</li>
<li><strong>borderValue</strong> &#8211; Border value in case of a constant border. The default value,   <tt class="docutils literal"><span class="pre">morphologyDefaultBorderValue</span></tt> , has a special meaning. It is transformed  <img class="math" src="../../../_images/math/8395ffd7fd9152687dbf5272cbb73294b3b52615.png" alt="+\inf"/>  for the erosion and to  <img class="math" src="../../../_images/math/e1b7928b9f62af38ffcb69c44d8f32c60d24114d.png" alt="-\inf"/>  for the dilation, which means that the minimum (maximum) is effectively computed only over the pixels that are inside the image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions construct primitive morphological filtering operations or a filter engine based on them. Normally it is enough to use
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a> or even higher-level
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></tt></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></tt></a> , or
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></tt></a> .
Note that
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a> analyzes the structuring element shape and builds a separable morphological filter engine when the structuring element is square.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></tt></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></tt></a>,
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></tt></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a></p>
</div>
</div>
<div class="section" id="createseparablelinearfilter">
<h2>createSeparableLinearFilter<a class="headerlink" href="#createseparablelinearfilter" title="Permalink to this headline">¶</a></h2>
<p>Creates an engine for a separable linear filter.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;FilterEngine&gt; <tt class="descname">createSeparableLinearFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>dstType</strong>, InputArray <strong>rowKernel</strong>, InputArray <strong>columnKernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>rowBorderType</strong>=BORDER_DEFAULT, int <strong>columnBorderType</strong>=-1, const Scalar&amp; <strong>borderValue</strong>=Scalar() <big>)</big><a class="headerlink" href="#Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseColumnFilter&gt; getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseColumnFilter&gt; <tt class="descname">getLinearColumnFilter</tt><big>(</big>int <strong>bufType</strong>, int <strong>dstType</strong>, InputArray <strong>kernel</strong>, int <strong>anchor</strong>, int <strong>symmetryType</strong>, double <strong>delta</strong>=0, int <strong>bits</strong>=0 <big>)</big><a class="headerlink" href="#Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseRowFilter&gt; getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BaseRowFilter&gt; <tt class="descname">getLinearRowFilter</tt><big>(</big>int <strong>srcType</strong>, int <strong>bufType</strong>, InputArray <strong>kernel</strong>, int <strong>anchor</strong>, int <strong>symmetryType</strong><big>)</big><a class="headerlink" href="#Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source array type.</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <tt class="docutils literal"><span class="pre">srcType</span></tt> .</li>
<li><strong>bufType</strong> &#8211; Intermediate buffer type that must have as many channels as  <tt class="docutils literal"><span class="pre">srcType</span></tt> .</li>
<li><strong>rowKernel</strong> &#8211; Coefficients for filtering each row.</li>
<li><strong>columnKernel</strong> &#8211; Coefficients for filtering each column.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the kernel. Negative values mean that anchor is positioned at the aperture center.</li>
<li><strong>delta</strong> &#8211; Value added to the filtered results before storing them.</li>
<li><strong>bits</strong> &#8211; Number of the fractional bits. The parameter is used when the kernel is an integer matrix representing fixed-point filter coefficients.</li>
<li><strong>rowBorderType</strong> &#8211; Pixel extrapolation method in the vertical direction. For details, see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a>.</li>
<li><strong>columnBorderType</strong> &#8211; Pixel extrapolation method in the horizontal direction.</li>
<li><strong>borderValue</strong> &#8211; Border value used in case of a constant border.</li>
<li><strong>symmetryType</strong> &#8211; Type of each row and column kernel. See  <a class="reference internal" href="#int getKernelType(InputArray kernel, Point anchor)" title="int getKernelType(InputArray kernel, Point anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getKernelType()</span></tt></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions construct primitive separable linear filtering operations or a filter engine based on them. Normally it is enough to use
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a> or even higher-level
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a> . The function
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a> is smart enough to figure out the <tt class="docutils literal"><span class="pre">symmetryType</span></tt> for each of the two kernels, the intermediate <tt class="docutils literal"><span class="pre">bufType</span></tt>  and, if filtering can be done in integer arithmetics, the number of <tt class="docutils literal"><span class="pre">bits</span></tt> to encode the filter coefficients. If it does not work for you, it is possible to call <tt class="docutils literal"><span class="pre">getLinearColumnFilter</span></tt>,``getLinearRowFilter`` directly and then pass them to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a> constructor.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></tt></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><tt class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></tt></a>,
<a class="reference internal" href="#int getKernelType(InputArray kernel, Point anchor)" title="int getKernelType(InputArray kernel, Point anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getKernelType()</span></tt></a></p>
</div>
</div>
<div class="section" id="dilate">
<h2>dilate<a class="headerlink" href="#dilate" title="Permalink to this headline">¶</a></h2>
<p>Dilates an image by using a specific structuring element.</p>
<dl class="function">
<dt id="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">dilate</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>iterations</strong>=1, int <strong>borderType</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <big>)</big><a class="headerlink" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.dilate">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">dilate</tt><big>(</big>src, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, iterations<span class="optional">[</span>, borderType<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.dilate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDilate(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvDilate</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, IplConvKernel* <strong>element</strong>=NULL, int <strong>iterations</strong>=1 <big>)</big><a class="headerlink" href="#void cvDilate(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Dilate">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Dilate</tt><big>(</big>src, dst, element=None, iterations=1<big>)</big> &rarr; None<a class="headerlink" href="#cv.Dilate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; the number of channels can be arbitrary, but the depth should be one of <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16S</span></tt>,  <tt class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></tt>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>element</strong> &#8211; structuring element used for dilation; if  <tt class="docutils literal"><span class="pre">element=Mat()</span></tt> , a  <tt class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">3</span></tt> rectangular structuring element is used.</li>
<li><strong>anchor</strong> &#8211; position of the anchor within the element; default value <tt class="docutils literal"><span class="pre">(-1,</span> <span class="pre">-1)</span></tt> means that the anchor is at the element center.</li>
<li><strong>iterations</strong> &#8211; number of times dilation is applied.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details).</li>
<li><strong>borderValue</strong> &#8211; border value in case of a constant border (see  <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken:</p>
<div class="math">
<p><img src="../../../_images/math/07c9cfd0cca27e895762c6b637b061b8c92c35df.png" alt="\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')"/></p>
</div><p>The function supports the in-place mode. Dilation can be applied several ( <tt class="docutils literal"><span class="pre">iterations</span></tt> ) times. In case of multi-channel images, each channel is processed independently.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></tt></a>,
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the morphological dilate operation can be found at opencv_source_code/samples/cpp/morphology2.cpp</li>
</ul>
</div>
</div>
<div class="section" id="erode">
<h2>erode<a class="headerlink" href="#erode" title="Permalink to this headline">¶</a></h2>
<p>Erodes an image by using a specific structuring element.</p>
<dl class="function">
<dt id="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">erode</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>iterations</strong>=1, int <strong>borderType</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <big>)</big><a class="headerlink" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.erode">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">erode</tt><big>(</big>src, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, iterations<span class="optional">[</span>, borderType<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.erode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvErode(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvErode</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, IplConvKernel* <strong>element</strong>=NULL, int <strong>iterations</strong>=1<big>)</big><a class="headerlink" href="#void cvErode(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Erode">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Erode</tt><big>(</big>src, dst, element=None, iterations=1<big>)</big> &rarr; None<a class="headerlink" href="#cv.Erode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; the number of channels can be arbitrary, but the depth should be one of <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16S</span></tt>,  <tt class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></tt>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>element</strong> &#8211; structuring element used for erosion; if  <tt class="docutils literal"><span class="pre">element=Mat()</span></tt> , a  <tt class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">3</span></tt>  rectangular structuring element is used.</li>
<li><strong>anchor</strong> &#8211; position of the anchor within the element; default value  <tt class="docutils literal"><span class="pre">(-1,</span> <span class="pre">-1)</span></tt>  means that the anchor is at the element center.</li>
<li><strong>iterations</strong> &#8211; number of times erosion is applied.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details).</li>
<li><strong>borderValue</strong> &#8211; border value in case of a constant border (see <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<div class="math">
<p><img src="../../../_images/math/64ec98ad393bb6e908b741cad0d790207eacf5a5.png" alt="\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')"/></p>
</div><p>The function supports the in-place mode. Erosion can be applied several ( <tt class="docutils literal"><span class="pre">iterations</span></tt> ) times. In case of multi-channel images, each channel is processed independently.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></tt></a>,
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the morphological erode operation can be found at opencv_source_code/samples/cpp/morphology2.cpp</li>
</ul>
</div>
</div>
<div class="section" id="filter2d">
<h2>filter2D<a class="headerlink" href="#filter2d" title="Permalink to this headline">¶</a></h2>
<p>Convolves an image with the kernel.</p>
<dl class="function">
<dt id="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">filter2D</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.filter2D">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">filter2D</tt><big>(</big>src, ddepth, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.filter2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvFilter2D</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>kernel</strong>, CvPoint <strong>anchor</strong>=cvPoint(-1,-1) <big>)</big><a class="headerlink" href="#void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Filter2D">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Filter2D</tt><big>(</big>src, dst, kernel, anchor=(-1, -1)<big>)</big> &rarr; None<a class="headerlink" href="#cv.Filter2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and the same number of channels as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ddepth</strong> &#8211; <dl class="docutils">
<dt>desired depth of the destination image; if it is negative, it will be the same as <tt class="docutils literal"><span class="pre">src.depth()</span></tt>; the following combinations of <tt class="docutils literal"><span class="pre">src.depth()</span></tt> and <tt class="docutils literal"><span class="pre">ddepth</span></tt> are supported:</dt>
<dd><ul class="first last">
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_16S</span></tt>/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_16U</span></tt>/<tt class="docutils literal"><span class="pre">CV_16S</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_32F</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_64F</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
</ul>
</dd>
</dl>
<p>when <tt class="docutils literal"><span class="pre">ddepth=-1</span></tt>, the output image will have the same depth as the source.</p>
</li>
<li><strong>kernel</strong> &#8211; convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using  <a class="reference internal" href="../../core/doc/operations_on_arrays.html#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></tt></a>  and process them individually.</li>
<li><strong>anchor</strong> &#8211; anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.</li>
<li><strong>delta</strong> &#8211; optional value added to the filtered pixels before storing them in <tt class="docutils literal"><span class="pre">dst</span></tt>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p>
<p>The function does actually compute correlation, not the convolution:</p>
<div class="math">
<p><img src="../../../_images/math/b4fbb9f6b173f5a947f03d4e97132db5baa66ec6.png" alt="\texttt{dst} (x,y) =  \sum _{ \stackrel{0\leq x' &lt; \texttt{kernel.cols},}{0\leq y' &lt; \texttt{kernel.rows}} }  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )"/></p>
</div><p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void flip(InputArray src, OutputArray dst, int flipCode)" title="void flip(InputArray src, OutputArray dst, int flipCode)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">flip()</span></tt></a> and set the new anchor to <tt class="docutils literal"><span class="pre">(kernel.cols</span> <span class="pre">-</span> <span class="pre">anchor.x</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">kernel.rows</span> <span class="pre">-</span> <span class="pre">anchor.y</span> <span class="pre">-</span> <span class="pre">1)</span></tt> .</p>
<p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~``11 x 11`` or larger) and the direct algorithm (that uses the engine retrieved by <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></tt></a> ) for small kernels.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></tt></a>,
<a class="reference internal" href="object_detection.html#void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)" title="void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">matchTemplate()</span></tt></a></p>
</div>
</div>
<div class="section" id="gaussianblur">
<h2>GaussianBlur<a class="headerlink" href="#gaussianblur" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using a Gaussian filter.</p>
<dl class="function">
<dt id="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">GaussianBlur</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>ksize</strong>, double <strong>sigmaX</strong>, double <strong>sigmaY</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.GaussianBlur">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">GaussianBlur</tt><big>(</big>src, ksize, sigmaX<span class="optional">[</span>, dst<span class="optional">[</span>, sigmaY<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.GaussianBlur" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; the image can have any number of channels, which are processed independently, but the depth should be <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16S</span></tt>, <tt class="docutils literal"><span class="pre">CV_32F</span></tt> or <tt class="docutils literal"><span class="pre">CV_64F</span></tt>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ksize</strong> &#8211; Gaussian kernel size.  <tt class="docutils literal"><span class="pre">ksize.width</span></tt>  and  <tt class="docutils literal"><span class="pre">ksize.height</span></tt>  can differ but they both must be positive and odd. Or, they can be zero&#8217;s and then they are computed from  <tt class="docutils literal"><span class="pre">sigma*</span></tt> .</li>
<li><strong>sigmaX</strong> &#8211; Gaussian kernel standard deviation in X direction.</li>
<li><strong>sigmaY</strong> &#8211; Gaussian kernel standard deviation in Y direction; if  <tt class="docutils literal"><span class="pre">sigmaY</span></tt>  is zero, it is set to be equal to  <tt class="docutils literal"><span class="pre">sigmaX</span></tt>, if both sigmas are zeros, they are computed from  <tt class="docutils literal"><span class="pre">ksize.width</span></tt>  and  <tt class="docutils literal"><span class="pre">ksize.height</span></tt> , respectively (see  <a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></tt></a> for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of <tt class="docutils literal"><span class="pre">ksize</span></tt>, <tt class="docutils literal"><span class="pre">sigmaX</span></tt>, and <tt class="docutils literal"><span class="pre">sigmaY</span></tt>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a>,
<a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></tt></a>,
<a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></tt></a></p>
</div>
</div>
<div class="section" id="getderivkernels">
<h2>getDerivKernels<a class="headerlink" href="#getderivkernels" title="Permalink to this headline">¶</a></h2>
<p>Returns filter coefficients for computing spatial image derivatives.</p>
<dl class="function">
<dt id="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">getDerivKernels</tt><big>(</big>OutputArray <strong>kx</strong>, OutputArray <strong>ky</strong>, int <strong>dx</strong>, int <strong>dy</strong>, int <strong>ksize</strong>, bool <strong>normalize</strong>=false, int <strong>ktype</strong>=CV_32F <big>)</big><a class="headerlink" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getDerivKernels">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getDerivKernels</tt><big>(</big>dx, dy, ksize<span class="optional">[</span>, kx<span class="optional">[</span>, ky<span class="optional">[</span>, normalize<span class="optional">[</span>, ktype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; kx, ky<a class="headerlink" href="#cv2.getDerivKernels" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kx</strong> &#8211; Output matrix of row filter coefficients. It has the type  <tt class="docutils literal"><span class="pre">ktype</span></tt> .</li>
<li><strong>ky</strong> &#8211; Output matrix of column filter coefficients. It has the type  <tt class="docutils literal"><span class="pre">ktype</span></tt> .</li>
<li><strong>dx</strong> &#8211; Derivative order in respect of x.</li>
<li><strong>dy</strong> &#8211; Derivative order in respect of y.</li>
<li><strong>ksize</strong> &#8211; Aperture size. It can be  <tt class="docutils literal"><span class="pre">CV_SCHARR</span></tt> , 1, 3, 5, or 7.</li>
<li><strong>normalize</strong> &#8211; Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator  <img class="math" src="../../../_images/math/5275ad994c6bbf00b138a583d217cd73b8eae957.png" alt="=2^{ksize*2-dx-dy-2}"/> . If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set  <tt class="docutils literal"><span class="pre">normalize=false</span></tt> .</li>
<li><strong>ktype</strong> &#8211; Type of filter coefficients. It can be  <tt class="docutils literal"><span class="pre">CV_32f</span></tt>  or  <tt class="docutils literal"><span class="pre">CV_64F</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns the filter coefficients for spatial image derivatives. When <tt class="docutils literal"><span class="pre">ksize=CV_SCHARR</span></tt> , the Scharr
<img class="math" src="../../../_images/math/d278803d72fcc493afb1559174a483aa7f41d143.png" alt="3 \times 3"/> kernels are generated (see
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></tt></a> ). Otherwise, Sobel kernels are generated (see
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a> ). The filters are normally passed to
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a> or to
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a> .</p>
</div>
<div class="section" id="getgaussiankernel">
<h2>getGaussianKernel<a class="headerlink" href="#getgaussiankernel" title="Permalink to this headline">¶</a></h2>
<p>Returns Gaussian filter coefficients.</p>
<dl class="function">
<dt id="Mat getGaussianKernel(int ksize, double sigma, int ktype)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getGaussianKernel</tt><big>(</big>int <strong>ksize</strong>, double <strong>sigma</strong>, int <strong>ktype</strong>=CV_64F <big>)</big><a class="headerlink" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getGaussianKernel">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getGaussianKernel</tt><big>(</big>ksize, sigma<span class="optional">[</span>, ktype<span class="optional">]</span><big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getGaussianKernel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ksize</strong> &#8211; Aperture size. It should be odd ( <img class="math" src="../../../_images/math/091d406a3ab6146e1fea3ca1b7b6598d5d6c0d8f.png" alt="\texttt{ksize} \mod 2 = 1"/> ) and positive.</li>
<li><strong>sigma</strong> &#8211; Gaussian standard deviation. If it is non-positive, it is computed from  <tt class="docutils literal"><span class="pre">ksize</span></tt>  as  <tt class="docutils literal"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">0.3*((ksize-1)*0.5</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">0.8</span></tt> .</li>
<li><strong>ktype</strong> &#8211; Type of filter coefficients. It can be  <tt class="docutils literal"><span class="pre">CV_32f</span></tt>  or  <tt class="docutils literal"><span class="pre">CV_64F</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns the
<img class="math" src="../../../_images/math/8efdba1f8ac27e903f86de5afbf4a806d5be0c40.png" alt="\texttt{ksize} \times 1"/> matrix of Gaussian filter coefficients:</p>
<div class="math">
<p><img src="../../../_images/math/11190bc8492c4440ffa39bdde58d6130ecd95b65.png" alt="G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma} )^2},"/></p>
</div><p>where
<img class="math" src="../../../_images/math/db2f171d360b22ed4b05a26534c8adc2d097b02e.png" alt="i=0..\texttt{ksize}-1"/> and
<img class="math" src="../../../_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha"/> is the scale factor chosen so that
<img class="math" src="../../../_images/math/805c0243c96c2840bee45745648d570fb2a054e8.png" alt="\sum_i G_i=1"/>.</p>
<p>Two of such generated kernels can be passed to
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a> or to
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a>. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a>.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a>,
<a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a>,
<a class="reference internal" href="#Mat getStructuringElement(int shape, Size ksize, Point anchor)" title="Mat getStructuringElement(int shape, Size ksize, Point anchor)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getStructuringElement()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a></p>
</div>
</div>
<div class="section" id="getkerneltype">
<h2>getKernelType<a class="headerlink" href="#getkerneltype" title="Permalink to this headline">¶</a></h2>
<p>Returns the kernel type.</p>
<dl class="function">
<dt id="int getKernelType(InputArray kernel, Point anchor)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">getKernelType</tt><big>(</big>InputArray <strong>kernel</strong>, Point <strong>anchor</strong><big>)</big><a class="headerlink" href="#int getKernelType(InputArray kernel, Point anchor)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kernel</strong> &#8211; 1D array of the kernel coefficients to analyze.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the kernel.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function analyzes the kernel coefficients and returns the corresponding kernel type:</p>
<blockquote>
<div><ul class="simple">
<li><strong>KERNEL_GENERAL</strong> The kernel is generic. It is used when there is no any type of symmetry or other properties.</li>
<li><strong>KERNEL_SYMMETRICAL</strong> The kernel is symmetrical:  <img class="math" src="../../../_images/math/fc8278a6ce430e45e0e5be0cead6ca3e7218c036.png" alt="\texttt{kernel}_i == \texttt{kernel}_{ksize-i-1}"/> , and the anchor is at the center.</li>
<li><strong>KERNEL_ASYMMETRICAL</strong> The kernel is asymmetrical:  <img class="math" src="../../../_images/math/1b4154b9c765a431e63c74bb60568f5612b504cf.png" alt="\texttt{kernel}_i == -\texttt{kernel}_{ksize-i-1}"/> , and the anchor is at the center.</li>
<li><strong>KERNEL_SMOOTH</strong> All the kernel elements are non-negative and summed to 1. For example, the Gaussian kernel is both smooth kernel and symmetrical, so the function returns  <tt class="docutils literal"><span class="pre">KERNEL_SMOOTH</span> <span class="pre">|</span> <span class="pre">KERNEL_SYMMETRICAL</span></tt> .</li>
<li><strong>KERNEL_INTEGER</strong> All the kernel coefficients are integer numbers. This flag can be combined with  <tt class="docutils literal"><span class="pre">KERNEL_SYMMETRICAL</span></tt>  or  <tt class="docutils literal"><span class="pre">KERNEL_ASYMMETRICAL</span></tt> .</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="getstructuringelement">
<h2>getStructuringElement<a class="headerlink" href="#getstructuringelement" title="Permalink to this headline">¶</a></h2>
<p>Returns a structuring element of the specified size and shape for morphological operations.</p>
<dl class="function">
<dt id="Mat getStructuringElement(int shape, Size ksize, Point anchor)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">getStructuringElement</tt><big>(</big>int <strong>shape</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1)<big>)</big><a class="headerlink" href="#Mat getStructuringElement(int shape, Size ksize, Point anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getStructuringElement">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getStructuringElement</tt><big>(</big>shape, ksize<span class="optional">[</span>, anchor<span class="optional">]</span><big>)</big> &rarr; retval<a class="headerlink" href="#cv2.getStructuringElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values)">
<strong>C:</strong><tt class="descname"> </tt>IplConvKernel* <tt class="descname">cvCreateStructuringElementEx</tt><big>(</big>int <strong>cols</strong>, int <strong>rows</strong>, int <strong>anchor_x</strong>, int <strong>anchor_y</strong>, int <strong>shape</strong>, int* <strong>values</strong>=NULL <big>)</big><a class="headerlink" href="#IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateStructuringElementEx">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">CreateStructuringElementEx</tt><big>(</big>cols, rows, anchorX, anchorY, shape, values=None<big>)</big> &rarr; kernel<a class="headerlink" href="#cv.CreateStructuringElementEx" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; <p>Element shape that could be one of the following:</p>
<ul>
<li><strong>MORPH_RECT</strong>         - a rectangular structuring element:<div class="math">
<p><img src="../../../_images/math/8e98ec0adad5d21e9a5607e42466e4b04ea9ac53.png" alt="E_{ij}=1"/></p>
</div></li>
<li><strong>MORPH_ELLIPSE</strong>         - an elliptic structuring element, that is, a filled ellipse inscribed into the rectangle <tt class="docutils literal"><span class="pre">Rect(0,</span> <span class="pre">0,</span> <span class="pre">esize.width,</span> <span class="pre">0.esize.height)</span></tt></li>
<li><strong>MORPH_CROSS</strong>         - a cross-shaped structuring element:<div class="math">
<p><img src="../../../_images/math/7123f3cfc96da06673e5f4a4667ea5ea06458bbe.png" alt="E_{ij} =  \fork{1}{if i=\texttt{anchor.y} or j=\texttt{anchor.x}}{0}{otherwise}"/></p>
</div></li>
<li><strong>CV_SHAPE_CUSTOM</strong>     - custom structuring element (OpenCV 1.x API)</li>
</ul>
</li>
<li><strong>ksize</strong> &#8211; Size of the structuring element.</li>
<li><strong>cols</strong> &#8211; Width of the structuring element</li>
<li><strong>rows</strong> &#8211; Height of the structuring element</li>
<li><strong>anchor</strong> &#8211; Anchor position within the element. The default value  <img class="math" src="../../../_images/math/6155e28d15217ab6e8ea537771fdce74d647ed6e.png" alt="(-1, -1)"/>  means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</li>
<li><strong>anchor_x</strong> &#8211; x-coordinate of the anchor</li>
<li><strong>anchor_y</strong> &#8211; y-coordinate of the anchor</li>
<li><strong>values</strong> &#8211; integer array of <tt class="docutils literal"><span class="pre">cols``*``rows</span></tt> elements that specifies the custom shape of the structuring element, when <tt class="docutils literal"><span class="pre">shape=CV_SHAPE_CUSTOM</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function constructs and returns the structuring element that can be further passed to
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a>,
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></tt></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></tt></a> or
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></tt></a> . But you can also construct an arbitrary binary mask yourself and use it as the structuring element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using OpenCV 1.x C API, the created structuring element <tt class="docutils literal"><span class="pre">IplConvKernel*</span> <span class="pre">element</span></tt> must be released in the end using <tt class="docutils literal"><span class="pre">cvReleaseStructuringElement(&amp;element)</span></tt>.</p>
</div>
</div>
<div class="section" id="medianblur">
<h2>medianBlur<a class="headerlink" href="#medianblur" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using the median filter.</p>
<dl class="function">
<dt id="void medianBlur(InputArray src, OutputArray dst, int ksize)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">medianBlur</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ksize</strong><big>)</big><a class="headerlink" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.medianBlur">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">medianBlur</tt><big>(</big>src, ksize<span class="optional">[</span>, dst<span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.medianBlur" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input 1-, 3-, or 4-channel image; when  <tt class="docutils literal"><span class="pre">ksize</span></tt>  is 3 or 5, the image depth should be <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, or <tt class="docutils literal"><span class="pre">CV_32F</span></tt>, for larger aperture sizes, it can only be <tt class="docutils literal"><span class="pre">CV_8U</span></tt>.</li>
<li><strong>dst</strong> &#8211; destination array of the same size and type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ksize</strong> &#8211; aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smoothes an image using the median filter with the
<img class="math" src="../../../_images/math/e5e433136f4cc9f409bfbb973054e37b7ddb7192.png" alt="\texttt{ksize} \times \texttt{ksize}"/> aperture. Each channel of a multi-channel image is processed independently. In-place operation is supported.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></tt></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a></p>
</div>
</div>
<div class="section" id="morphologyex">
<h2>morphologyEx<a class="headerlink" href="#morphologyex" title="Permalink to this headline">¶</a></h2>
<p>Performs advanced morphological transformations.</p>
<dl class="function">
<dt id="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">morphologyEx</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>op</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>iterations</strong>=1, int <strong>borderType</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <big>)</big><a class="headerlink" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.morphologyEx">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">morphologyEx</tt><big>(</big>src, op, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, iterations<span class="optional">[</span>, borderType<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.morphologyEx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvMorphologyEx</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvArr* <strong>temp</strong>, IplConvKernel* <strong>element</strong>, int <strong>operation</strong>, int <strong>iterations</strong>=1 <big>)</big><a class="headerlink" href="#void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MorphologyEx">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">MorphologyEx</tt><big>(</big>src, dst, temp, element, operation, iterations=1<big>)</big> &rarr; None<a class="headerlink" href="#cv.MorphologyEx" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image. The number of channels can be arbitrary. The depth should be one of <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16U</span></tt>, <tt class="docutils literal"><span class="pre">CV_16S</span></tt>,  <tt class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></tt>.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>element</strong> &#8211; Structuring element.</li>
<li><strong>op</strong> &#8211; <p>Type of a morphological operation that can be one of the following:</p>
<ul>
<li><strong>MORPH_OPEN</strong> - an opening operation</li>
<li><strong>MORPH_CLOSE</strong> - a closing operation</li>
<li><strong>MORPH_GRADIENT</strong> - a morphological gradient</li>
<li><strong>MORPH_TOPHAT</strong> - &#8220;top hat&#8221;</li>
<li><strong>MORPH_BLACKHAT</strong> - &#8220;black hat&#8221;</li>
</ul>
</li>
<li><strong>iterations</strong> &#8211; Number of times erosion and dilation are applied.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details.</li>
<li><strong>borderValue</strong> &#8211; Border value in case of a constant border. The default value has a special meaning. See  <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Opening operation:</p>
<div class="math">
<p><img src="../../../_images/math/85e0a3b0b4bad14b8d825dbb08e9c98a77e18325.png" alt="\texttt{dst} = \mathrm{open} ( \texttt{src} , \texttt{element} )= \mathrm{dilate} ( \mathrm{erode} ( \texttt{src} , \texttt{element} ))"/></p>
</div><p>Closing operation:</p>
<div class="math">
<p><img src="../../../_images/math/1979734ad381c5ef37f7ba40cfc70566b6c03369.png" alt="\texttt{dst} = \mathrm{close} ( \texttt{src} , \texttt{element} )= \mathrm{erode} ( \mathrm{dilate} ( \texttt{src} , \texttt{element} ))"/></p>
</div><p>Morphological gradient:</p>
<div class="math">
<p><img src="../../../_images/math/63858fbf864f6b38674e2b75b6c3a504ee8d3730.png" alt="\texttt{dst} = \mathrm{morph\_grad} ( \texttt{src} , \texttt{element} )= \mathrm{dilate} ( \texttt{src} , \texttt{element} )- \mathrm{erode} ( \texttt{src} , \texttt{element} )"/></p>
</div><p>&#8220;Top hat&#8221;:</p>
<div class="math">
<p><img src="../../../_images/math/de0eb3c059d4fe185917d5ae4ed383e61c36e76b.png" alt="\texttt{dst} = \mathrm{tophat} ( \texttt{src} , \texttt{element} )= \texttt{src} - \mathrm{open} ( \texttt{src} , \texttt{element} )"/></p>
</div><p>&#8220;Black hat&#8221;:</p>
<div class="math">
<p><img src="../../../_images/math/02da5354ed3169501e31a5e9ab33f3d3311569f6.png" alt="\texttt{dst} = \mathrm{blackhat} ( \texttt{src} , \texttt{element} )= \mathrm{close} ( \texttt{src} , \texttt{element} )- \texttt{src}"/></p>
</div><p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></tt></a>,
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></tt></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the morphologyEx function for the morphological opening and closing operations can be found at opencv_source_code/samples/cpp/morphology2.cpp</li>
</ul>
</div>
</div>
<div class="section" id="laplacian">
<h2>Laplacian<a class="headerlink" href="#laplacian" title="Permalink to this headline">¶</a></h2>
<p>Calculates the Laplacian of an image.</p>
<dl class="function">
<dt id="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">Laplacian</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, int <strong>ksize</strong>=1, double <strong>scale</strong>=1, double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Laplacian">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">Laplacian</tt><big>(</big>src, ddepth<span class="optional">[</span>, dst<span class="optional">[</span>, ksize<span class="optional">[</span>, scale<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.Laplacian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvLaplace(const CvArr* src, CvArr* dst, int aperture_size)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvLaplace</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>aperture_size</strong>=3 <big>)</big><a class="headerlink" href="#void cvLaplace(const CvArr* src, CvArr* dst, int aperture_size)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Laplace">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Laplace</tt><big>(</big>src, dst, apertureSize=3<big>)</big> &rarr; None<a class="headerlink" href="#cv.Laplace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and the same number of channels as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>ddepth</strong> &#8211; Desired depth of the destination image.</li>
<li><strong>ksize</strong> &#8211; Aperture size used to compute the second-derivative filters. See  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a> for details. The size must be positive and odd.</li>
<li><strong>scale</strong> &#8211; Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a> for details.</li>
<li><strong>delta</strong> &#8211; Optional delta value that is added to the results prior to storing them in  <tt class="docutils literal"><span class="pre">dst</span></tt> .</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<div class="math">
<p><img src="../../../_images/math/b1873bdbd97ad13406fd470230dafc8b00683d8b.png" alt="\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}"/></p>
</div><p>This is done when <tt class="docutils literal"><span class="pre">ksize</span> <span class="pre">&gt;</span> <span class="pre">1</span></tt> . When <tt class="docutils literal"><span class="pre">ksize</span> <span class="pre">==</span> <span class="pre">1</span></tt> , the Laplacian is computed by filtering the image with the following
<img class="math" src="../../../_images/math/d278803d72fcc493afb1559174a483aa7f41d143.png" alt="3 \times 3"/> aperture:</p>
<div class="math">
<p><img src="../../../_images/math/419bd3245ef1af7bbf9ba028deadba4cb9266861.png" alt="\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}"/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a>,
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></tt></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the Laplace transformation for edge detection can be found at opencv_source_code/samples/cpp/laplace.cpp</li>
</ul>
</div>
</div>
<div class="section" id="pyrdown">
<h2>pyrDown<a class="headerlink" href="#pyrdown" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image and downsamples it.</p>
<dl class="function">
<dt id="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">pyrDown</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, const Size&amp; <strong>dstsize</strong>=Size(), int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pyrDown">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">pyrDown</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, dstsize<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.pyrDown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPyrDown(const CvArr* src, CvArr* dst, int filter)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPyrDown</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>filter</strong>=CV_GAUSSIAN_5x5 <big>)</big><a class="headerlink" href="#void cvPyrDown(const CvArr* src, CvArr* dst, int filter)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PyrDown">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">PyrDown</tt><big>(</big>src, dst, filter=CV_GAUSSIAN_5X5<big>)</big> &rarr; None<a class="headerlink" href="#cv.PyrDown" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image; it has the specified size and the same type as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>dstsize</strong> &#8211; <p>size of the output image; by default, it is computed as <tt class="docutils literal"><span class="pre">Size((src.cols+1)/2,</span> <span class="pre">(src.rows+1)/2)</span></tt>, but in any case, the following conditions should be satisfied:</p>
<div class="math">
<p><img src="../../../_images/math/f1ab44981e9308163296424a1aa1d29a110a714d.png" alt="\begin{array}{l}
| \texttt{dstsize.width} *2-src.cols| \leq  2  \\ | \texttt{dstsize.height} *2-src.rows| \leq  2 \end{array}"/></p>
</div></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel:</p>
<div class="math">
<p><img src="../../../_images/math/72e776c78f4e25d4acbb62413c4b6f336d2199c2.png" alt="\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}"/></p>
</div><p>Then, it downsamples the image by rejecting even rows and columns.</p>
</div>
<div class="section" id="pyrup">
<h2>pyrUp<a class="headerlink" href="#pyrup" title="Permalink to this headline">¶</a></h2>
<p>Upsamples an image and then blurs it.</p>
<dl class="function">
<dt id="void pyrUp(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">pyrUp</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, const Size&amp; <strong>dstsize</strong>=Size(), int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void pyrUp(InputArray src, OutputArray dst, const Size& dstsize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pyrUp">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">pyrUp</tt><big>(</big>src<span class="optional">[</span>, dst<span class="optional">[</span>, dstsize<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.pyrUp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="cvPyrUp(const CvArr* src, CvArr* dst, int filter)">
<strong>C:</strong><tt class="descname"> </tt> <tt class="descname">cvPyrUp</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>filter</strong>=CV_GAUSSIAN_5x5 <big>)</big><a class="headerlink" href="#cvPyrUp(const CvArr* src, CvArr* dst, int filter)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PyrUp">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">PyrUp</tt><big>(</big>src, dst, filter=CV_GAUSSIAN_5X5<big>)</big> &rarr; None<a class="headerlink" href="#cv.PyrUp" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image. It has the specified size and the same type as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>dstsize</strong> &#8211; <p>size of the output image; by default, it is computed as <tt class="docutils literal"><span class="pre">Size(src.cols*2,</span> <span class="pre">(src.rows*2)</span></tt>, but in any case, the following conditions should be satisfied:</p>
<div class="math">
<p><img src="../../../_images/math/d8d6bc69566cf5200655b1c5a65733779ed6e113.png" alt="\begin{array}{l}
| \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}"/></p>
</div></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in
<a class="reference internal" href="#void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)" title="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">pyrDown()</span></tt></a>  multiplied by 4.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>(Python) An example of Laplacian Pyramid construction and merging can be found at opencv_source_code/samples/python2/lappyr.py</li>
</ul>
</div>
</div>
<div class="section" id="pyrmeanshiftfiltering">
<h2>pyrMeanShiftFiltering<a class="headerlink" href="#pyrmeanshiftfiltering" title="Permalink to this headline">¶</a></h2>
<p>Performs initial step of meanshift segmentation of an image.</p>
<dl class="function">
<dt id="void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">pyrMeanShiftFiltering</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, double <strong>sp</strong>, double <strong>sr</strong>, int <strong>maxLevel</strong>=1, TermCriteria <strong>termcrit</strong>=TermCriteria( TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) <big>)</big><a class="headerlink" href="#void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pyrMeanShiftFiltering">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">pyrMeanShiftFiltering</tt><big>(</big>src, sp, sr<span class="optional">[</span>, dst<span class="optional">[</span>, maxLevel<span class="optional">[</span>, termcrit<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.pyrMeanShiftFiltering" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPyrMeanShiftFiltering(const CvArr* src, CvArr* dst, double sp, double sr, int max_level, CvTermCriteria termcrit)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPyrMeanShiftFiltering</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>sp</strong>, double <strong>sr</strong>, int <strong>max_level</strong>=1, CvTermCriteria <strong>termcrit</strong>=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,5,1)<big>)</big><a class="headerlink" href="#void cvPyrMeanShiftFiltering(const CvArr* src, CvArr* dst, double sp, double sr, int max_level, CvTermCriteria termcrit)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PyrMeanShiftFiltering">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">PyrMeanShiftFiltering</tt><big>(</big>src, dst, sp, sr, max_level=1, termcrit=(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 5, 1)<big>)</big> &rarr; None<a class="headerlink" href="#cv.PyrMeanShiftFiltering" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source 8-bit, 3-channel image.</li>
<li><strong>dst</strong> &#8211; The destination image of the same format and the same size as the source.</li>
<li><strong>sp</strong> &#8211; The spatial window radius.</li>
<li><strong>sr</strong> &#8211; The color window radius.</li>
<li><strong>maxLevel</strong> &#8211; Maximum level of the pyramid for the segmentation.</li>
<li><strong>termcrit</strong> &#8211; Termination criteria: when to stop meanshift iterations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered &#8220;posterized&#8221; image with color gradients and fine-grain texture flattened. At every pixel
<tt class="docutils literal"><span class="pre">(X,Y)</span></tt> of the input image (or down-sized input image, see below) the function executes meanshift
iterations, that is, the pixel <tt class="docutils literal"><span class="pre">(X,Y)</span></tt> neighborhood in the joint space-color hyperspace is considered:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/1e1b65a60ed1f2e2cb7efde16f8766d0122792a3.png" alt="(x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}"/></p>
</div></div></blockquote>
<p>where  <tt class="docutils literal"><span class="pre">(R,G,B)</span></tt> and  <tt class="docutils literal"><span class="pre">(r,g,b)</span></tt> are the vectors of color components at <tt class="docutils literal"><span class="pre">(X,Y)</span></tt> and  <tt class="docutils literal"><span class="pre">(x,y)</span></tt>, respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value  <tt class="docutils literal"><span class="pre">(X',Y')</span></tt> and average color vector  <tt class="docutils literal"><span class="pre">(R',G',B')</span></tt> are found and they act as the neighborhood center on the next iteration:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/f77257f260fc05b5645b60d8348846148b9baa2d.png" alt="(X,Y)~(X',Y'), (R,G,B)~(R',G',B')."/></p>
</div></div></blockquote>
<p>After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration):</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/a26e77f12ced794b32cd6c0fedeecea5a2a2867d.png" alt="I(X,Y) &lt;- (R*,G*,B*)"/></p>
</div></div></blockquote>
<p>When <tt class="docutils literal"><span class="pre">maxLevel</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>, the gaussian pyramid of <tt class="docutils literal"><span class="pre">maxLevel+1</span></tt> levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than <tt class="docutils literal"><span class="pre">sr</span></tt> from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when <tt class="docutils literal"><span class="pre">maxLevel==0</span></tt>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using mean-shift image segmentation can be found at opencv_source_code/samples/cpp/meanshift_segmentation.cpp</li>
</ul>
</div>
</div>
<div class="section" id="sepfilter2d">
<h2>sepFilter2D<a class="headerlink" href="#sepfilter2d" title="Permalink to this headline">¶</a></h2>
<p>Applies a separable linear filter to an image.</p>
<dl class="function">
<dt id="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">sepFilter2D</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, InputArray <strong>kernelX</strong>, InputArray <strong>kernelY</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.sepFilter2D">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">sepFilter2D</tt><big>(</big>src, ddepth, kernelX, kernelY<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.sepFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and the same number of channels as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>ddepth</strong> &#8211; <dl class="docutils">
<dt>Destination image depth. The following combination of <tt class="docutils literal"><span class="pre">src.depth()</span></tt> and <tt class="docutils literal"><span class="pre">ddepth</span></tt> are supported:</dt>
<dd><ul class="first last">
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_16S</span></tt>/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_16U</span></tt>/<tt class="docutils literal"><span class="pre">CV_16S</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_32F</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_64F</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
</ul>
</dd>
</dl>
<p>when <tt class="docutils literal"><span class="pre">ddepth=-1</span></tt>, the destination image will have the same depth as the source.</p>
</li>
<li><strong>kernelX</strong> &#8211; Coefficients for filtering each row.</li>
<li><strong>kernelY</strong> &#8211; Coefficients for filtering each column.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the kernel. The default value  <img class="math" src="../../../_images/math/a11af309f4f98a632b52d2972cd9de92053c603c.png" alt="(-1,-1)"/>  means that the anchor is at the kernel center.</li>
<li><strong>delta</strong> &#8211; Value added to the filtered results before storing them.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies a separable linear filter to the image. That is, first, every row of <tt class="docutils literal"><span class="pre">src</span></tt> is filtered with the 1D kernel <tt class="docutils literal"><span class="pre">kernelX</span></tt> . Then, every column of the result is filtered with the 1D kernel <tt class="docutils literal"><span class="pre">kernelY</span></tt> . The final result shifted by <tt class="docutils literal"><span class="pre">delta</span></tt> is stored in <tt class="docutils literal"><span class="pre">dst</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></tt></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a>,
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></tt></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a></p>
</div>
</div>
<div class="section" id="smooth">
<h2>Smooth<a class="headerlink" href="#smooth" title="Permalink to this headline">¶</a></h2>
<p>Smooths the image in one of several ways.</p>
<dl class="cfunction">
<dt id="void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype, int size1, int size2, double sigma1, double sigma2)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSmooth</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>smoothtype</strong>=CV_GAUSSIAN, int <strong>size1</strong>=3, int <strong>size2</strong>=0, double <strong>sigma1</strong>=0, double <strong>sigma2</strong>=0 <big>)</big><a class="headerlink" href="#void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype, int size1, int size2, double sigma1, double sigma2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Smooth">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Smooth</tt><big>(</big>src, dst, smoothtype=CV_GAUSSIAN, param1=3, param2=0, param3=0, param4=0<big>)</big> &rarr; None<a class="headerlink" href="#cv.Smooth" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source image</li>
<li><strong>dst</strong> &#8211; The destination image</li>
<li><strong>smoothtype</strong> &#8211; <p>Type of the smoothing:</p>
<ul>
<li><strong>CV_BLUR_NO_SCALE</strong> linear convolution with  <img class="math" src="../../../_images/math/4361d8a9a2bd513dd5be73793b2a738e82737e8a.png" alt="\texttt{size1}\times\texttt{size2}"/>  box kernel (all 1&#8217;s). If you want to smooth different pixels with different-size box kernels, you can use the integral image that is computed using  <a class="reference internal" href="miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)" title="void integral(InputArray src, OutputArray sum, int sdepth)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">integral()</span></tt></a></li>
<li><strong>CV_BLUR</strong> linear convolution with  <img class="math" src="../../../_images/math/4361d8a9a2bd513dd5be73793b2a738e82737e8a.png" alt="\texttt{size1}\times\texttt{size2}"/>  box kernel (all 1&#8217;s) with subsequent scaling by  <img class="math" src="../../../_images/math/83787c0c1e1eebd1188b53412a8d1b310c6181b2.png" alt="1/(\texttt{size1}\cdot\texttt{size2})"/></li>
<li><strong>CV_GAUSSIAN</strong> linear convolution with a  <img class="math" src="../../../_images/math/4361d8a9a2bd513dd5be73793b2a738e82737e8a.png" alt="\texttt{size1}\times\texttt{size2}"/>  Gaussian kernel</li>
<li><strong>CV_MEDIAN</strong> median filter with a  <img class="math" src="../../../_images/math/919a5e248b00babab8e3bd9c411557331305b8f4.png" alt="\texttt{size1}\times\texttt{size1}"/>  square aperture</li>
<li><strong>CV_BILATERAL</strong> bilateral filter with a  <img class="math" src="../../../_images/math/919a5e248b00babab8e3bd9c411557331305b8f4.png" alt="\texttt{size1}\times\texttt{size1}"/>  square aperture, color sigma= <tt class="docutils literal"><span class="pre">sigma1</span></tt>  and spatial sigma= <tt class="docutils literal"><span class="pre">sigma2</span></tt> . If  <tt class="docutils literal"><span class="pre">size1=0</span></tt> , the aperture square side is set to  <tt class="docutils literal"><span class="pre">cvRound(sigma2*1.5)*2+1</span></tt> . Information about bilateral filtering can be found at  <a class="reference external" href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></li>
</ul>
</li>
<li><strong>size1</strong> &#8211; The first parameter of the smoothing operation, the aperture width. Must be a positive odd number (1, 3, 5, ...)</li>
<li><strong>size2</strong> &#8211; The second parameter of the smoothing operation, the aperture height. Ignored by  <tt class="docutils literal"><span class="pre">CV_MEDIAN</span></tt>  and  <tt class="docutils literal"><span class="pre">CV_BILATERAL</span></tt>  methods. In the case of simple scaled/non-scaled and Gaussian blur if  <tt class="docutils literal"><span class="pre">size2</span></tt>  is zero, it is set to  <tt class="docutils literal"><span class="pre">size1</span></tt> . Otherwise it must be a positive odd number.</li>
<li><strong>sigma1</strong> &#8211; <p>In the case of a Gaussian parameter this parameter may specify Gaussian  <img class="math" src="../../../_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/>  (standard deviation). If it is zero, it is calculated from the kernel size:</p>
<div class="math">
<p><img src="../../../_images/math/22b36e01e5518a63d4e642a7f29c5803def391d8.png" alt="\sigma  = 0.3 (n/2 - 1) + 0.8  \quad   \text{where}   \quad  n= \begin{array}{l l} \mbox{\texttt{size1} for horizontal kernel} \\ \mbox{\texttt{size2} for vertical kernel} \end{array}"/></p>
</div><p>Using standard sigma for small kernels ( <img class="math" src="../../../_images/math/7b5343f2d9e22816e8de24262565ff2937695b2c.png" alt="3\times 3"/>  to  <img class="math" src="../../../_images/math/d82a7109054f6068dbb1152f48bd109090f2c73d.png" alt="7\times 7"/> ) gives better speed. If  <tt class="docutils literal"><span class="pre">sigma1</span></tt>  is not zero, while  <tt class="docutils literal"><span class="pre">size1</span></tt>  and  <tt class="docutils literal"><span class="pre">size2</span></tt>  are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation).</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smooths an image using one of several methods. Every of the methods has some features and restrictions listed below:</p>
<blockquote>
<div><ul class="simple">
<li>Blur with no scaling works with single-channel images only and supports accumulation of 8-bit to 16-bit format (similar to <a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a> and <a class="reference internal" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Laplacian()</span></tt></a>) and 32-bit floating point to 32-bit floating-point format.</li>
<li>Simple blur and Gaussian blur support 1- or 3-channel, 8-bit and 32-bit floating point images. These two methods can process images in-place.</li>
<li>Median and bilateral filters work with 1- or 3-channel 8-bit images and can not process images in-place.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function is now obsolete. Use <a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a>, <a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></tt></a>, <a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></tt></a> or <a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></tt></a>.</p>
</div>
</div>
<div class="section" id="sobel">
<h2>Sobel<a class="headerlink" href="#sobel" title="Permalink to this headline">¶</a></h2>
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<dl class="function">
<dt id="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">Sobel</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, int <strong>dx</strong>, int <strong>dy</strong>, int <strong>ksize</strong>=3, double <strong>scale</strong>=1, double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Sobel">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">Sobel</tt><big>(</big>src, ddepth, dx, dy<span class="optional">[</span>, dst<span class="optional">[</span>, ksize<span class="optional">[</span>, scale<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.Sobel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvSobel</tt><big>(</big>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>xorder</strong>, int <strong>yorder</strong>, int <strong>aperture_size</strong>=3 <big>)</big><a class="headerlink" href="#void cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Sobel">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv.</tt><tt class="descname">Sobel</tt><big>(</big>src, dst, xorder, yorder, apertureSize=3<big>)</big> &rarr; None<a class="headerlink" href="#cv.Sobel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and the same number of channels as  <tt class="docutils literal"><span class="pre">src</span></tt> .</li>
<li><strong>ddepth</strong> &#8211; <dl class="docutils">
<dt>output image depth; the following combinations of <tt class="docutils literal"><span class="pre">src.depth()</span></tt> and <tt class="docutils literal"><span class="pre">ddepth</span></tt> are supported:</dt>
<dd><ul class="first last">
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_8U</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_16S</span></tt>/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_16U</span></tt>/<tt class="docutils literal"><span class="pre">CV_16S</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_32F</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_32F</span></tt>/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
<li><tt class="docutils literal"><span class="pre">src.depth()</span></tt> = <tt class="docutils literal"><span class="pre">CV_64F</span></tt>, <tt class="docutils literal"><span class="pre">ddepth</span></tt> = -1/<tt class="docutils literal"><span class="pre">CV_64F</span></tt></li>
</ul>
</dd>
</dl>
<p>when <tt class="docutils literal"><span class="pre">ddepth=-1</span></tt>, the destination image will have the same depth as the source; in the case of 8-bit input images it will result in truncated derivatives.</p>
</li>
<li><strong>xorder</strong> &#8211; order of the derivative x.</li>
<li><strong>yorder</strong> &#8211; order of the derivative y.</li>
<li><strong>ksize</strong> &#8211; size of the extended Sobel kernel; it must be 1, 3, 5, or 7.</li>
<li><strong>scale</strong> &#8211; optional scale factor for the computed derivative values; by default, no scaling is applied (see  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a> for details).</li>
<li><strong>delta</strong> &#8211; optional delta value that is added to the results prior to storing them in <tt class="docutils literal"><span class="pre">dst</span></tt>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>In all cases except one, the
<img class="math" src="../../../_images/math/914d7ea39f4c7e0d9de9f1555797b15080187868.png" alt="\texttt{ksize} \times
\texttt{ksize}"/> separable kernel is used to calculate the
derivative. When
<img class="math" src="../../../_images/math/88ffe3c7c14a1cfd0a77646431022940e22c8244.png" alt="\texttt{ksize = 1}"/> , the
<img class="math" src="../../../_images/math/b1b5c38967bbe07eb314a8bc1ae4f7951ebaffa1.png" alt="3 \times 1"/> or
<img class="math" src="../../../_images/math/47054764af9c891341022f5943cdd34c7a9a99ec.png" alt="1 \times 3"/> kernel is used (that is, no Gaussian smoothing is done). <tt class="docutils literal"><span class="pre">ksize</span> <span class="pre">=</span> <span class="pre">1</span></tt> can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value <tt class="docutils literal"><span class="pre">ksize</span> <span class="pre">=</span> <span class="pre">CV_SCHARR</span></tt> (-1) that corresponds to the
<img class="math" src="../../../_images/math/77d7104f34af16053b63ce7cfa87265d915c6105.png" alt="3\times3"/> Scharr
filter that may give more accurate results than the
<img class="math" src="../../../_images/math/77d7104f34af16053b63ce7cfa87265d915c6105.png" alt="3\times3"/> Sobel. The Scharr aperture is</p>
<div class="math">
<p><img src="../../../_images/math/4dbe0b579aa4ab5941e8d44e383c203cf7e96288.png" alt="\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}"/></p>
</div><p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<div class="math">
<p><img src="../../../_images/math/29e7251a59fec8e0639e840adefeecfa6ade6464.png" alt="\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}"/></p>
</div><p>The Sobel operators combine Gaussian smoothing and differentiation,
so the result is more or less resistant to the noise. Most often,
the function is called with ( <tt class="docutils literal"><span class="pre">xorder</span></tt> = 1, <tt class="docutils literal"><span class="pre">yorder</span></tt> = 0, <tt class="docutils literal"><span class="pre">ksize</span></tt> = 3) or ( <tt class="docutils literal"><span class="pre">xorder</span></tt> = 0, <tt class="docutils literal"><span class="pre">yorder</span></tt> = 1, <tt class="docutils literal"><span class="pre">ksize</span></tt> = 3) to calculate the first x- or y- image
derivative. The first case corresponds to a kernel of:</p>
<div class="math">
<p><img src="../../../_images/math/fcbe094371d6870bd2624e6ca2aa6bf0d472ee6a.png" alt="\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}"/></p>
</div><p>The second case corresponds to a kernel of:</p>
<div class="math">
<p><img src="../../../_images/math/c1cc7a0f82a0772a91a25fcd4cc6ad624ccb6e24.png" alt="\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}"/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></tt></a>,
<a class="reference internal" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Laplacian()</span></tt></a>,
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></tt></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></tt></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a></p>
</div>
</div>
<div class="section" id="scharr">
<h2>Scharr<a class="headerlink" href="#scharr" title="Permalink to this headline">¶</a></h2>
<p>Calculates the first x- or y- image derivative using Scharr operator.</p>
<dl class="function">
<dt id="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">Scharr</tt><big>(</big>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, int <strong>dx</strong>, int <strong>dy</strong>, double <strong>scale</strong>=1, double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <big>)</big><a class="headerlink" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Scharr">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">Scharr</tt><big>(</big>src, ddepth, dx, dy<span class="optional">[</span>, dst<span class="optional">[</span>, scale<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; dst<a class="headerlink" href="#cv2.Scharr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and the same number of channels as <tt class="docutils literal"><span class="pre">src</span></tt>.</li>
<li><strong>ddepth</strong> &#8211; output image depth (see <a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></tt></a> for the list of supported combination of <tt class="docutils literal"><span class="pre">src.depth()</span></tt> and <tt class="docutils literal"><span class="pre">ddepth</span></tt>).</li>
<li><strong>dx</strong> &#8211; order of the derivative x.</li>
<li><strong>dy</strong> &#8211; order of the derivative y.</li>
<li><strong>scale</strong> &#8211; optional scale factor for the computed derivative values; by default, no scaling is applied (see  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></tt></a> for details).</li>
<li><strong>delta</strong> &#8211; optional delta value that is added to the results prior to storing them in <tt class="docutils literal"><span class="pre">dst</span></tt>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></tt></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p>
<div class="math">
<p><img src="../../../_images/math/3de0ddbf5f785206a53c963cdea3e290c7e964ba.png" alt="\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}"/></p>
</div><p>is equivalent to</p>
<div class="math">
<p><img src="../../../_images/math/e296da6b2379090cf761f0bb832a82c4ddb1c2f3.png" alt="\texttt{Sobel(src, dst, ddepth, dx, dy, CV\_SCHARR, scale, delta, borderType)} ."/></p>
</div><div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../core/doc/operations_on_arrays.html#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></tt></a></p>
</div>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Image Filtering</a><ul>
<li><a class="reference internal" href="#basecolumnfilter">BaseColumnFilter</a></li>
<li><a class="reference internal" href="#basefilter">BaseFilter</a></li>
<li><a class="reference internal" href="#baserowfilter">BaseRowFilter</a></li>
<li><a class="reference internal" href="#filterengine">FilterEngine</a></li>
<li><a class="reference internal" href="#bilateralfilter">bilateralFilter</a></li>
<li><a class="reference internal" href="#adaptivebilateralfilter">adaptiveBilateralFilter</a></li>
<li><a class="reference internal" href="#blur">blur</a></li>
<li><a class="reference internal" href="#borderinterpolate">borderInterpolate</a></li>
<li><a class="reference internal" href="#boxfilter">boxFilter</a></li>
<li><a class="reference internal" href="#buildpyramid">buildPyramid</a></li>
<li><a class="reference internal" href="#copymakeborder">copyMakeBorder</a></li>
<li><a class="reference internal" href="#createboxfilter">createBoxFilter</a></li>
<li><a class="reference internal" href="#createderivfilter">createDerivFilter</a></li>
<li><a class="reference internal" href="#creategaussianfilter">createGaussianFilter</a></li>
<li><a class="reference internal" href="#createlinearfilter">createLinearFilter</a></li>
<li><a class="reference internal" href="#createmorphologyfilter">createMorphologyFilter</a></li>
<li><a class="reference internal" href="#createseparablelinearfilter">createSeparableLinearFilter</a></li>
<li><a class="reference internal" href="#dilate">dilate</a></li>
<li><a class="reference internal" href="#erode">erode</a></li>
<li><a class="reference internal" href="#filter2d">filter2D</a></li>
<li><a class="reference internal" href="#gaussianblur">GaussianBlur</a></li>
<li><a class="reference internal" href="#getderivkernels">getDerivKernels</a></li>
<li><a class="reference internal" href="#getgaussiankernel">getGaussianKernel</a></li>
<li><a class="reference internal" href="#getkerneltype">getKernelType</a></li>
<li><a class="reference internal" href="#getstructuringelement">getStructuringElement</a></li>
<li><a class="reference internal" href="#medianblur">medianBlur</a></li>
<li><a class="reference internal" href="#morphologyex">morphologyEx</a></li>
<li><a class="reference internal" href="#laplacian">Laplacian</a></li>
<li><a class="reference internal" href="#pyrdown">pyrDown</a></li>
<li><a class="reference internal" href="#pyrup">pyrUp</a></li>
<li><a class="reference internal" href="#pyrmeanshiftfiltering">pyrMeanShiftFiltering</a></li>
<li><a class="reference internal" href="#sepfilter2d">sepFilter2D</a></li>
<li><a class="reference internal" href="#smooth">Smooth</a></li>
<li><a class="reference internal" href="#sobel">Sobel</a></li>
<li><a class="reference internal" href="#scharr">Scharr</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="imgproc.html"
                        title="previous chapter">imgproc. Image Processing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="geometric_transformations.html"
                        title="next chapter">Geometric Image Transformations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/modules/imgproc/doc/filtering.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="geometric_transformations.html" title="Geometric Image Transformations"
             >next</a> |</li>
        <li class="right" >
          <a href="imgproc.html" title="imgproc. Image Processing"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.9.0 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" >imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Apr 21, 2014.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>